<!DOCTYPE html>
<html lang="en">
    <head>
        
    
    <link rel='stylesheet' href="/./css/dracula.css">

        <title>Graph Theory</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=2.0">
<link rel="stylesheet" href="/css/style.css">
<link rel="shortcut icon" href="/favicon.ico">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="manifest" href="/site.webmanifest">

    <meta name="generator" content="Hexo 7.3.0"></head>
    <body>
        <header class="al_header al_pos_fixed">
    <div class="al_header_container dis_flex_jcenter">
        <div class="al_header_container_left">
            <div class="al_header_site_title">
                <a href="/">Make1tRight</a>
            </div>
        </div>

        <div class="dis_flex_jcenter">
            <div class="al_header_setting">
                <svg class="al_header_icon">
                    <use xmlns="http://www.w3.org/2000/svg" xlink:href="/assets/svg_icons.svg#svg-menu"></use>
                </svg>
            </div>
        </div>
    </div>
</header>

        <div class="al_sidebar">

    <div class="al_sidebar_overlay al_full_cover"></div>

    <div class="al_pos_fixed al_sidebar_cnt">
        <div class="dis_flex_acenter al_sidebar_header">
            <h3>Make1tRight</h3>
            <div class="al_sidebar_close al_header_setting">
                <svg class="al_header_icon">
                    <use xmlns="http://www.w3.org/2000/svg" xlink:href="/assets/svg_icons.svg#svg-close"></use>
                </svg>
            </div>
        </div>

        <div class="al_sidebar_author_cnt">

            <div class="al_sidebar_author_info">
                <h4></h4>
                <img class="al_sidebar_avatar" src="https://yourAvatorURL">
                <p>Make things straight, make things right.</p>
            </div>

            
        </div>
    </div>
</div>

        
    <div class="dis_flex_center al_lightbox_cnt al_full_cover">
        <img class="al_lightbox_img"/>
    </div>
    <div class="al_page_background dis_flex_center al_full_cover"></div>
    <div class="al_page_container">
        <div class="al_pos_ab al_fake_background"></div>
        <div class="al_main_container al_shadow al_main_page_container">
            <article class="al_article">
                <header>
                    <h1 class="al_page_title">
                        Graph Theory
                    </h1>
                    <div class="al_page_info dis_flex">
                        <div class="al_page_content_info">
                            Mon November 4, 2024 10:17 PM
                        </div>

                        

                        
                        <span class="tags"></span>
                    </div>
                </header>

                
                    <div class="al_page_content_outline">
                        <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%80%E6%9C%89%E5%8F%AF%E8%BE%BE%E8%B7%AF%E5%BE%84-%E6%B7%B1%E6%90%9C"><span class="toc-text">所有可达路径 - 深搜</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F-%E6%B7%B1%E6%90%9C-%E5%B9%BF%E6%90%9C"><span class="toc-text">岛屿数量 - 深搜&#x2F;广搜</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF"><span class="toc-text">岛屿的最大面积</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%A4%E5%B2%9B%E7%9A%84%E6%80%BB%E9%9D%A2%E7%A7%AF-%E6%B7%B1%E6%90%9C-%E5%B9%BF%E6%90%9C"><span class="toc-text">孤岛的总面积 - 深搜&#x2F;广搜</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B2%89%E6%B2%A1%E5%AD%A4%E5%B2%9B-%E6%B7%B1%E6%90%9C-%E5%B9%BF%E6%90%9C"><span class="toc-text">沉没孤岛 - 深搜&#x2F;广搜</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B0%B4%E6%B5%81%E9%97%AE%E9%A2%98-%E6%B7%B1%E6%90%9C-%E5%B9%BF%E6%90%9C"><span class="toc-text">水流问题 - 深搜&#x2F;广搜</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E9%80%A0%E6%9C%80%E5%A4%A7%E5%B7%A5%E5%B2%9B"><span class="toc-text">建造最大工岛</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%A5%E9%BE%99"><span class="toc-text">字符串接龙</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E5%AE%8C%E5%85%A8%E5%8F%AF%E8%BE%BE%E6%80%A7-%E5%B9%BF%E6%90%9C-%E6%B7%B1%E6%90%9C"><span class="toc-text">有向图的完全可达性 - 广搜&#x2F;深搜</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B2%9B%E5%B1%BF%E7%9A%84%E5%91%A8%E9%95%BF"><span class="toc-text">岛屿的周长</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E5%AD%98%E5%9C%A8%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="toc-text">寻找存在的路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5"><span class="toc-text">冗余连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5%E2%85%A1"><span class="toc-text">冗余连接Ⅱ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#prim%E7%AE%97%E6%B3%95"><span class="toc-text">prim算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Kruskal%E7%AE%97%E6%B3%95"><span class="toc-text">Kruskal算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%9E%84%E5%BB%BA-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-text">软件构建 - 拓扑排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dijkstra%E7%AE%97%E6%B3%95-%E6%9C%B4%E7%B4%A0%E7%89%88-%E5%A0%86%E4%BC%98%E5%8C%96"><span class="toc-text">dijkstra算法 - 朴素版&#x2F;堆优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bellman-ford%E7%AE%97%E6%B3%95%EF%BC%88%E8%BE%B9%E8%A7%86%E8%A7%92%E3%80%81%E8%BE%B9%E8%A7%86%E8%A7%92%E3%80%81%E8%BE%B9%E8%A7%86%E8%A7%92%EF%BC%89"><span class="toc-text">Bellman_ford算法（边视角、边视角、边视角）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Floyd%E7%AE%97%E6%B3%95"><span class="toc-text">Floyd算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#A-%E7%AE%97%E6%B3%95"><span class="toc-text">A*算法</span></a></li></ol>
                    </div>
                

                
                <section id="post-body">
                    <p><img src="/../images/GraphSummary.png" alt="GraphTheoryMindMap"></p>
<h3 id="所有可达路径-深搜"><a href="#所有可达路径-深搜" class="headerlink" title="所有可达路径 - 深搜"></a>所有可达路径 - 深搜</h3><ol>
<li>先把与边界相邻的陆地作额外标记，然后统一处理邻接矩阵</li>
<li>图可以用邻接矩阵vector&lt;vector<int>&gt;或者邻接表vector&lt;list<int>&gt;来实现</li>
<li>深搜的写法：<ol>
<li>邻接矩阵需要加if语句检查出发点所在行有哪些列能到达，邻接表中每个list都是能到达的部分所以不用检查，直接加入到path中检查下一个节点即可</li>
<li>递归结束、回收结果的条件是起点等于终点；每层递归要记得回溯</li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">    que.<span class="built_in">push</span>(start);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> node = que.<span class="built_in">front</span>(); que.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= end; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[node][i] == <span class="number">1</span>) &#123;</span><br><span class="line">                path.<span class="built_in">push_back</span>(i);</span><br><span class="line">                <span class="keyword">if</span> (i == end) &#123;</span><br><span class="line">                    result.<span class="built_in">push_back</span>(path);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                que.<span class="built_in">push</span>(i);       </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="comment">// 用邻接矩阵表达节点之间的关系</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">grid</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> s, t;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">        grid[s][t] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result.<span class="built_in">clear</span>();</span><br><span class="line">    path.<span class="built_in">clear</span>();</span><br><span class="line">    path.<span class="built_in">push_back</span>(<span class="number">1</span>);<span class="comment">//题目要求, 所有的点都从1开始</span></span><br><span class="line">    <span class="built_in">bfs</span>(grid, <span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; pa : result) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; pa.<span class="built_in">size</span>() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">                cout &lt;&lt; pa[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; pa[pa.<span class="built_in">size</span>() - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="岛屿数量-深搜-广搜"><a href="#岛屿数量-深搜-广搜" class="headerlink" title="岛屿数量 - 深搜&#x2F;广搜"></a>岛屿数量 - 深搜&#x2F;广搜</h3><ol>
<li>visited数组保证了我们不会重复对一个区域进行搜索</li>
<li>输入的时候不指定一个变量暂存，直接cin到数组的目标元素位置也是可以的</li>
<li>广搜&#x2F;深搜开始和结束的时机是怎样的？<ol>
<li>没有访问到 + 当前位置是陆地 -&gt; !visited[i][j] &amp;&amp; grid[i][j] &#x3D;&#x3D; 1 -&gt; 开始</li>
<li>这里每次触发广搜&#x2F;深搜都是因为碰到了陆地，要把相邻的1合并起来统计</li>
<li>下一片区域是水、到达地图的4个边界 -&gt; 停止</li>
</ol>
</li>
<li>深搜在做什么 - 递归标记相邻的陆地<ol>
<li>没有访问到 + 当前位置是陆地 -&gt; !visited[i][j] &amp;&amp; grid[i][j] &#x3D;&#x3D; 1 -&gt; 开始深搜</li>
<li>深搜到下一片区域是水、到达地图的4个边界 -&gt; 停止深搜</li>
</ol>
</li>
<li>广搜在做什么 - 维护一个队列，作用也是标记相邻陆地<ol>
<li>只有满足条件的元素才能被加入到队列中</li>
<li>广搜要把标记元素与元素入队两个操作合并起来，避免重复加入元素</li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> nextx = x + dir[i][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> nexty = y + dir[i][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nextx &lt; <span class="number">0</span> || nextx &gt;= grid.<span class="built_in">size</span>() || nexty &lt; <span class="number">0</span> || nexty &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>()) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (!visited[nextx][nexty] &amp;&amp; grid[nextx][nexty] == <span class="number">1</span>) &#123;</span><br><span class="line">            visited[nextx][nexty] = <span class="literal">true</span>;</span><br><span class="line">            ++count;</span><br><span class="line">            <span class="built_in">dfs</span>(grid, visited, nextx, nexty);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">grid</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m, <span class="number">0</span>));</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">visited</span>(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(m, <span class="literal">false</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">            cin &gt;&gt; grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i][j] &amp;&amp; grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">                count = <span class="number">1</span>;  <span class="comment">//这里是1, 因为岛屿的第一块面积数没有算进去</span></span><br><span class="line">                <span class="built_in">dfs</span>(grid, visited, i, j);</span><br><span class="line">                result = <span class="built_in">max</span>(result, count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="岛屿的最大面积"><a href="#岛屿的最大面积" class="headerlink" title="岛屿的最大面积"></a>岛屿的最大面积</h3><ol>
<li>在搜索过程中记录1的数量，结果取最大值，只是应用不同</li>
<li>深搜&#x2F;广搜代码实现</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; que;</span><br><span class="line">    que.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cur = que.<span class="built_in">front</span>(); que.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> nextx = cur.first + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> nexty = cur.second + dir[i][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nextx &lt; <span class="number">0</span> || nextx &gt;= grid.<span class="built_in">size</span>() || nexty &lt; <span class="number">0</span> || nexty &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>()) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (!visited[nextx][nexty] &amp;&amp; grid[nextx][nexty] == <span class="number">1</span>) &#123;</span><br><span class="line">                grid[nextx][nexty] = <span class="number">0</span>;</span><br><span class="line">                visited[nextx][nexty] = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">bfs</span>(grid, visited, nextx, nexty);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">grid</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m, <span class="number">0</span>));</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">visited</span>(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(m, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">            cin &gt;&gt; grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for (int i = 0; i &lt; n; ++i) bfs(grid, visited, i, 0);</span></span><br><span class="line">    <span class="comment">// // for (int i = 0; i &lt; n; ++i) bfs(grid, visited, i, m - 1);</span></span><br><span class="line">    <span class="comment">// for (int j = 0; j &lt; m; ++j) bfs(grid, visited, 0, j);</span></span><br><span class="line">    <span class="comment">// for (int j = 0; j &lt; m; ++j) bfs(grid, visited, n - 1, j);</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">bfs</span>(grid, visited, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">bfs</span>(grid, visited, n - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">bfs</span>(grid, visited, <span class="number">0</span>, m - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">bfs</span>(grid, visited, n - <span class="number">1</span>, m - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// for (int i = 0; i &lt; n; ++i) &#123;</span></span><br><span class="line">    <span class="comment">//     for (int j = 0; j &lt; m; ++j) &#123;</span></span><br><span class="line">    <span class="comment">//         cout &lt;&lt; grid[i][j] &lt;&lt; &quot; &quot;;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// &#125;   </span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i][j] &amp;&amp; grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                ++result;</span><br><span class="line">                visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">bfs</span>(grid, visited, i, j);   <span class="comment">//这里是为了把相邻的陆地给加上, 算作同一片陆地</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="孤岛的总面积-深搜-广搜"><a href="#孤岛的总面积-深搜-广搜" class="headerlink" title="孤岛的总面积 - 深搜&#x2F;广搜"></a>孤岛的总面积 - 深搜&#x2F;广搜</h3><ol>
<li>邻接矩阵+深搜&#x2F;广搜；深搜广搜其实作用都是把附近区域的陆地看作一个整体共同处理</li>
<li>先把边界相邻的陆地去掉，后统计中间陆地的面积（用count）</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    grid[x][y] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> nextx = x + dir[i][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> nexty = y + dir[i][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nextx &lt; <span class="number">0</span> || nextx &gt;= grid.<span class="built_in">size</span>() || nexty &lt; <span class="number">0</span> || nexty &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>()) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (!visited[nextx][nexty] &amp;&amp; grid[nextx][nexty] == <span class="number">1</span>) &#123;</span><br><span class="line">            visited[nextx][nexty] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(grid, visited, nextx, nexty);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    grid[x][y] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; que;</span><br><span class="line">    que.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cur = que.<span class="built_in">front</span>(); que.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> nextx = cur.first + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> nexty = cur.second + dir[i][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nextx &lt; <span class="number">0</span> || nextx &gt;= grid.<span class="built_in">size</span>() || nexty &lt; <span class="number">0</span> || nexty &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>()) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!visited[nextx][nexty] &amp;&amp; grid[nextx][nexty] == <span class="number">1</span>) &#123;</span><br><span class="line">                visited[nextx][nexty] = <span class="literal">true</span>;</span><br><span class="line">                ++count;</span><br><span class="line">                que.<span class="built_in">push</span>(&#123;nextx, nexty&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">grid</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m, <span class="number">0</span>));</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">visited</span>(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(m, <span class="literal">false</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">            cin &gt;&gt; grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid[i][<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">            visited[i][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(grid, visited, i, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid[i][m - <span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">            visited[i][m - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(grid, visited, i, m - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid[<span class="number">0</span>][j] == <span class="number">1</span>) &#123;</span><br><span class="line">            visited[<span class="number">0</span>][j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(grid, visited, <span class="number">0</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid[n - <span class="number">1</span>][j] == <span class="number">1</span>) &#123;</span><br><span class="line">            visited[n - <span class="number">1</span>][j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(grid, visited, n - <span class="number">1</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) grid[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">2</span>) grid[i][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">            cout &lt;&lt; grid[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="沉没孤岛-深搜-广搜"><a href="#沉没孤岛-深搜-广搜" class="headerlink" title="沉没孤岛 - 深搜&#x2F;广搜"></a>沉没孤岛 - 深搜&#x2F;广搜</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    grid[x][y] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> nextx = x + dir[i][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> nexty = y + dir[i][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nextx &lt; <span class="number">0</span> || nextx &gt;= grid.<span class="built_in">size</span>() || nexty &lt; <span class="number">0</span> || nexty &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>()) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (!visited[nextx][nexty] &amp;&amp; grid[nextx][nexty] == <span class="number">1</span>) &#123;</span><br><span class="line">            visited[nextx][nexty] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(grid, visited, nextx, nexty);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    grid[x][y] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; que;</span><br><span class="line">    que.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cur = que.<span class="built_in">front</span>(); que.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> nextx = cur.first + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> nexty = cur.second + dir[i][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nextx &lt; <span class="number">0</span> || nextx &gt;= grid.<span class="built_in">size</span>() || nexty &lt; <span class="number">0</span> || nexty &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>()) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!visited[nextx][nexty] &amp;&amp; grid[nextx][nexty] == <span class="number">1</span>) &#123;</span><br><span class="line">                visited[nextx][nexty] = <span class="literal">true</span>;</span><br><span class="line">                grid[nextx][nexty] = <span class="number">2</span>;</span><br><span class="line">                que.<span class="built_in">push</span>(&#123;nextx, nexty&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">grid</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m, <span class="number">0</span>));</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">visited</span>(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(m, <span class="literal">false</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">            cin &gt;&gt; grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid[i][<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">            visited[i][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">bfs</span>(grid, visited, i, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid[i][m - <span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">            visited[i][m - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">bfs</span>(grid, visited, i, m - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid[<span class="number">0</span>][j] == <span class="number">1</span>) &#123;</span><br><span class="line">            visited[<span class="number">0</span>][j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">bfs</span>(grid, visited, <span class="number">0</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid[n - <span class="number">1</span>][j] == <span class="number">1</span>) &#123;</span><br><span class="line">            visited[n - <span class="number">1</span>][j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">bfs</span>(grid, visited, n - <span class="number">1</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) grid[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">2</span>) grid[i][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">            cout &lt;&lt; grid[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="水流问题-深搜-广搜"><a href="#水流问题-深搜-广搜" class="headerlink" title="水流问题 - 深搜&#x2F;广搜"></a>水流问题 - 深搜&#x2F;广搜</h3><ol>
<li>如何统计一个点既存在于第一border又存在于第二border，直接&amp;&amp;两个数组就可以</li>
<li>使用两个数组传入visited来分隔两次遍历，让两个边界上能到达的结果互不影响</li>
<li>使用广搜的时候记得要把所有加入到队列里面的节点都进行标记</li>
<li>起点和终点可以互换，开始可以当作结尾，结尾可以当作开始</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (visited[x][y]) <span class="keyword">return</span>;</span><br><span class="line">    visited[x][y] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> nextx = x + dir[i][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> nexty = y + dir[i][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nextx &lt; <span class="number">0</span> || nextx &gt;= n || nexty &lt; <span class="number">0</span> || nexty &gt;= m) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (grid[x][y] &lt;= grid[nextx][nexty]) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(grid, visited, nextx, nexty);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; que;</span><br><span class="line">    que.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">    visited[x][y] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cur = que.<span class="built_in">front</span>(); que.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> nextx = cur.first + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> nexty = cur.second + dir[i][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nextx &lt; <span class="number">0</span> || nextx &gt;= n || nexty &lt; <span class="number">0</span> || nexty &gt;= m) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (!visited[nextx][nexty] </span><br><span class="line">                &amp;&amp; grid[cur.first][cur.second] &lt;= grid[nextx][nexty]) &#123;</span><br><span class="line">                visited[nextx][nexty] = <span class="literal">true</span>;</span><br><span class="line">                que.<span class="built_in">push</span>(&#123;nextx, nexty&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">grid</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m, <span class="number">0</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">            cin &gt;&gt; grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">firstBorder</span>(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(m, <span class="literal">false</span>));</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">secondBorder</span>(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(m, <span class="literal">false</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">bfs</span>(grid, firstBorder, i, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">bfs</span>(grid, secondBorder, i, m - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">        <span class="built_in">bfs</span>(grid, firstBorder, <span class="number">0</span>, j);</span><br><span class="line">        <span class="built_in">bfs</span>(grid, secondBorder, n - <span class="number">1</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (firstBorder[i][j] &amp;&amp; secondBorder[i][j]) &#123;</span><br><span class="line">                cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="建造最大工岛"><a href="#建造最大工岛" class="headerlink" title="建造最大工岛"></a>建造最大工岛</h3><ol>
<li>避免重复遍历的方法，visit避免在深搜的过程中重复遍历每一个grid；visitedGrid避免在加入新陆地的时候重复加入相邻岛屿面积</li>
<li>因为每次只加入一次相邻岛屿面积，所以如何计算相邻岛屿面积、如何存储相邻岛屿面积也很重要<ol>
<li>用mark标记不同岛屿，作为岛屿编号</li>
<li>用关联容器unordered_map&lt;int, int&gt;记录岛屿编号和面积之间的关系<ol>
<li>为什么？</li>
<li>因为unordered_map和unordered_set两种无序容器的增删效率和查询效率都是O(1)</li>
</ol>
</li>
<li>加入新岛屿后，往4个方向各试探一次，然后每次取面积最大值result并且重置count、visitedGrid</li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, m, count;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> mark)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (visited[x][y]) <span class="keyword">return</span>;</span><br><span class="line">    visited[x][y] = <span class="literal">true</span>;</span><br><span class="line">    grid[x][y] = mark;</span><br><span class="line">    ++count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> nextx = x + dir[i][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> nexty = y + dir[i][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nextx &lt; <span class="number">0</span> || nextx &gt;= n || nexty &lt; <span class="number">0</span> || nexty &gt;= m) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (grid[nextx][nexty] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(grid, visited, nextx, nexty, mark);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> mark)</span> </span>&#123;</span><br><span class="line">    queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; que;</span><br><span class="line">    que.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">    visited[x][y] = <span class="literal">true</span>;</span><br><span class="line">    grid[x][y] = mark;</span><br><span class="line">    ++count;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cur = que.<span class="built_in">front</span>(); que.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> nextx = cur.first + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> nexty = cur.second + dir[i][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nextx &lt; <span class="number">0</span> || nextx &gt;= n || nexty &lt; <span class="number">0</span> || nexty &gt;= m) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (!visited[nextx][nexty] </span><br><span class="line">                &amp;&amp; grid[nextx][nexty] == <span class="number">1</span>) &#123;</span><br><span class="line">                visited[nextx][nexty] = <span class="literal">true</span>;</span><br><span class="line">                grid[nextx][nexty] = mark;</span><br><span class="line">                ++count;</span><br><span class="line">                que.<span class="built_in">push</span>(&#123;nextx, nexty&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">grid</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m, <span class="number">0</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">            cin &gt;&gt; grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">visited</span>(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(m, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> isAllGrid = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> mark = <span class="number">2</span>;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; gridNum;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span>) isAllGrid = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i][j] &amp;&amp; grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">bfs</span>(grid, visited, i, j, mark);</span><br><span class="line">                gridNum[mark] = count;</span><br><span class="line">                ++mark;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isAllGrid) &#123;</span><br><span class="line">        cout &lt;&lt; n * m &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; visitedGrid;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                visitedGrid.<span class="built_in">clear</span>();</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">                    <span class="type">int</span> neari = i + dir[k][<span class="number">0</span>];</span><br><span class="line">                    <span class="type">int</span> nearj = j + dir[k][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (neari &lt; <span class="number">0</span> || neari &gt;= n || nearj &lt; <span class="number">0</span> || nearj &gt;= m) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (visitedGrid.<span class="built_in">count</span>(grid[neari][nearj])) <span class="keyword">continue</span>;</span><br><span class="line">                    count += gridNum[grid[neari][nearj]];</span><br><span class="line">                    visitedGrid.<span class="built_in">insert</span>(grid[neari][nearj]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result = <span class="built_in">max</span>(result, count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符串接龙"><a href="#字符串接龙" class="headerlink" title="字符串接龙"></a>字符串接龙</h3><ol>
<li>用unordered_map去记录经过哪些字符，路径的长度；避免重复遍历的同时，记录了结果</li>
<li>主要是把路径长度和字符串关联起来了</li>
<li>广度优先遍历搜索到的结果就是最短路径，如果使用深搜还要取路径最小值</li>
<li>每次只能够换一个字符， 所以必须有一个word的拷贝，而不是直接用word去换；如果直接用word去换，遍历所有位置，每个位置从a-&gt;z，外层for循环走完了字符串也就换完了，用不到队列</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    unordered_set&lt;string&gt; strList;</span><br><span class="line"></span><br><span class="line">    string beginStr, endStr, str;</span><br><span class="line">    cin &gt;&gt; beginStr &gt;&gt; endStr;</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        cin &gt;&gt; str;</span><br><span class="line">        strList.<span class="built_in">insert</span>(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unordered_map&lt;string, <span class="type">int</span>&gt; visitedMap;</span><br><span class="line">    visitedMap.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;string, <span class="type">int</span>&gt;(beginStr, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    queue&lt;string&gt; que;</span><br><span class="line">    que.<span class="built_in">push</span>(beginStr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        string word = que.<span class="built_in">front</span>(); que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> path = visitedMap[word];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; word.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; ++j) &#123;</span><br><span class="line">                string newWord = word;  <span class="comment">//每次换一位, 如果直接使用word的话</span></span><br><span class="line">                newWord[i] = j + <span class="string">&#x27;a&#x27;</span>;   <span class="comment">//遍历一次word所有位置的字符串就能换完了, 所以path原始值+1就能搞定</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (newWord == endStr) &#123;</span><br><span class="line">                    cout &lt;&lt; path + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (visitedMap.<span class="built_in">find</span>(newWord) == visitedMap.<span class="built_in">end</span>()   <span class="comment">//只能1次</span></span><br><span class="line">                    &amp;&amp; strList.<span class="built_in">find</span>(newWord) != strList.<span class="built_in">end</span>()) &#123;   <span class="comment">//在strlist里面</span></span><br><span class="line">                    visitedMap.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;string, <span class="type">int</span>&gt;(newWord, path + <span class="number">1</span>));</span><br><span class="line">                    que.<span class="built_in">push</span>(newWord);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="有向图的完全可达性-广搜-深搜"><a href="#有向图的完全可达性-广搜-深搜" class="headerlink" title="有向图的完全可达性 - 广搜&#x2F;深搜"></a>有向图的完全可达性 - 广搜&#x2F;深搜</h3><ol>
<li>并查集不适用于有向图，只适用于无向图连通性的检查</li>
<li>list不支持随机访问，也就是不支持下标访问，只能顺序遍历</li>
<li>一个flag不够表明所有节点都能到达，需要用一个数组来组织所有的flag，这题的关键也就是visited没想到</li>
<li>深搜的dfs函数实现要想清楚是判断当前节点还是判断下一个节点；深搜是用栈、广搜是用队列，两个时间复杂度其实差不多，深搜用栈空间复杂度会稍微小一点</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> vector&lt;list&lt;<span class="type">int</span>&gt;&gt;&amp; graph, vector&lt;<span class="type">bool</span>&gt;&amp; visited, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (visited[key]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[key] = <span class="literal">true</span>;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; keys = graph[key];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = keys.<span class="built_in">begin</span>(); it != keys.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; key &lt;&lt; &quot;-&gt;&quot; &lt;&lt; *it &lt;&lt; endl;</span></span><br><span class="line">        <span class="built_in">dfs</span>(graph, visited, *it);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;list&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">graph</span>(n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> s, t;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">        graph[s].<span class="built_in">push_back</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> key : graph[i]) &#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt;<span class="string">&quot; -&gt; &quot;</span> &lt;&lt; key &lt;&lt; endl; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(n + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(graph, visited, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = visited.<span class="built_in">begin</span>() + <span class="number">1</span>; it != visited.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*it == <span class="literal">false</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="岛屿的周长"><a href="#岛屿的周长" class="headerlink" title="岛屿的周长"></a>岛屿的周长</h3><ol>
<li>遍历邻接矩阵的每一个单位，每次往4个方向试探，碰到边界或者碰到水域就把计数+1</li>
<li>不需要广搜或者深搜</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">grid</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m, <span class="number">0</span>));</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">visited</span>(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(m, <span class="literal">false</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">            cin &gt;&gt; grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">                    <span class="type">int</span> neari = i + dir[k][<span class="number">0</span>];</span><br><span class="line">                    <span class="type">int</span> nearj = j + dir[k][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (neari &lt; <span class="number">0</span> </span><br><span class="line">                        || neari &gt;= n </span><br><span class="line">                        || nearj &lt; <span class="number">0</span></span><br><span class="line">                        || nearj &gt;= m</span><br><span class="line">                        || grid[neari][nearj] == <span class="number">0</span>) &#123;</span><br><span class="line">                        ++count;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; count &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="寻找存在的路径"><a href="#寻找存在的路径" class="headerlink" title="寻找存在的路径"></a>寻找存在的路径</h3><ol>
<li>并查集的初始化、连接、判断连通性、路径压缩</li>
<li>father数组可以按照n的大小来定，索引正好对应节点的编号</li>
<li>father数组初始化的时候要注意在节点编号范围外</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">father</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == father[value]) &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(father[value]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> lhs, <span class="type">int</span> rhs)</span> </span>&#123;</span><br><span class="line">    lhs = <span class="built_in">find</span>(lhs);</span><br><span class="line">    rhs = <span class="built_in">find</span>(rhs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lhs == rhs) <span class="keyword">return</span>;</span><br><span class="line">    father[rhs] = lhs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isIdentical</span><span class="params">(<span class="type">int</span> lhs, <span class="type">int</span> rhs)</span> </span>&#123;</span><br><span class="line">    lhs = <span class="built_in">find</span>(lhs);</span><br><span class="line">    rhs = <span class="built_in">find</span>(rhs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lhs == rhs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> s, t;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">        <span class="built_in">join</span>(s, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> source, destination;</span><br><span class="line">    cin &gt;&gt; source &gt;&gt; destination;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isIdentical</span>(source, destination)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="冗余连接"><a href="#冗余连接" class="headerlink" title="冗余连接"></a>冗余连接</h3><ol>
<li>看哪一对已经在树里面（已经加入了并查集），仍然要重复加入，就将那一对节点直接输出</li>
<li>并查集就是检查连通性的，检查两个节点是否在一个集合里面；因为这两个节点不一定直接相连，有可能间隔了几个节点，并查集最重要的作用就是做路径压缩，直接判断这两个节点是否有公共的“父节点”</li>
</ol>
<h3 id="冗余连接Ⅱ"><a href="#冗余连接Ⅱ" class="headerlink" title="冗余连接Ⅱ"></a>冗余连接Ⅱ</h3><ol>
<li>让有向图变成一颗树，要处理的三种情况：<ol>
<li>有环，这个时候每个节点的入度和出度都是1，要删除掉构成环的那条边，这里用并查集来找环</li>
<li>有入度为2的节点<ol>
<li>只能删一条边，删另外一条边这个图就构不成树，用isTreeAfterRemoveEdge函数来判断</li>
<li>两条边都能删除，就删除标准输入最后出现的边，逆向遍历节点入度记录数组，从数组末尾开始找</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="prim算法"><a href="#prim算法" class="headerlink" title="prim算法"></a>prim算法</h3><ol>
<li>prim三部曲<ol>
<li>找到距离生成树最近的节点<ol>
<li>这里要注意用&lt;，否则第一次就会把所有节点都给更新了</li>
<li>通过minVal来判断哪个节点与当前生成树的距离minDist是最近的，取最小值</li>
</ol>
</li>
<li>用visited数组来标记新加入的节点</li>
<li>更新加入节点后的生成树中最近节点距离其他非生成树节点的距离</li>
</ol>
</li>
<li>minDist里面记录的是索引代表节点离生成树的最小距离</li>
</ol>
<h3 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h3><ol>
<li>主要是看边，每次都选择连接最短边相邻的两个节点；同时要求两个点不能在一个集合中，否则会成环</li>
<li>最短可以用sort来进行排序</li>
<li>要求两个点不在一个集合可以通过并查集来检查，使用并查集记得init();</li>
</ol>
<h3 id="软件构建-拓扑排序"><a href="#软件构建-拓扑排序" class="headerlink" title="软件构建 - 拓扑排序"></a>软件构建 - 拓扑排序</h3><ol>
<li>每次查找入度为0的节点，删掉节点以后更新连接节点的入度</li>
<li>邻接表可以实现，unordered_map的好处是可以处理不连续索引的节点；邻接表在处理不连续编号的节点时会出现空元素</li>
</ol>
<h3 id="dijkstra算法-朴素版-堆优化"><a href="#dijkstra算法-朴素版-堆优化" class="headerlink" title="dijkstra算法 - 朴素版&#x2F;堆优化"></a>dijkstra算法 - 朴素版&#x2F;堆优化</h3><ol>
<li>和prim算法的步骤是相同的</li>
<li>不同之处在于，minDist数组是用来记录与源节点的最短距离的，所以遍历完所有顶点后只需要输出尾元素</li>
<li>堆优化中，堆的作用有两个，<ol>
<li>存储距离源点最近顶点的编号</li>
<li>排序，让距离源点最近的顶点在top的位置，可以直接取出不用每次都进行条件判断</li>
<li>因为是有堆来组织元素，所以不需要visited数组去管理元素是否有遍历到，堆用完直接pop</li>
<li>这里lhs.second &gt; rhs.second的判断逻辑是因为，原始的priority_queue是个基于&lt;运算的大顶堆，我们需要的是小的元素在上面，所以需要的是小顶堆，于是在这里对大小判断作一个取反操作</li>
</ol>
</li>
</ol>
<h3 id="Bellman-ford算法（边视角、边视角、边视角）"><a href="#Bellman-ford算法（边视角、边视角、边视角）" class="headerlink" title="Bellman_ford算法（边视角、边视角、边视角）"></a>Bellman_ford算法（边视角、边视角、边视角）</h3><ol>
<li>什么是松弛？ 松弛就是更新from到to的最短距离，涉及到“更新”这个概念是因为每次松弛，能够使用的边数量都不一样</li>
<li>松弛每次都要保证已经visited过的节点与源点的距离是最近的，要求n到源点最近距离，因为n个顶点有n-1条边，所以当所有边都加进来的时候minDist就应该存储n到1的最近距离，所以只需要松弛n-1次</li>
<li>不需要visited数组，只需要判断from能不能到达</li>
<li>队列优化版本Bellman_ford：SPFA算法（边视角）用队列优化的地方在于<ol>
<li>只基于上一次松弛过的节点进行松弛，也就是把上一次松弛过的点作为新的出发点去松弛相连的边</li>
<li>图越稀疏效率越高，如果是稠密图SPFA算法效率接近普通版本的bellman_ford</li>
</ol>
</li>
<li>单源有限最短回路：minDist_copy[from] !&#x3D; INT_MAX没有办法处理带负权回路的情况，所以当图中有负权回路并且上一个from节点我们遍历过的时候会基于本次松弛的minDist多一次松弛<ol>
<li>面对有负权回路的情况下，如果我们要控制松弛次数，需要拷贝上一次松弛的结果</li>
<li>然后基于上一次松弛的结果来做本次松弛</li>
</ol>
</li>
</ol>
<h3 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h3><ol>
<li>注意初始值设成INT_MAX溢出会变负数，影响min函数的判断；算法没有问题</li>
<li>dp数组grid[i][j][k]的含义是从i到j, 经过k步所需要的最短路径长度</li>
</ol>
<h3 id="A-算法"><a href="#A-算法" class="headerlink" title="A*算法"></a>A*算法</h3><ol>
<li>重载&lt;运算符的时候要记得给函数体const<ol>
<li>当const对象调用这个函数的时候才不会报错</li>
<li>set和map一些容器也要求用于排序的函数是const的</li>
</ol>
</li>
<li>moves数组记录的是步数</li>
<li>下一步可以走才计算next的各个参数</li>
<li>包含string.h以后才能使用memset</li>
</ol>

                </section>

                
                

                

            </article>

            
            <nav class="dis_flex al_post_nav">
                <a class="al_post_nav_item dis_flex_acenter" href="/">
                    
                </a>
                <a class="al_post_nav_item dis_flex_acenter" href="/2024/11/01/C-Primer-5th-Notes/">
                    
                        <span class="al_text_ellipsis al_post_nav_desc">C++ Primer 5th Notes</span>
                        <svg class="al_arrow">
                            <use xmlns="http://www.w3.org/2000/svg" xlink:href="/assets/svg_icons.svg#svg-arrow-right"></use>
                        </svg>
                    
                </a>
            </nav>
        </div>
    </div>


        <div class="al_index_footer dis_flex_center">
    <div class="al_index_footer_item al_index_footer_title">
        
    </div>

    
    

    <div class="al_index_footer_item al_index_footer_extra">
        Created By 
        <a target="_blank" rel="noopener" href="https://github.com/iGuan7u/Acetolog">AcetoLog</a>
         · Power By 
        <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>
    </div>

    <div class="al_index_footer_item al_index_footer_extra_right">
        All Right Reserved
    </div>
</div>

        <script type="text/javascript" async="async" src="/javascripts/acelog.js"></script>
        
        
        
        
        

    </body>
</html>