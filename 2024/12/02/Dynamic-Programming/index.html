<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="动态规划基础题目斐波那契数 思路：递推公式照搬，注意2之前的输出就可以 动规五部曲：数组含义 -&gt; 递推公式 -&gt; 初始化 -&gt; 遍历顺序 -&gt; 举例 第i个斐波那契数是dp[i] 递归公式是f(n) &#x3D; f(n - 1) + f(n - 2) 初始条件是f(0) &#x3D; 0; f(1) &#x3D; 1; 递推顺序是从小到大 举例推导（自己算前几个数）">
<meta property="og:type" content="article">
<meta property="og:title" content="Dynamic Programming">
<meta property="og:url" content="http://example.com/2024/12/02/Dynamic-Programming/index.html">
<meta property="og:site_name" content="Make it right.">
<meta property="og:description" content="动态规划基础题目斐波那契数 思路：递推公式照搬，注意2之前的输出就可以 动规五部曲：数组含义 -&gt; 递推公式 -&gt; 初始化 -&gt; 遍历顺序 -&gt; 举例 第i个斐波那契数是dp[i] 递归公式是f(n) &#x3D; f(n - 1) + f(n - 2) 初始条件是f(0) &#x3D; 0; f(1) &#x3D; 1; 递推顺序是从小到大 举例推导（自己算前几个数）">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/images/dynamic_programming_summary.png">
<meta property="article:published_time" content="2024-12-02T00:45:48.000Z">
<meta property="article:modified_time" content="2024-12-10T03:54:59.569Z">
<meta property="article:author" content="Make1tRight">
<meta property="article:tag" content="leetcode">
<meta property="article:tag" content="algorithm">
<meta property="article:tag" content="dynamic programming">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/dynamic_programming_summary.png">

<link rel="canonical" href="http://example.com/2024/12/02/Dynamic-Programming/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Dynamic Programming | Make it right.</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Make it right.</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/02/Dynamic-Programming/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/xiaoxin.jpg">
      <meta itemprop="name" content="Make1tRight">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Make it right.">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Dynamic Programming
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-12-02 08:45:48" itemprop="dateCreated datePublished" datetime="2024-12-02T08:45:48+08:00">2024-12-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-12-10 11:54:59" itemprop="dateModified" datetime="2024-12-10T11:54:59+08:00">2024-12-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><img src="/../images/dynamic_programming_summary.png" alt="Dynamic-Programming"></p>
<h3 id="动态规划基础题目"><a href="#动态规划基础题目" class="headerlink" title="动态规划基础题目"></a>动态规划基础题目</h3><h4 id="斐波那契数"><a href="#斐波那契数" class="headerlink" title="斐波那契数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fibonacci-number/">斐波那契数</a></h4><ol>
<li>思路：递推公式照搬，注意2之前的输出就可以</li>
<li>动规五部曲：数组含义 -&gt; 递推公式 -&gt; 初始化 -&gt; 遍历顺序 -&gt; 举例</li>
<li>第i个斐波那契数是dp[i]</li>
<li>递归公式是f(n) &#x3D; f(n - 1) + f(n - 2)</li>
<li>初始条件是f(0) &#x3D; 0; f(1) &#x3D; 1;</li>
<li>递推顺序是从小到大</li>
<li>举例推导（自己算前几个数）</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// dp数组含义 第i项是dp[i]</span></span><br><span class="line">        <span class="comment">// 递推公式 dp[i] = dp[i - 1] + dp[i - 2]</span></span><br><span class="line">        <span class="comment">// 初始化 dp[0] = 0; dp[1] = 1</span></span><br><span class="line">        <span class="comment">// 遍历顺序 从小到大</span></span><br><span class="line">        <span class="comment">// dp数组</span></span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>; dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; dp.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="爬楼梯1"><a href="#爬楼梯1" class="headerlink" title="爬楼梯1"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/">爬楼梯1</a></h4><ol>
<li>思路：要达到n层，有剩1步和剩2步的情况，剩1步 -&gt; 那么有dp[i - 1]种方法能到达i - 1层，剩2步 -&gt; 那么有dp[i - 2]种方法能到达i - 2层；总共有dp[i - 1] + dp[i - 2]种方法能到达i层</li>
<li>爬到第i阶楼梯的时候有dp[i]种方法</li>
<li>递归公式是f(n) &#x3D; f(n - 1) + f(n - 2) ：<ol>
<li>假设自己在第一层 -&gt; 只有一种方法能上到1层 &#x3D;&gt; +1</li>
<li>现在要上第三层 -&gt; 有两种方法能往上2层 &#x3D;&gt; +2</li>
<li>所以要到第三层有 +1+2 &#x3D; 3种方法（初始状态变成2层 &#x3D;&gt; 上两层）</li>
<li>–</li>
</ol>
</li>
<li>初始条件是f(1) &#x3D; 1; f(2) &#x3D; 2</li>
<li>递推顺序是从小到大</li>
<li>举例推导</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 爬上i阶有dp[i]种方法</span></span><br><span class="line">        <span class="comment">// dp[i] = dp[i - 1] + dp[i - 2]</span></span><br><span class="line">        <span class="comment">// 初始化 dp[1] = 1; dp[2] = 2;</span></span><br><span class="line">        <span class="comment">// 从小到大</span></span><br><span class="line">        <span class="comment">// -</span></span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>)  <span class="keyword">return</span> n;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>; dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt; dp.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="使用最小花费爬楼梯"><a href="#使用最小花费爬楼梯" class="headerlink" title="使用最小花费爬楼梯"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/min-cost-climbing-stairs/description/">使用最小花费爬楼梯</a></h4><ol>
<li>思路：找到从n-1阶或n-2阶爬上来所需花费的最小值，所以递推公式为dp[i] &#x3D; min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);，注意0和1阶不用花费</li>
<li>爬到第i层楼梯需要支付dp[i]的费用，爬第i层需要支付cost[i]的费用</li>
<li>爬到第i层的方法有两种<ol>
<li>到i-1层往上爬1层 -&gt; dp[i - 1] + cost[i - 1]， 其中dp[i - 1]是到i-1层之前的花费、cost[i - 1]是爬i-1层需要的花费</li>
<li>到i-2层往上爬2层 -&gt; dp[i - 2] + cost[i - 2]，与1同理</li>
<li>要找到最小花费，就是从这2种方法里面找到更小的的那个 -&gt; 递推公式为<br>dp[i] &#x3D; min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);</li>
</ol>
</li>
<li>因为第1层和第2层都是可以自由选择的 -&gt; dp[0] &#x3D; 0, dp[1] &#x3D; 0 (但是选择了就要支付对应的cost)</li>
<li>因为是一层一层（索引0-size()）往上爬，所以是从数组的begin遍历到end</li>
<li>最后要到cost.end()这个位置的，因为这个位置才是楼顶</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 爬到i阶最少需要花费dp[i]</span></span><br><span class="line">        <span class="comment">// dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);</span></span><br><span class="line">        <span class="comment">// 初始化 dp[0] = 0; dp[1] = 0;</span></span><br><span class="line">        <span class="comment">// 遍历顺序 从小到大</span></span><br><span class="line">        <span class="comment">// -</span></span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(cost.size() + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="comment">// dp[0] = 0; dp[1] = 0; //初始化的逻辑, 因为都是0可以省略掉</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; dp.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>]);</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;dp[&quot; &lt;&lt; i &lt;&lt; &quot;]=&quot; &lt;&lt; dp[i] &lt;&lt; endl; //打印数组的逻辑</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[cost.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths/">不同路径</a></h4><ol>
<li>思路：要到达当前位置，要么往下走要么往右走；注意一直往下和一直往右走都分别只有一条路径</li>
<li>从(0, 0)到(m, n)有多少条路径 -&gt; 从(0, 0)到(i , j)有dp[i][j]条路径</li>
<li>到达(i, j)路径的方法：<ol>
<li>(i - 1, j)往下走一格到(i, j)，dp[i - 1][j]代表走到(i - 1, j)有多少条路径（1里面说清楚了这里不用赘述）</li>
<li>(i, j - 1)往右走一格到(i, j)</li>
<li>那么综合以上两种方法，总共有dp[i][j] &#x3D;dp[i - 1][j] + dp[i][j - 1]条路径可以到达(i , j)</li>
</ol>
</li>
<li>因为直走到最右一格和直走到最下一个都只有一条路径，所以初始化的时候<ol>
<li>dp[0][j] &#x3D; 1</li>
<li>dp[i][0] &#x3D; 1</li>
</ol>
</li>
<li>走路径一定是从(0 , 0)开始的，从数组的begin到end递推</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 走到[i, j]总共有dp[i][j]条路径</span></span><br><span class="line">        <span class="comment">// 要么往下, 要么往右: dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</span></span><br><span class="line">        <span class="comment">// 往右直走和往下直走都只有一条路径可以到达: dp[0][j] = 1; dp[i][0] = 1;</span></span><br><span class="line">        <span class="comment">// 初始化是从小到大, 因为起点是(0, 0)</span></span><br><span class="line">        <span class="comment">// -</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="不同路径Ⅱ"><a href="#不同路径Ⅱ" class="headerlink" title="不同路径Ⅱ"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths-ii/">不同路径Ⅱ</a></h4><ol>
<li>思路：和不同路径类似，区别是只有在无障碍物的时候才用公式递推</li>
<li>走到(i, j)一共有dp(i, j)条路径可以到达；因为棋盘是二维的，两个变量就能够表达所有位置(obstacleGrid代表了整个棋盘)</li>
<li>因为机器人每次只能向下或者向右移动<ol>
<li>往下移动 -&gt; dp[i - 1][j]</li>
<li>往右移动 -&gt; dp[i][j - 1]</li>
<li>所以能够到达(i, j)的路径有dp[i][j] &#x3D; dp[i - 1][j] + dp[i][j - 1]</li>
<li>另外还有条件，如果网格中有障碍物，那么不能进行下一步递推 -&gt; continue处理</li>
</ol>
</li>
<li>dp数组的初始化：一直向下或一直向右，只有一条路径可以到达<ol>
<li>一直向下dp[i][0] &#x3D; 1</li>
<li>一直向右dp[0][j] &#x3D; 1</li>
<li>碰到障碍物的话就不能继续递推</li>
</ol>
</li>
<li>只能从起点到终点所以只能是从前往后递推</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 到达(i, j)总共有dp[i][j]条路径可以到达</span></span><br><span class="line">        <span class="comment">// 2. 当没有障碍物的时候可以往下走或者往右走 if (obstacleGrid[i][j] == 0) dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</span></span><br><span class="line">        <span class="comment">// 2. 否则就用原来的0, 表示0条路径可到达</span></span><br><span class="line">        <span class="comment">// 初始化 往右走或往下走在不碰到障碍之前都只有一条路径</span></span><br><span class="line">        <span class="comment">// 遍历顺序从小到大</span></span><br><span class="line">        <span class="comment">// -</span></span><br><span class="line">        <span class="type">int</span> n = obstacleGrid.<span class="built_in">size</span>(), m = obstacleGrid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n &amp;&amp; obstacleGrid[i][<span class="number">0</span>] == <span class="number">0</span>; ++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m &amp;&amp; obstacleGrid[<span class="number">0</span>][j] == <span class="number">0</span>; ++j) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][m - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="整数拆分"><a href="#整数拆分" class="headerlink" title="整数拆分"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/integer-break/">整数拆分</a></h4><ol>
<li>思路：拆成2个数或者是2个数以上的乘积，2个数用i,i-j表示，2个数以上用i,dp[i-j]表示；这里dp[i-j]在遍历计算的过程中是会变小的，所以需要有取最大值的逻辑</li>
<li>正整数i的最大乘积为dp[i]</li>
<li>乘积可以由两个数构成(i - j)*j，也可以由多个数构成dp[i - j]*j，其中dp[i - j]是若干个数构成的结果<ol>
<li>因为要找最大值 -&gt; 得递推公式dp[i] &#x3D; max(dp[i], max((i-j)*j, dp[i - j]*j));</li>
<li>其中加入dp[i]的目的是保存当前的最大值</li>
<li>i最大一定是题目给定的n；j是i拆出来的数，所以最大只能到i-1</li>
</ol>
</li>
<li>初始化，最小只有2能拆 -&gt; vector<int>dp(n + 1);dp[2] &#x3D; 1x1 &#x3D; 1;<ol>
<li>没有意义的值不需要初始化</li>
</ol>
</li>
<li>从小到大验证，i的拆分结果可供i+1进行使用</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">integerBreak</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将i拆成j, i-j, 乘积最大为j*dp[i-j]或者是j*(i-j)</span></span><br><span class="line">        <span class="comment">// 递推公式dp[i]=(i-j)*dp[j]</span></span><br><span class="line">        <span class="comment">// 初始化dp[2] = 1;</span></span><br><span class="line">        <span class="comment">// 遍历顺序从小到大</span></span><br><span class="line">        <span class="comment">// -</span></span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123; <span class="comment">//拆成接近的2个数相乘才是最大的, 所以这里可以做一个剪枝, 条件换成j &lt;= i / 2</span></span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], <span class="built_in">max</span>(j * (i - j), j * dp[i - j]));</span><br><span class="line">                <span class="comment">// printf(&quot;i=%d, j=%d, dp[%d]=%d\n&quot;, i, j, i, dp[i]);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="不同的二叉搜索树"><a href="#不同的二叉搜索树" class="headerlink" title="不同的二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-binary-search-trees/">不同的二叉搜索树</a></h4><ol>
<li>思路：节点值范围是[1, n]，可以定义一个变量j让每一个值都做一次根节点，然后累加所有情况</li>
<li>由i个节点能够组成的二叉搜索树有dp[i]种</li>
<li>递推公式：以j为节点，那么[1, j - 1]是这个二叉搜索树的左子树，[j + 1, i]是这个二叉搜索树的右子树 dp[i] +&#x3D; dp[j - 1] * dp[i - j]</li>
<li>初始化dp[0] &#x3D; 1;因为空树也算一个二叉搜索树</li>
<li>遍历顺序是从小到大</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 由i个节点组成且节点值从1到i, 可以组成dp[i]种二叉搜索树</span></span><br><span class="line">        <span class="comment">// 让j做根节点: dp[j - 1] * dp[i - j];</span></span><br><span class="line">        <span class="comment">// 因为每个j做根节点情况要累加, 所以最后结果要求和dp[i] += dp[j - 1] * dp[i - j];</span></span><br><span class="line">        <span class="comment">// 空树也是1种二叉搜索树: dp[0] = 1 </span></span><br><span class="line">        <span class="comment">// 遍历顺序从小到大</span></span><br><span class="line">        <span class="comment">// -</span></span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">                dp[i] += dp[j - <span class="number">1</span>] * dp[i - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><h4 id="01背包理论基础（滚动数组）"><a href="#01背包理论基础（滚动数组）" class="headerlink" title="01背包理论基础（滚动数组）"></a><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1046">01背包理论基础（滚动数组）</a></h4><ol>
<li>思路：统一使用滚动数组来解决01背包问题，倒序遍历背包容量，分为装与不装两种情况，取最大值</li>
<li>背包剩余空间j，可以装下最大价值为dp[j]的物品</li>
<li>递推公式：<ol>
<li>首先判断剩余背包容量是否能够装下当前遍历的物品j&gt;&#x3D; weight[i]</li>
<li>如果装下物品那么有dp[j] &#x3D; dp[j - weight[i]] + value[i]</li>
<li>如果不装下当前物品dp[j] &#x3D; dp[j]，因为没有装东西所以剩余空间不会改变</li>
<li>综上，取最大值dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i]);</li>
</ol>
</li>
<li>初始化<ol>
<li>空间为0的时候什么都装不下：dp[0] &#x3D; 0;初始化vector的值本来就是0，所以这里可以不写</li>
</ol>
</li>
<li>背包容量从大到小遍历、物品从小到大？<ol>
<li>为什么背包的容量要从大到小遍历 -&gt; 因为把数组的元素都初始化为0，从小到大遍历的话，会把已经装进背包的元素再装一遍</li>
<li>反向遍历因为dp数</li>
<li>组里面都是空的，所以涉及到dp的位置都是0，只有物品的价值是非零值</li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 背包空间剩余j, 能够携带研究材料的最大价值为dp[j]</span></span><br><span class="line">    <span class="comment">// 装i物品dp[j] = dp[j - weight[i]] + values[i]</span></span><br><span class="line">    <span class="comment">// 不装i物品dp[j] = dp[j]</span></span><br><span class="line">    <span class="comment">// 取最大值dp[j] = max(dp[j], dp[j - weight[i]] + values[i])</span></span><br><span class="line">    <span class="comment">// 初始化: dp[0] = 0;可以不写 </span></span><br><span class="line">    <span class="comment">// 遍历顺序j从大到小, i从小到大</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">values</span><span class="params">(m, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">weight</span><span class="params">(m, <span class="number">0</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 收集数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; weight[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">        cin &gt;&gt; values[j];</span><br><span class="line">    &#125;   </span><br><span class="line">            </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= weight[i]; --j) &#123;</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + values[i]);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;j=%d, dp[j]=%d&quot;</span>, j, dp[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"> </span><br><span class="line">    cout &lt;&lt; dp[n] &lt;&lt; endl;   <span class="comment">//最后返回dp[n]，代表剩余容量为n时能装下最大物品价值为dp[n] </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-equal-subset-sum/">分割等和子集</a></h4><ol>
<li>思路：01背包的应用，背包剩余空间是还需要的大小，背包所装物品的价值是已有的大小；最后的结果要返回：当背包剩余空间为target的时候，能否正好装下价值为target的物品</li>
<li>要注意dp数组的初始化，dp[target]是包括在里面的，初始化的时候要用vector<int> dp(target+1, 0)</li>
<li>背包容量逆序遍历（如果顺序遍历就会根据本轮的状态进行迭代，逆序遍历是根据上一轮的状态进行迭代），但每换一次物品都会更新一次背包容量为target的情况，这里取最大值</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 目标为j的数组已有的元素之和为dp[j]</span></span><br><span class="line">        <span class="comment">// 2. 加入当前元素: dp[j] = dp[j - nums[i]] + nums[i]</span></span><br><span class="line">        <span class="comment">// 2. 不加入当前元素: dp[j] = dp[j];</span></span><br><span class="line">        <span class="comment">// 2. 取最大值, 接近目标 -&gt; dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);</span></span><br><span class="line">        <span class="comment">// 3. 初始化: dp[0] = 0;</span></span><br><span class="line">        <span class="comment">// 4. nums数组中的元素顺序遍历, j逆序遍历 -&gt; 元素不能重复放入, 而且需要离目标越来越近</span></span><br><span class="line">        <span class="comment">// 5. 达成target这个目标的时候, 元素之和dp[j]正好为target -&gt; dp[target] == target;</span></span><br><span class="line">        <span class="comment">// 5. 物品价值和占用空间是一样的</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = target; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= nums[i]) &#123;</span><br><span class="line">                    dp[j] = <span class="built_in">max</span>(dp[j], dp[j - nums[i]] + nums[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[target] == target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="最后一块石头的重量Ⅱ"><a href="#最后一块石头的重量Ⅱ" class="headerlink" title="最后一块石头的重量Ⅱ"></a>最后一块石头的重量Ⅱ</h4><ol>
<li>思路：类似于416等和分割子集，区别在于最后要返回的是两个子集的差值；要注意动规计算的是已有子集dp[target]，剩余另一个子集是sum - dp[target]</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lastStoneWeightII</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 目标石块的重量为j的时候, 已有石块重量为dp[j]</span></span><br><span class="line">        <span class="comment">// 2. 加入当前石块 -&gt; dp[j] = dp[j - stones[i]] + stones[i];</span></span><br><span class="line">        <span class="comment">// 2. 不加入当前石块 -&gt; dp[j] = dp[j];</span></span><br><span class="line">        <span class="comment">// 3. 初始化 dp[0] = 0;</span></span><br><span class="line">        <span class="comment">// 4. 石块重量顺序遍历, 目标石块重量逆序遍历 -&gt; 因为不能重复加入</span></span><br><span class="line">        <span class="comment">// 5. 目标石块的重量应该是总重量的一半, 才会让石头返回最小重量</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> sum = <span class="built_in">accumulate</span>(stones.<span class="built_in">begin</span>(), stones.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> target = sum / <span class="number">2</span>; <span class="comment">//一定是小的那堆</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; stones.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = target; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= stones[i]) &#123;</span><br><span class="line">                    dp[j] = <span class="built_in">max</span>(dp[j], dp[j - stones[i]] + stones[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (sum - dp[target]) - dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="目标和"><a href="#目标和" class="headerlink" title="目标和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/target-sum/">目标和</a></h4><ol>
<li>思路：分为left和right两个部分，left-right&#x3D;target, left+right&#x3D;sum，所以left&#x3D;(sum+target)&#x2F;2，最后需要找到子集总和为left的组合数</li>
<li>要注意如果(target+sum)%2 &#x3D;&#x3D; 1说明这两个子集分不出来；另外dp[0]&#x3D;1的含义是，要填满剩余空间为0的背包，组合数有1种，那就是什么也不放</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 让最终目标和为j的方法一共有dp[j]种</span></span><br><span class="line">        <span class="comment">// 2. 加入当前元素 dp[j] = dp[j] + dp[j - nums[i]];(dp[i][j] = dp[i - 1][j - nums[i]])</span></span><br><span class="line">        <span class="comment">// 2. 不加入当前元素 dp[j] = dp[j]; (dp[i][j] = dp[i - 1][j])</span></span><br><span class="line">        <span class="comment">// 2. 取最大值 -&gt; 接近目标 -&gt; dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);</span></span><br><span class="line">        <span class="comment">// 3. 初始化 dp[0] = 0 -&gt; 不用动</span></span><br><span class="line">        <span class="comment">// 4. nums元素顺序遍历, target逆序遍历 -&gt; 因为要越来越接近目标, 且放入的元素不能重新放入</span></span><br><span class="line">        <span class="comment">// 5. ↓</span></span><br><span class="line">        <span class="comment">// 将数组分成left和right(2份), left + right = sum</span></span><br><span class="line">        <span class="comment">// left - right = target</span></span><br><span class="line">        <span class="comment">// left = (target + sum) / 2;</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> ((target + sum) % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//left-right不能等于target</span></span><br><span class="line">        <span class="keyword">if</span> (sum &lt; <span class="built_in">abs</span>(target)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = (target + sum) / <span class="number">2</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(left + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = left; j &gt;= nums[i]; --j) &#123;</span><br><span class="line">                <span class="comment">// if (j &gt;= nums[i] ) &#123;</span></span><br><span class="line">                    dp[j] += dp[j - nums[i]];   </span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="一和零"><a href="#一和零" class="headerlink" title="一和零"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ones-and-zeroes/">一和零</a></h4><ol>
<li>思路：01背包问题的应用，剩余背包容量为i和j时，能够装下最大物品价值为dp[i][j]</li>
<li>这里背包容量有2个维度，一个是0一个是1；</li>
<li>根据上一轮小容量的背包数量来推，如果增加了zeroNum和oneNum，能装下的子集长度发生了什么样的变化；也就是所基于上一轮背包存储情况推出当前轮的背包存储情况</li>
<li>物品和背包的遍历顺序一定是背包在内层，只有背包在内层才能够在遍历每个物品的时候把dp数组全部元素都更新一次；</li>
<li>如果背包在外层，那么遍历完全部也才更新一次dp数组，里面的元素是背包容量为j的时候能装下最大的一件物品的价值；因为他不根据其他背包容量来更新（表面上看是有，但是实际上它参考的值全都是0，所以本质上并没有参考其他背包容量的值）</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMaxForm</span><span class="params">(vector&lt;string&gt;&amp; strs, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. strs子集中还需要i个0和j个1时, 其最大长度为dp[i][j]</span></span><br><span class="line">        <span class="comment">// 2. 将元素加入到当前子集 dp[i][j] = dp[i - zeroNum][j - oneNum] + 1; -&gt; 需求减少, 长度+1</span></span><br><span class="line">        <span class="comment">// 2. 不加入当前元素: dp[i][j] = dp[i][j] -&gt; 需求不变, 长度不变</span></span><br><span class="line">        <span class="comment">// 2. 取最大值dp[i][j] = max(dp[i - zeroNum][j - oneNum] + 1, dp[i][j]);</span></span><br><span class="line">        <span class="comment">// 3. dp[0][0] = 0;</span></span><br><span class="line">        <span class="comment">// 4. 需求是越来越少的 -&gt; 逆序遍历</span></span><br><span class="line">        <span class="comment">// 5. 注意dp数组的索引范围</span></span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> string&amp; str : strs) &#123;    <span class="comment">//物品</span></span><br><span class="line">            <span class="type">int</span> zeroNum = <span class="number">0</span>, oneNum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="type">char</span>&amp; ch : str) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ch == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                    ++zeroNum;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ++oneNum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;zeroNum = &quot; &lt;&lt; zeroNum &lt;&lt; &quot;; oneNum = &quot; &lt;&lt; oneNum &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = m; i &gt;= <span class="number">0</span>; --i) &#123;  <span class="comment">//背包</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i &gt;= zeroNum &amp;&amp; j &gt;= oneNum) &#123;</span><br><span class="line">                        dp[i][j] = <span class="built_in">max</span>(dp[i - zeroNum][j - oneNum] + <span class="number">1</span>, dp[i][j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1052">完全背包</a></h4><ol>
<li>思路：完全背包就是在01背包的基础上可以重复放入物品；所以更新dp数组的时候可以基于本轮背包装过的物品来进行更新</li>
<li>本轮装过的物品可以再装，所以背包的容量是顺序遍历的</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 背包空间剩余j时, 装下的最大物品价值为dp[j]</span></span><br><span class="line">    <span class="comment">// 2. 装下当前物品, 则空间减少, 价值增加 -&gt; dp[j] = dp[j - weights[i]] + values[i]</span></span><br><span class="line">    <span class="comment">// 2. 不装当前物品, 则空间和价值都不变 -&gt; dp[j] = dp[j] </span></span><br><span class="line">    <span class="comment">// 3. 暂不初始化</span></span><br><span class="line">    <span class="comment">// 4. 材料顺序遍历, 材料可以重复取用 -&gt; 顺序遍历</span></span><br><span class="line">    <span class="comment">// 5. -</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m, bagWeight;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; bagWeight;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">weights</span><span class="params">(m, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">values</span><span class="params">(m, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; weights[i] &gt;&gt; values[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(bagWeight + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; weights.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = weights[i]; j &lt;= bagWeight; ++j) &#123;</span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j - weights[i]] + values[i], dp[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; dp[bagWeight] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="零钱兑换Ⅱ"><a href="#零钱兑换Ⅱ" class="headerlink" title="零钱兑换Ⅱ"></a>零钱兑换Ⅱ</h4><ol>
<li>思路：完全背包问题（物品可以重复放入），另外要注意力扣示例中有两个元素相加超过int的情况，所以这里元素定义为uint32_t，或者加if判断也行</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">change</span><span class="params">(<span class="type">int</span> amount, vector&lt;<span class="type">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 目标金额为j时, 已有的硬币组合数为dp[j]</span></span><br><span class="line">        <span class="comment">// 2. 加入当前硬币 dp[j] = dp[j - coins[i]]</span></span><br><span class="line">        <span class="comment">// 2. 不加入当前硬币 dp[j] = dp[j] -&gt; dp[j] = dp[j - coins[i]] + dp[j]</span></span><br><span class="line">        <span class="comment">// 2. dp[j] += dp[j - coins[i]]</span></span><br><span class="line">        <span class="comment">// 3. 初始化dp[0] = 1;</span></span><br><span class="line">        <span class="comment">// 4. 硬币顺序遍历, 背包顺序遍历 -&gt; 因为可以重复放入</span></span><br><span class="line">        <span class="comment">// 5. -</span></span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">uint32_t</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; coins.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = coins[i]; j &lt;= amount; ++j) &#123;</span><br><span class="line">                dp[j] += dp[j - coins[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="组合总和Ⅳ"><a href="#组合总和Ⅳ" class="headerlink" title="组合总和Ⅳ"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-iv/">组合总和Ⅳ</a></h4><ol>
<li>思路：完全背包问题，求排列数就是在内层遍历物品(为什么？不理解)</li>
<li>暂时这样理解：每次都遍历全部物品，那么在物品不同的时候就算作不同情况</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">combinationSum4</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 目标总数为j时, 所包含的元素组合个数为dp[j]</span></span><br><span class="line">        <span class="comment">// 2. 加入当前元素 -&gt; dp[j] = dp[j - nums[i]]</span></span><br><span class="line">        <span class="comment">// 2. 不加入当前元素 -&gt; dp[j] = dp[j]</span></span><br><span class="line">        <span class="comment">// 2. 此时目标为j所包含的元素组合个数为dp[j] = dp[j] + dp[j - nums[i]] -&gt; dp[j] += dp[j - nums[i]];</span></span><br><span class="line">        <span class="comment">// 3. 初始化: dp[0] = 1;</span></span><br><span class="line">        <span class="comment">// 4. 背包顺序遍历 -&gt; 元素可以重复放入; 物品放入的顺序不同, 算作不同的组合 -&gt; 物品要放在内层进行遍历</span></span><br><span class="line">        <span class="comment">// 5. -</span></span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">uint32_t</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= target; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= nums[i]) &#123;</span><br><span class="line">                    dp[j] += dp[j - nums[i]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="爬楼梯进阶版"><a href="#爬楼梯进阶版" class="headerlink" title="爬楼梯进阶版"></a><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1067">爬楼梯进阶版</a></h4><ol>
<li>思路：完全背包问题，且要求排列数，所以物品在内层循环</li>
<li>因为放过的元素还可以再放，所以属于完全背包问题；爬123和爬132是两种不同的方法，所以物品要在内层遍历</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 距离楼顶剩余j时, 爬到楼顶的方法有dp[j]种</span></span><br><span class="line">    <span class="comment">// 2. 爬1-m阶 -&gt; 物品是1-m可以让我选</span></span><br><span class="line">    <span class="comment">// 2. 爬i阶 -&gt; dp[j] = dp[j - i];</span></span><br><span class="line">    <span class="comment">// 2. 不爬, 其实也就是累计之前的状态 -&gt; dp[j] = dp[j] -&gt; dp[j] += dp[j - i];</span></span><br><span class="line">    <span class="comment">// 3. dp[1] = 1; -&gt; ***dp[0] = 1才对***</span></span><br><span class="line">    <span class="comment">// 4. 爬过了还可以再爬 -&gt; 物品可以重复放入 -&gt; 背包空间顺序遍历</span></span><br><span class="line">    <span class="comment">// 4. 爬23和爬32是两种不同的爬法 -&gt; 物品放入的顺序是有区分的 -&gt; 物品在内层</span></span><br><span class="line">    <span class="comment">// 5. 如果是dp[1] = 1, dp[0] = 0的话,每次都会少加一个dp[0] = 1</span></span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= i) &#123;</span><br><span class="line">                dp[j] += dp[j - i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; dp[n] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change/">零钱兑换</a></h4><ol>
<li>思路：完全背包问题，已经放入的物品还可以重新放入；取组合数的最小值</li>
<li>将初始值初始为有效值范围外的数值，就不会影响到有效数据的更新，但是要根据题目来具体定</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 要凑成j元, 所需要最少的硬币数量为dp[j]</span></span><br><span class="line">        <span class="comment">// 2. 放入当前硬币 -&gt; dp[j] = dp[j - coins[i]] + 1;</span></span><br><span class="line">        <span class="comment">// 2. 不放入当前硬币 -&gt; dp[j] = dp[j]</span></span><br><span class="line">        <span class="comment">// 2. 取最小值 dp[j] = min(dp[j], dp[j - coins[i]] + 1);</span></span><br><span class="line">        <span class="comment">// 3. 初始化: dp[0] = 0;</span></span><br><span class="line">        <span class="comment">// 4. 硬币可以重复放入 -&gt; 背包顺序遍历; 硬币放入的顺序不重要 -&gt; 硬币在外层</span></span><br><span class="line">        <span class="comment">// 5. 如果dp[j - coins[i]]是初始值要跳过? 为什么? 说明没有这种情况</span></span><br><span class="line">        <span class="keyword">if</span> (amount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; coins.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = coins[i]; j &lt;= amount; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[j - coins[i]] != INT_MAX) &#123;<span class="comment">//***</span></span><br><span class="line">                    dp[j] = <span class="built_in">min</span>(dp[j], dp[j - coins[i]] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for (const int&amp; v: dp) &#123;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; v &lt;&lt; &quot; &quot;;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (dp[amount] == INT_MAX) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/perfect-squares/">完全平方数</a></h4><ol>
<li>思路：物品是i*i, 背包剩余空间是n；因为物品可以重复放入，所以是完全背包问题</li>
<li>这里要对0进行初始化，因为0没有完全平方数</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSquares</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 和为j的完全平方数最少数量为dp[j]</span></span><br><span class="line">        <span class="comment">// 2. 加入 -&gt; dp[j] = dp[j - i*i] + 1;</span></span><br><span class="line">        <span class="comment">// 2. 不加入 -&gt; dp[j] = dp[j]</span></span><br><span class="line">        <span class="comment">// 2. 要求最小数量, 取最小值 -&gt; dp[j] = min(dp[j], dp[j - i*i] + 1);</span></span><br><span class="line">        <span class="comment">// 3. vector&lt;int&gt; dp(n + 1, INT_MAX); dp[0] = 0; dp[1] = 1;</span></span><br><span class="line">        <span class="comment">// 4. 平方数可以重复 -&gt; 顺序遍历, 平方数加入的顺序不重要 -&gt; 物品在外层</span></span><br><span class="line">        <span class="comment">// 5. 这里不用if是因为从1*1开始, 已经把dp[i]每个元素都变成了有效值, 然后再慢慢减少数量</span></span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i*i; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="comment">// if (dp[j - i*i] != INT_MAX) &#123;</span></span><br><span class="line">                    dp[j] = <span class="built_in">min</span>(dp[j], dp[j - i*i] + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">                cout &lt;&lt; dp[j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dp[n] == INT_MAX) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="单词拆分"><a href="#单词拆分" class="headerlink" title="单词拆分"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-break/">单词拆分</a></h4><ol>
<li>思路：单词可以重复放入-&gt;完全背包问题；单词放入的顺序影响判断结果-&gt;背包问题中的排列问题</li>
<li>截取字符串的方法是s.substr(pos, n); pos是位置，n是长度；如果pos超过了s.size()会返回out_of_range，如果pos+n超过了s.size()，只会到末尾</li>
<li>截取字符串内层循环第一个是最长的，然后逐个去掉第一个字母进行匹配</li>
<li>dp数组的含义是j之前能够装下的情况是dp[j]，所以既要判断之前的i可以（dp[i]&#x3D;&#x3D;true）又要判断j-i可以（wordSet.find(word) !&#x3D; wordSet.end()）</li>
<li>这里转成unordered_set是为了调用关联容器的find方法</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 物品是wordDict, 背包是s</span></span><br><span class="line">        <span class="comment">// 1. 能够装下j个字符前的情况为dp[j]</span></span><br><span class="line">        <span class="comment">// 2. 出现在字典里 -&gt; dp[j] = true;</span></span><br><span class="line">        <span class="comment">// 2. 没有出现在字典里 -&gt; dp[j] = false;</span></span><br><span class="line">        <span class="comment">// 3. 初始化 都为false, 然后空字符是可以的</span></span><br><span class="line">        <span class="comment">// 4. 先遍历背包后遍历物品 -&gt; 物品的顺序是固定好的 -&gt; 物品要在内层</span></span><br><span class="line">        <span class="comment">// 5. -</span></span><br><span class="line">        <span class="function">unordered_set&lt;string&gt; <span class="title">wordSet</span><span class="params">(wordDict.begin(), wordDict.end())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(s.size() + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= s.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; j; ++i) &#123;</span><br><span class="line">                string word = s.<span class="built_in">substr</span>(i, j - i);</span><br><span class="line">                <span class="comment">// cout &lt;&lt; word &lt;&lt; &quot; &quot;;</span></span><br><span class="line">                <span class="keyword">if</span> (wordSet.<span class="built_in">find</span>(word) != wordSet.<span class="built_in">end</span>() &amp;&amp; dp[i]) &#123;</span><br><span class="line">                    dp[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[s.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1066">多重背包</a></h4><ol>
<li>思路：多重背包就是在01背包的基础上多了个数，所以我们要多遍历一个数量的数组</li>
<li>要注意的是，背包所能装下最大价值，是可以针对每个物品从0-&gt;nums[i]进行选择的，而不是每个都选最大值，具体可以看k的定义</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> bagWeight, n;</span><br><span class="line">    cin &gt;&gt; bagWeight &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">weights</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">values</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) cin &gt;&gt; weights[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) cin &gt;&gt; values[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) cin &gt;&gt; nums[i];</span><br><span class="line">    <span class="comment">// 1. 剩余容量为j, 当前遍历到的矿石数量剩余k时, 能够装下的最大矿石的价值为dp[j];</span></span><br><span class="line">    <span class="comment">// 2. 装下-&gt; if (j &gt;= weight[i] &amp;&amp; k &gt; 0) dp[j] = dp[j - weight[i]] + k * values[i];</span></span><br><span class="line">    <span class="comment">// 2. 不装 dp[j] = dp[j]</span></span><br><span class="line">    <span class="comment">// 2. 取最大值 dp[j] = max(dp[j], dp[j - weight[i]] + k * values[i]);</span></span><br><span class="line">    <span class="comment">// 3. 初始化:</span></span><br><span class="line">    <span class="comment">// 4. 物品放入的顺序不重要 -&gt; 物品在外层; 物品不能重复放入 -&gt; 背包容量倒序遍历</span></span><br><span class="line">    <span class="comment">// 5. -</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(bagWeight + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = bagWeight; j &gt;= weights[i]; --j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = nums[i]; k &gt; <span class="number">0</span>; --k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= k * weights[i])</span><br><span class="line">                    dp[j] = <span class="built_in">max</span>(dp[j], dp[j - k * weights[i]] + k * values[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; dp[bagWeight] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="打家劫舍问题"><a href="#打家劫舍问题" class="headerlink" title="打家劫舍问题"></a>打家劫舍问题</h3><h4 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber/">打家劫舍</a></h4><ol>
<li>思路：偷到j家能获取的最大金额数为dp[j]; 偷当前家那么上上家一定要偷dp[j] &#x3D; dp[j -2] + nums[j], 不偷当前家那么继承上一个状态dp[j - 1]，然后取最大值</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 偷到j家能获得的最大金额数为dp[j]</span></span><br><span class="line">        <span class="comment">// 2. 如果偷这一家 -&gt; dp[j] = dp[j - 2] + nums[j]; 上上家一定要偷不然就错过了</span></span><br><span class="line">        <span class="comment">// 2. 如果不偷这一家 -&gt; 偷上一家 -&gt; dp[j] = dp[j - 1]</span></span><br><span class="line">        <span class="comment">// 2. 求最大值: dp[j] = max(dp[j - 2] + nums[j], dp[j - 1]); 一个变量就够了</span></span><br><span class="line">        <span class="comment">// 3. 初始化: dp[0] = nums[0]; dp[1] = max(nums[0], nums[1]);</span></span><br><span class="line">        <span class="comment">// 4. 遍历顺序:j是从前往后推算的, 所以只能是从前往后遍历</span></span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j &lt; nums.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j - <span class="number">2</span>] + nums[j], dp[j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="打家劫舍Ⅱ"><a href="#打家劫舍Ⅱ" class="headerlink" title="打家劫舍Ⅱ"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber-ii/">打家劫舍Ⅱ</a></h4><ol>
<li>思路：在打家劫舍的基础上，只能选择偷第一家或者偷最后一家</li>
<li>构造一个函数，分别查找偷第一家的情况和偷最后一家的情况，然后取最大值</li>
<li>为什么不能使用循环数组？因为会遍历2次</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">robRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == end) <span class="keyword">return</span> nums[end];</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(end + <span class="number">1</span>, <span class="number">0</span>)</span></span>; <span class="comment">//end是索引</span></span><br><span class="line">        dp[start] = nums[start];    <span class="comment">//这里把0 -&gt; start应对不同起始索引的情况</span></span><br><span class="line">        dp[start + <span class="number">1</span>] = <span class="built_in">max</span>(nums[start], nums[start + <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = start + <span class="number">2</span>; j &lt;= end; ++j) &#123;    <span class="comment">//这里end是索引, 索引可以取等号</span></span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j - <span class="number">2</span>] + nums[j], dp[j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[end];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> result1 = <span class="built_in">robRange</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">2</span>);        <span class="comment">//其实就是把环分成了2种不同情况 -&gt; 取最大值</span></span><br><span class="line">        <span class="type">int</span> result2 = <span class="built_in">robRange</span>(nums, <span class="number">1</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(result1, result2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="打家劫舍Ⅲ"><a href="#打家劫舍Ⅲ" class="headerlink" title="打家劫舍Ⅲ"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber-iii/">打家劫舍Ⅲ</a></h4><ol>
<li>思路：因为要根据孩子节点的情况来判断当前节点偷不偷，所以先判断孩子节点再判断当前节点，选用后序遍历；利用递归的调用栈来保存每个节点偷与不偷的两种状态；</li>
<li>如果偷当前节点，那么两个孩子节点都不能偷；如果不偷当前节点，那么两个孩子节点各自判断偷与不偷的最大值，注意：两个是不干扰的</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 1. dp[i][0] -&gt; 不偷当前结点, 能够盗取的最高金额; dp[i][1] -&gt; 偷当前结点能够盗取的最高金额</span></span><br><span class="line">    <span class="comment">// 2. 递推公式: val1 = cur-&gt;val + dp[left][0] + dp[right][0]; 偷了当前节点, 孩子节点就不能偷</span></span><br><span class="line">    <span class="comment">// 2. val2 = max(dp[left][0], dp[left][1]) + max(dp[right][0], dp[right][1]); 偷孩子节点的最大值</span></span><br><span class="line">    <span class="comment">// 3. 初始化: 空节点偷不偷都是0; val1 = 0, val2 = 0;</span></span><br><span class="line">        <span class="comment">// 4. 因为要根据是否偷孩子节点来判断当前节点要不要偷 -&gt; 只能采用后序遍历, 利用递归函数的返回值来做下一步计算</span></span><br><span class="line">        <span class="comment">// 5. 虽然只用了一个二维数组, 但是每一层递归都会有一个二维数组来记录节点的状态 -&gt; 保存在系统栈内</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">robTree</span><span class="params">(TreeNode* cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>) <span class="keyword">return</span> &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// vector&lt;int&gt; dp(2, 0);</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; left = <span class="built_in">robTree</span>(cur-&gt;left);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; right = <span class="built_in">robTree</span>(cur-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> val1 = cur-&gt;val + left[<span class="number">0</span>] + right[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> val2 = <span class="built_in">max</span>(left[<span class="number">0</span>], left[<span class="number">1</span>]) + <span class="built_in">max</span>(right[<span class="number">0</span>], right[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;val2, val1&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result = <span class="built_in">robTree</span>(root);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(result[<span class="number">0</span>], result[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="股票问题"><a href="#股票问题" class="headerlink" title="股票问题"></a>股票问题</h3><h4 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/">买卖股票的最佳时机</a></h4><ol>
<li>思路（动规）：dp数组描述持有和不持有的两种状态；持有有当前持有和昨天持有两种情况，不持有有当前卖出和昨天不持有两种情况；注意这里买入直接-prices[i]就可以，因为只有一次买入的机会</li>
<li>思路（贪心）：顺序遍历，统计最小值，统计与最小值的差值result，最后返回result的最大值</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 在第i天不持有股票最多能拿dp[i][0]; 第i天持有股票最多能拿dp[i][1]</span></span><br><span class="line">        <span class="comment">// 2. dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);前一天不持有, 和今天刚卖出取最大值</span></span><br><span class="line">        <span class="comment">// 2. dp[i][1] = max(dp[i - 1][1], -prices[i]);  前一天持有, 和今天刚买入取最大值</span></span><br><span class="line">        <span class="comment">// 3. 初始化 dp[0][0] = 0; dp[0][1] = -prices[0]; 其余值全为0</span></span><br><span class="line">        <span class="comment">// 4. 遍历顺序: 因为要用前一天推后一天 -&gt; 顺序遍历</span></span><br><span class="line">        <span class="comment">// 5. 不持有一定比持有剩下的现金更多, 因为最终是看现金数量的</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> len = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(len, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], -prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 贪心解法</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> low = INT_MAX;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            low = <span class="built_in">min</span>(low, prices[i]);  <span class="comment">// 取最左最小价格</span></span><br><span class="line">            result = <span class="built_in">max</span>(result, prices[i] - low); <span class="comment">// 直接取最大区间利润</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="买卖股票的最佳时机Ⅱ-可以多次买卖"><a href="#买卖股票的最佳时机Ⅱ-可以多次买卖" class="headerlink" title="买卖股票的最佳时机Ⅱ - 可以多次买卖"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/">买卖股票的最佳时机Ⅱ - 可以多次买卖</a></h4><ol>
<li>思路：对比买卖股票的最佳时机，就是不持有的状态下，有保持昨天不持有的状态和当天卖出这两种情况，差异在于，当天卖出要根据上一次持有的状态推出</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法一: 动态规划</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 第i天不持有最多能获得收益dp[i][0]; 第i天持有最多能获得收益dp[i][1]</span></span><br><span class="line">        <span class="comment">// 2. 第i天不持有: dp[i][0] = max(dp[i - 1][0] , dp[i - 1][1] + prices[i]);</span></span><br><span class="line">        <span class="comment">// 2. 第i天持有： dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);</span></span><br><span class="line">        <span class="comment">// 3. dp[0][0] = 0; dp[0][1] = -prices[0];</span></span><br><span class="line">        <span class="comment">// 4. 前一天推出后一天的状态 -&gt; 只能是正序遍历</span></span><br><span class="line">        <span class="comment">// 5. </span></span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>; </span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>] , dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法二: 贪心</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            result += <span class="built_in">max</span>(<span class="number">0</span>, prices[i] - prices[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="买卖股票的最佳时机Ⅲ-可以买卖2次"><a href="#买卖股票的最佳时机Ⅲ-可以买卖2次" class="headerlink" title="买卖股票的最佳时机Ⅲ - 可以买卖2次"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/">买卖股票的最佳时机Ⅲ - 可以买卖2次</a></h4><ol>
<li>思路：将买卖股票的状态分为不持有、第一次买入、第一次卖出、第二次买入、第二次卖出5种状态；因为第二次卖出的利润包含了2次操作带来是收益，所以一定是第二次卖出的状态钱最多</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 第i天不持有dp[i][0]; 第i天买入dp[i][1]; 第i天卖出dp[i][2]</span></span><br><span class="line">        <span class="comment">// 1. 第i天第二次买入dp[i][3]; 第i天第二次卖出dp[i][4];</span></span><br><span class="line">        <span class="comment">// 2. dp[i][0] = dp[i - 1][0]; </span></span><br><span class="line">        <span class="comment">// 2. dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);</span></span><br><span class="line">        <span class="comment">// 2. dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i]);</span></span><br><span class="line">        <span class="comment">// 2. dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]);</span></span><br><span class="line">        <span class="comment">// 2. dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]);</span></span><br><span class="line">        <span class="comment">// 3. dp[0][0] = 0; dp[0][1] = -prices[0]; dp[0][2] = 0; dp[0][3] = -prices[0]; dp[0][4] = 0;</span></span><br><span class="line">        <span class="comment">// 4. 前一天的状态推出后一天的状态 -&gt; 只能是正序遍历</span></span><br><span class="line">        <span class="comment">// 5. -</span></span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">5</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">3</span>] = -prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">2</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">2</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">3</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">3</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">4</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">4</span>], dp[i - <span class="number">1</span>][<span class="number">3</span>] + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">4</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="买卖股票的最佳时机IV"><a href="#买卖股票的最佳时机IV" class="headerlink" title="买卖股票的最佳时机IV"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">买卖股票的最佳时机IV</a></h4><ol>
<li>思路：买卖股票的最佳时机Ⅲ的抽象化，买入（以及买入后）的状态记为奇数，卖出（以及卖出后）的状态记为偶数，不持有记为0，将Ⅲ的代码写成循环即可</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 第i天, 不持有股票最大利润为dp[i][0]; 第一次买入股票最大利润为dp[i][1]</span></span><br><span class="line">        <span class="comment">// 1. 第一次卖出股票最大利润为dp[i][2]; 以此类推,</span></span><br><span class="line">        <span class="comment">// 1. 第k次买入股票的最大利润为dp[i][2*k - 1], 第k次卖出股票的最大利润为dp[i][2*k]</span></span><br><span class="line">        <span class="comment">// 2. 第i天不持有(单独一个状态, 因卖出而不持有的状态是dp[i][2*k]) -&gt; dp[i][0] = dp[i - 1][0]; </span></span><br><span class="line">        <span class="comment">// 2. dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]); -&gt; 可推出(直接从1开始遍历)</span></span><br><span class="line">        <span class="comment">// 2. 第k次买入:dp[i][2 * k - 1] = max(dp[i - 1][2 * k - 1], dp[i - 1][2 * k - 2] - prices[i]);</span></span><br><span class="line">        <span class="comment">// 2. 第k次卖出:dp[i][2 * k] = max(dp[i - 1][2 * k], dp[i - 1][2 * k - 1] + prices[i]);</span></span><br><span class="line">        <span class="comment">// 3. 初始化: dp[i][2 * k - 1] = -prices[i];</span></span><br><span class="line">        <span class="comment">// 4. 由前一天的状态推出后一天的状态 -&gt; 顺序遍历</span></span><br><span class="line">        <span class="comment">// 5. -</span></span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>*k + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">2</span>*k + <span class="number">1</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = -prices[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= k; ++j) &#123;</span><br><span class="line">                dp[i][<span class="number">2</span> * j - <span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">2</span> * j - <span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span> * j - <span class="number">2</span>] - prices[i]);</span><br><span class="line">                dp[i][<span class="number">2</span> * j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">2</span> * j], dp[i - <span class="number">1</span>][<span class="number">2</span> * j - <span class="number">1</span>] + prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">2</span> * k];        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="最佳买卖股票时机含冷冻期"><a href="#最佳买卖股票时机含冷冻期" class="headerlink" title="最佳买卖股票时机含冷冻期"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">最佳买卖股票时机含冷冻期</a></h4><ol>
<li>思路：分为不持有、买入、卖出、冷冻期4种状态，返回的结果中一定是股票卖出以后收益是最大的；股票卖出的状态分为卖出和冷冻期两种，所以最后的结果要取最大值</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 第i天: 不持有股票的状态dp[i][0]; 买入股票的状态dp[i][1]; 当天卖出股票的状态dp[i][2]</span></span><br><span class="line">        <span class="comment">// 1. 卖出股票后的冷冻期dp[i][3];</span></span><br><span class="line">        <span class="comment">// 2. 一直不持有或者说前一天是冷冻期:dp[i][0] = max(dp[i - 1][0], dp[i - 1][3]); </span></span><br><span class="line">        <span class="comment">// 2. dp[i][1] = max(dp[i - 1][1], max(dp[i - 1][0] - prices[i], dp[i - 1][3] - prices[i]));</span></span><br><span class="line">        <span class="comment">// 2. dp[i][2] = dp[i - 1][1] + prices[i];</span></span><br><span class="line">        <span class="comment">// 2. dp[i][3] = dp[i - 1][2];</span></span><br><span class="line">        <span class="comment">// 3. dp[0][0] = 0; dp[0][1] = -prices[0]; dp[0][2] = 0; dp[0][3] = 0;</span></span><br><span class="line">        <span class="comment">// 4. 前一天的状态推出后一天的状态 -&gt; 顺序遍历</span></span><br><span class="line">        <span class="comment">// 5. -</span></span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">4</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">3</span>]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i], dp[i - <span class="number">1</span>][<span class="number">3</span>] - prices[i]));</span><br><span class="line">            dp[i][<span class="number">2</span>] = dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i];</span><br><span class="line">            dp[i][<span class="number">3</span>] = dp[i - <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">0</span>], <span class="built_in">max</span>(dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">2</span>], dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">3</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="买卖股票的最佳时机含手续费"><a href="#买卖股票的最佳时机含手续费" class="headerlink" title="买卖股票的最佳时机含手续费"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">买卖股票的最佳时机含手续费</a></h4><ol>
<li>思路：将状态规划为不持有0和持有1两种状态，只是在买卖股票的最佳时机Ⅱ的基础上多了手续费</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices, <span class="type">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 第i天不持有股票的状态是dp[i][0]; 持有股票的状态是dp[i][1];</span></span><br><span class="line">        <span class="comment">// 2. dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i] - fee);</span></span><br><span class="line">        <span class="comment">// 2. dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);</span></span><br><span class="line">        <span class="comment">// 3. dp[0][1] = -prices[0];</span></span><br><span class="line">        <span class="comment">// 4. 因为要根据前一天推出后一天的状态 -&gt; 顺序遍历</span></span><br><span class="line">        <span class="comment">// 5. 因为要求获得利润的最大值, 如果在第一天买入又卖出, 最大利润直接-2 -&gt; 没有意义</span></span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i] - fee);</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="编辑距离问题"><a href="#编辑距离问题" class="headerlink" title="编辑距离问题"></a>编辑距离问题</h3><h4 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-increasing-subsequence/description/">最长递增子序列</a></h4><ol>
<li>思路：结尾为第i位元素之前（包括第i位），最长严格递增子序列的长度为dp[i]；在每次统计dp[i]的时候都要对比i前面每一个元素j，才能确定dp[i]的值</li>
<li>最终的结果需要定义一个result取最大值，因为最长递增子串不一定以最后一位元素为结尾</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 第i位之前, 最长严格递增子序列的长度为dp[i]</span></span><br><span class="line">        <span class="comment">// 2. 在满足nums[j] &lt; nums[i]的条件下, 有如下递推公式</span></span><br><span class="line">        <span class="comment">// 2. dp[i] = max(dp[i], dp[j] + 1); 这里j是指代i前一位数的最长子序列</span></span><br><span class="line">        <span class="comment">// 3. 初始化: dp[i]都为1 -&gt; 最长严格递增子序列的长度不可能比1还小</span></span><br><span class="line">        <span class="comment">// 4. 顺序遍历 -&gt; 因为后一位要比前一位更大</span></span><br><span class="line">        <span class="comment">// 5. 这里的result是取最大值, 不是最后一位;</span></span><br><span class="line">        <span class="comment">// 5. 可以在每次取得dp数组后更新最大值result的数值 -&gt; 保存最大值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[i])</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result = <span class="built_in">max</span>(result, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="最长连续递增子序列"><a href="#最长连续递增子序列" class="headerlink" title="最长连续递增子序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/">最长连续递增子序列</a></h4><ol>
<li>思路：如果递增则继承上一个状态的dp，并自增1；如果不递增就使用默认值；因为是连续的所以不用再定义j去判断子序列里面各元素</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            result = <span class="built_in">max</span>(result, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="最长重复子序列"><a href="#最长重复子序列" class="headerlink" title="最长重复子序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/">最长重复子序列</a></h4><ol>
<li>思路：难点在于dp数组的定义，以i-1为结尾的nums1子数组和以j-1为结尾的num2子数组最长重复子序列长度为dp[i][j]</li>
<li>为什么要以i-1为结尾以j-1为结尾，因为如果直接定义i，j为结尾，那么需要单独讨论两边第0位元素与另一数组元素的相同情况，需要多2个for循环</li>
<li>这里如果元素不相同不用继承上一个状态，直接写0就可以，因为dp数组讨论的是以当前元素为结尾的子串；如果元素相同dp[i][j]就在上一个状态的基础上+1</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 以i - 1结尾的nums1, 以j - 1结尾的nums2公共最长子序列长度为dp[i][j]</span></span><br><span class="line">        <span class="comment">// 2. if (nums1[i - 1] == nums2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;</span></span><br><span class="line">        <span class="comment">// 3. dp[0][j]和dp[i][0]都是没有意义的, 因为长度都不一样而且dp[i][j]是以i-1和j-1为结尾的 负索引没有意义 -&gt; 直接设置为0</span></span><br><span class="line">        <span class="comment">// 4. 顺序遍历(但是要能包括最后一位数)</span></span><br><span class="line">        <span class="comment">// 5. -</span></span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(nums<span class="number">1.</span><span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(nums<span class="number">2.</span><span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= nums<span class="number">1.</span><span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= nums<span class="number">2.</span><span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>]) </span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                result = <span class="built_in">max</span>(result, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-common-subsequence/">最长公共子序列</a></h4><ol>
<li>思路：两边相同的时候在上一个状态的基础上+1，两边不相同的时候继承上一个状态的最大值，最终返回结尾为最后一位元素的子串</li>
<li>因为不要求连续，所以如果当前元素不相同可以继承上一个状态（当前元素不相等就不改变dp数组）</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/uncrossed-lines/">应用题版本</a></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. text1的i-1位前与text2的j-1位前最大公共子序列长度为dp[i][j]</span></span><br><span class="line">        <span class="comment">// 2. 如果i-1位与j-1位相同 -&gt; dp[i][j] = dp[i - 1][j - 1] + 1;</span></span><br><span class="line">        <span class="comment">// 2. 如果i-1位与j-1位不相同 -&gt; 因为不要求连续,所以可以看上一位是否相同</span></span><br><span class="line">        <span class="comment">// 2. dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);</span></span><br><span class="line">        <span class="comment">// 3. 初始化: 都是0, 因为公共子序列的个数不一定存在</span></span><br><span class="line">        <span class="comment">// 4. 公共子序列的相对顺序不能乱, 顺序遍历比较方便</span></span><br><span class="line">        <span class="comment">// 5. 最终结果是看最后一位, 因为只有看完了最后一位才能知道最后一位之前公共子序列的长度</span></span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(text<span class="number">1.</span><span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(text<span class="number">2.</span><span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= text<span class="number">1.</span><span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= text<span class="number">2.</span><span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);<span class="comment">//不要求连续就可以加这句</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[text<span class="number">1.</span><span class="built_in">size</span>()][text<span class="number">2.</span><span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="最大子数组和-动规和贪心"><a href="#最大子数组和-动规和贪心" class="headerlink" title="最大子数组和 - 动规和贪心"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/">最大子数组和 - 动规和贪心</a></h4><ol>
<li>思路：dp数组的含义：以i为结尾元素的子数组，最大和为dp[i]；如果加上当前元素更大则加，如果当前元素比之前合起来都大那么直接放弃之前的状态从当前位置重新统计</li>
<li>因为dp数组代表的是以i为结尾元素的子数组，以最后一位元素为结尾的子数组不一定具有最大和，所以需要额外定义一个变量来统计最大和</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. i位之前的子数组最大和为dp[i]</span></span><br><span class="line">        <span class="comment">// 2. 如果之前是负数 dp[i] = nums[i]; /*这里可以直接更新*/</span></span><br><span class="line">        <span class="comment">// 2. 如果之前还是正的 dp[i] = dp[i - 1] + nums[i]</span></span><br><span class="line">        <span class="comment">// 2. 取最大值 dp[i] = max(dp[i - 1] + nums[i], nums[i]);</span></span><br><span class="line">        <span class="comment">// 3. 初始化: dp[0] = nums[0]; 其余的都要为无穷小, 如果全是负数的话 0有可能覆盖掉正确的值</span></span><br><span class="line">        <span class="comment">// 4. 要求连续数组 -&gt; 顺序不能变 -&gt; 顺序遍历</span></span><br><span class="line">        <span class="comment">// 5. -</span></span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(), INT_MIN)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> result = dp[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>] + nums[i], nums[i]);</span><br><span class="line">            result = <span class="built_in">max</span>(result, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 贪心</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*贪心*/</span></span><br><span class="line">        <span class="comment">// 局部最优: 总和小于0直接重置, 大于0继续叠加</span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> result = INT_MIN;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            count += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (result &lt; count) &#123;    <span class="comment">//只记录最大值</span></span><br><span class="line">                result = count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count &lt; <span class="number">0</span>) count = <span class="number">0</span>;<span class="comment">//总和小于0直接重置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="判断子序列"><a href="#判断子序列" class="headerlink" title="判断子序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/is-subsequence/">判断子序列</a></h4><ol>
<li>思路：判断最长公共子序列的应用题版本，主要的区别就是。若s是t的子串，st以最后一个元素为结尾元素的子串具有最长公共子序列的长度为s.size()</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubsequence</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 长度为i-1的s子数组与长度为j-1的t子数组相同的具有相同的子序列长度为dp[i][j]</span></span><br><span class="line">        <span class="comment">// 2. 当前位相同 -&gt; if (s[i - 1] == t[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;</span></span><br><span class="line">        <span class="comment">// 2. 当前位不相同 -&gt; 看t的前一位(长度为j-2的t子数组, 其实就是往前删, 一直没有就一直继承上一个dp值) dp[i][j] = dp[i][j - 1];</span></span><br><span class="line">        <span class="comment">// 3. 长度为-1的子数组没有意义 -&gt; dp[0][j] = 0; dp[i][0] = 0;</span></span><br><span class="line">        <span class="comment">// 4. 顺序遍历</span></span><br><span class="line">        <span class="comment">// 5. -</span></span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(t.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= t.<span class="built_in">size</span>(); ++j) &#123;    <span class="comment">//这里改成j = i也可以AC</span></span><br><span class="line">                <span class="keyword">if</span> (s[i - <span class="number">1</span>] == t[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dp[s.<span class="built_in">size</span>()][t.<span class="built_in">size</span>()] == s.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="不同的子序列"><a href="#不同的子序列" class="headerlink" title="不同的子序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/distinct-subsequences/">不同的子序列</a></h4><ol>
<li>思路：匹配单个元素的时候可以使用当前元素也可以不使用当前元素，使用当前元素就是dp[i][j] &#x3D; dp[i - 1][j - 1], 不使用当前元素就是dp[i][j] &#x3D; dp[i - 1][j]; 如果匹配失败，则找下一元素dp[i][j] &#x3D; dp[i - 1][j];</li>
<li>dp[i][0]一定都是1，因为也就是把以i-1为结尾的s，删除所有元素，出现空字符串的个数就是1。</li>
<li>当s[i - 1] 与 t[j - 1]不相等时，不用s[i - 1]来匹配（就是模拟在s中删除这个元素），即：dp[i - 1][j]</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numDistinct</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 长度为i-1的s子序列中, 长度为j-1的t子序列出现的个数为dp[i][j]</span></span><br><span class="line">        <span class="comment">// 2. 第i-1位与第j-1位相同 -&gt; if (s[i - 1] == t[j - 1]) dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];</span></span><br><span class="line">        <span class="comment">// 2. 加的后面那个部分 -&gt; 可以不使用最后一位进行匹配, 而是只使用前面的i-2位匹配</span></span><br><span class="line">        <span class="comment">// 2. 不相同 -&gt; dp[i][j] = dp[i - 1][j];</span></span><br><span class="line">        <span class="comment">// 3. 初始化:dp[0][j]没有意义; s随便删除, 都能够和空字符串进行匹配 -&gt; dp[i][0] = 1;</span></span><br><span class="line">        <span class="comment">// 4. 顺序遍历</span></span><br><span class="line">        <span class="comment">// 5. -</span></span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">uint32_t</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">uint32_t</span>&gt;(t.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= s.<span class="built_in">size</span>(); ++i) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= t.<span class="built_in">size</span>(); ++j) dp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= t.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i - <span class="number">1</span>] == t[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for (const vector&lt;int&gt;&amp; vi : dp) &#123;</span></span><br><span class="line">        <span class="comment">//     for (const int&amp; i : vi) &#123;</span></span><br><span class="line">        <span class="comment">//         cout &lt;&lt; i &lt;&lt; &quot; &quot;;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[s.<span class="built_in">size</span>()][t.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="两个字符串的删除操作"><a href="#两个字符串的删除操作" class="headerlink" title="两个字符串的删除操作"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-operation-for-two-strings/">两个字符串的删除操作</a></h4><ol>
<li>思路：将所有操作统一为删，相同则继承上一个状态，不相同则删掉其中一个字符串，然后步数+1</li>
<li>因为只需要记录步数，所以不区分操作，将操作统一为删</li>
<li>初始化的时候要注意，任一字符串为空的时候，另一个字符串有多长，要做的删除操作就有多少步；详见初始化的逻辑</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. word1长度为i-1的子串与word2长度为j-1的子串最少需经过dp[i][j]次能相同</span></span><br><span class="line">        <span class="comment">// 2. if (word1[i - 1] == word2[j - 1]) dp[i][j] = dp[i - 1][j - 1]; &lt;- 两边具有相同字母不需要改变</span></span><br><span class="line">        <span class="comment">// 2. else &#123; dp[i][j] = min(&#123;dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + 2&#125;)&#125;</span></span><br><span class="line">        <span class="comment">// 2. 上面三种分别对应： 删word1, 删word2, 两个都删</span></span><br><span class="line">        <span class="comment">// 3. 初始化: dp[i][0] = i; dp[0][j] = j; 如果另一个串是空串 -&gt; 需要把全部字符都删掉</span></span><br><span class="line">        <span class="comment">// 4. 顺序遍历</span></span><br><span class="line">        <span class="comment">// 5. -</span></span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(word<span class="number">1.</span><span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(word<span class="number">2.</span><span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= word<span class="number">1.</span><span class="built_in">size</span>(); ++i) dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= word<span class="number">2.</span><span class="built_in">size</span>(); ++j) dp[<span class="number">0</span>][j] = j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= word<span class="number">1.</span><span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= word<span class="number">2.</span><span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// for (const vector&lt;int&gt;&amp; vi : dp) &#123;</span></span><br><span class="line">        <span class="comment">//     for (const int&amp; i : vi) &#123;</span></span><br><span class="line">        <span class="comment">//         cout &lt;&lt; i &lt;&lt; &quot; &quot;;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[word<span class="number">1.</span><span class="built_in">size</span>()][word<span class="number">2.</span><span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/edit-distance/">编辑距离</a></h4><ol>
<li>思路：相同则继承上一个状态，不相同则进行删除和替换操作</li>
<li>初始化的时候和【583】两个字符串的删除操作相同，一个字符串是空串的时候另一个要做size次删除操作</li>
<li>替换元素dp[i][j] &#x3D; dp[i - 1][j - 1] + 1; word1或word2删除元素（一个删除相当于另一个增加）dp[i][j] &#x3D; dp[i - 1][j]或dp[i][j - 1]</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. word1长度为i-1的子串转换成word2长度为j-1的子串最少需要经过dp[i][j]</span></span><br><span class="line">        <span class="comment">// 2. 当前位相同 -&gt; 不需要操作 -&gt; dp[i][j] = dp[i - 1][j - 1];</span></span><br><span class="line">        <span class="comment">// 2. 需要删除word1子串 -&gt; dp[i][j] = dp[i - 1][j] + 1;</span></span><br><span class="line">        <span class="comment">// 2. 需要插入一个字符到word1子串 -&gt; 操作次数与删除word2子串相同 -&gt; dp[i][j] = dp[i][j - 1] + 1;</span></span><br><span class="line">        <span class="comment">// 2. 需要替换一个字符 -&gt; dp[i][j] = dp[i - 1][j - 1] + 1;**</span></span><br><span class="line">        <span class="comment">// 3. 初始化: dp[i][0] = i; dp[0][j] = j;</span></span><br><span class="line">        <span class="comment">// 4. 顺序遍历</span></span><br><span class="line">        <span class="comment">// 5. 替换操作从相同的子串开始, 操作数+1就可以</span></span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(word<span class="number">1.</span><span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(word<span class="number">2.</span><span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= word<span class="number">1.</span><span class="built_in">size</span>(); ++i) dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= word<span class="number">2.</span><span class="built_in">size</span>(); ++j) dp[<span class="number">0</span>][j] = j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= word<span class="number">1.</span><span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= word<span class="number">2.</span><span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(&#123;dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]&#125;) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[word<span class="number">1.</span><span class="built_in">size</span>()][word<span class="number">2.</span><span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/leetcode/" rel="tag"># leetcode</a>
              <a href="/tags/algorithm/" rel="tag"># algorithm</a>
              <a href="/tags/dynamic-programming/" rel="tag"># dynamic programming</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/11/16/Analysis-of-Low-Memory/" rel="prev" title="Computer System | Analysis of Low Memory">
      <i class="fa fa-chevron-left"></i> Computer System | Analysis of Low Memory
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/12/10/Backtracking/" rel="next" title="Backtracking">
      Backtracking <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9F%BA%E7%A1%80%E9%A2%98%E7%9B%AE"><span class="nav-number">1.</span> <span class="nav-text">动态规划基础题目</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0"><span class="nav-number">1.1.</span> <span class="nav-text">斐波那契数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%88%AC%E6%A5%BC%E6%A2%AF1"><span class="nav-number">1.2.</span> <span class="nav-text">爬楼梯1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="nav-number">1.3.</span> <span class="nav-text">使用最小花费爬楼梯</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84"><span class="nav-number">1.4.</span> <span class="nav-text">不同路径</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%E2%85%A1"><span class="nav-number">1.5.</span> <span class="nav-text">不同路径Ⅱ</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86"><span class="nav-number">1.6.</span> <span class="nav-text">整数拆分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">1.7.</span> <span class="nav-text">不同的二叉搜索树</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-number">2.</span> <span class="nav-text">背包问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#01%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%EF%BC%88%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84%EF%BC%89"><span class="nav-number">2.1.</span> <span class="nav-text">01背包理论基础（滚动数组）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86"><span class="nav-number">2.2.</span> <span class="nav-text">分割等和子集</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F%E2%85%A1"><span class="nav-number">2.3.</span> <span class="nav-text">最后一块石头的重量Ⅱ</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87%E5%92%8C"><span class="nav-number">2.4.</span> <span class="nav-text">目标和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E5%92%8C%E9%9B%B6"><span class="nav-number">2.5.</span> <span class="nav-text">一和零</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85"><span class="nav-number">2.6.</span> <span class="nav-text">完全背包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2%E2%85%A1"><span class="nav-number">2.7.</span> <span class="nav-text">零钱兑换Ⅱ</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A3"><span class="nav-number">2.8.</span> <span class="nav-text">组合总和Ⅳ</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%88%AC%E6%A5%BC%E6%A2%AF%E8%BF%9B%E9%98%B6%E7%89%88"><span class="nav-number">2.9.</span> <span class="nav-text">爬楼梯进阶版</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2"><span class="nav-number">2.10.</span> <span class="nav-text">零钱兑换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0"><span class="nav-number">2.11.</span> <span class="nav-text">完全平方数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86"><span class="nav-number">2.12.</span> <span class="nav-text">单词拆分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85"><span class="nav-number">2.13.</span> <span class="nav-text">多重背包</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E9%97%AE%E9%A2%98"><span class="nav-number">3.</span> <span class="nav-text">打家劫舍问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="nav-number">3.1.</span> <span class="nav-text">打家劫舍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E2%85%A1"><span class="nav-number">3.2.</span> <span class="nav-text">打家劫舍Ⅱ</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E2%85%A2"><span class="nav-number">3.3.</span> <span class="nav-text">打家劫舍Ⅲ</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98"><span class="nav-number">4.</span> <span class="nav-text">股票问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA"><span class="nav-number">4.1.</span> <span class="nav-text">买卖股票的最佳时机</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E2%85%A1-%E5%8F%AF%E4%BB%A5%E5%A4%9A%E6%AC%A1%E4%B9%B0%E5%8D%96"><span class="nav-number">4.2.</span> <span class="nav-text">买卖股票的最佳时机Ⅱ - 可以多次买卖</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E2%85%A2-%E5%8F%AF%E4%BB%A5%E4%B9%B0%E5%8D%962%E6%AC%A1"><span class="nav-number">4.3.</span> <span class="nav-text">买卖股票的最佳时机Ⅲ - 可以买卖2次</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV"><span class="nav-number">4.4.</span> <span class="nav-text">买卖股票的最佳时机IV</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F"><span class="nav-number">4.5.</span> <span class="nav-text">最佳买卖股票时机含冷冻期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9"><span class="nav-number">4.6.</span> <span class="nav-text">买卖股票的最佳时机含手续费</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%E9%97%AE%E9%A2%98"><span class="nav-number">5.</span> <span class="nav-text">编辑距离问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">5.1.</span> <span class="nav-text">最长递增子序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">5.2.</span> <span class="nav-text">最长连续递增子序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">5.3.</span> <span class="nav-text">最长重复子序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">5.4.</span> <span class="nav-text">最长公共子序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C-%E5%8A%A8%E8%A7%84%E5%92%8C%E8%B4%AA%E5%BF%83"><span class="nav-number">5.5.</span> <span class="nav-text">最大子数组和 - 动规和贪心</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">5.6.</span> <span class="nav-text">判断子序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">5.7.</span> <span class="nav-text">不同的子序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="nav-number">5.8.</span> <span class="nav-text">两个字符串的删除操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB"><span class="nav-number">5.9.</span> <span class="nav-text">编辑距离</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Make1tRight"
      src="/uploads/xiaoxin.jpg">
  <p class="site-author-name" itemprop="name">Make1tRight</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/make1tRight" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;make1tRight" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:xliang9809@163.com" title="E-Mail → mailto:xliang9809@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Make1tRight</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
