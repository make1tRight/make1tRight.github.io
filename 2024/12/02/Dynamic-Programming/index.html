<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="动态规划基础题目斐波那契数 思路：递推公式照搬，注意2之前的输出就可以 动规五部曲：数组含义 -&gt; 递推公式 -&gt; 初始化 -&gt; 遍历顺序 -&gt; 举例 第i个斐波那契数是dp[i] 递归公式是f(n) &#x3D; f(n - 1) + f(n - 2) 初始条件是f(0) &#x3D; 0; f(1) &#x3D; 1; 递推顺序是从小到大 举例推导（自己算前几个数）">
<meta property="og:type" content="article">
<meta property="og:title" content="Dynamic Programming">
<meta property="og:url" content="http://example.com/2024/12/02/Dynamic-Programming/index.html">
<meta property="og:site_name" content="Make it right.">
<meta property="og:description" content="动态规划基础题目斐波那契数 思路：递推公式照搬，注意2之前的输出就可以 动规五部曲：数组含义 -&gt; 递推公式 -&gt; 初始化 -&gt; 遍历顺序 -&gt; 举例 第i个斐波那契数是dp[i] 递归公式是f(n) &#x3D; f(n - 1) + f(n - 2) 初始条件是f(0) &#x3D; 0; f(1) &#x3D; 1; 递推顺序是从小到大 举例推导（自己算前几个数）">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-12-02T00:45:48.000Z">
<meta property="article:modified_time" content="2024-12-02T01:08:05.053Z">
<meta property="article:author" content="Make1tRight">
<meta property="article:tag" content="leetcode">
<meta property="article:tag" content="algorithm">
<meta property="article:tag" content="dynamic programming">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2024/12/02/Dynamic-Programming/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Dynamic Programming | Make it right.</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Make it right.</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/02/Dynamic-Programming/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/xiaoxin.jpg">
      <meta itemprop="name" content="Make1tRight">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Make it right.">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Dynamic Programming
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-12-02 08:45:48 / Modified: 09:08:05" itemprop="dateCreated datePublished" datetime="2024-12-02T08:45:48+08:00">2024-12-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="动态规划基础题目"><a href="#动态规划基础题目" class="headerlink" title="动态规划基础题目"></a>动态规划基础题目</h3><h4 id="斐波那契数"><a href="#斐波那契数" class="headerlink" title="斐波那契数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fibonacci-number/">斐波那契数</a></h4><ol>
<li>思路：递推公式照搬，注意2之前的输出就可以</li>
<li>动规五部曲：数组含义 -&gt; 递推公式 -&gt; 初始化 -&gt; 遍历顺序 -&gt; 举例</li>
<li>第i个斐波那契数是dp[i]</li>
<li>递归公式是f(n) &#x3D; f(n - 1) + f(n - 2)</li>
<li>初始条件是f(0) &#x3D; 0; f(1) &#x3D; 1;</li>
<li>递推顺序是从小到大</li>
<li>举例推导（自己算前几个数）</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// dp数组含义 第i项是dp[i]</span></span><br><span class="line">        <span class="comment">// 递推公式 dp[i] = dp[i - 1] + dp[i - 2]</span></span><br><span class="line">        <span class="comment">// 初始化 dp[0] = 0; dp[1] = 1</span></span><br><span class="line">        <span class="comment">// 遍历顺序 从小到大</span></span><br><span class="line">        <span class="comment">// dp数组</span></span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>; dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; dp.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="爬楼梯1"><a href="#爬楼梯1" class="headerlink" title="爬楼梯1"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/">爬楼梯1</a></h4><ol>
<li>思路：要达到n层，有剩1步和剩2步的情况，剩1步 -&gt; 那么有dp[i - 1]种方法能到达i - 1层，剩2步 -&gt; 那么有dp[i - 2]种方法能到达i - 2层；总共有dp[i - 1] + dp[i - 2]种方法能到达i层</li>
<li>爬到第i阶楼梯的时候有dp[i]种方法</li>
<li>递归公式是f(n) &#x3D; f(n - 1) + f(n - 2) ：<ol>
<li>假设自己在第一层 -&gt; 只有一种方法能上到1层 &#x3D;&gt; +1</li>
<li>现在要上第三层 -&gt; 有两种方法能往上2层 &#x3D;&gt; +2</li>
<li>所以要到第三层有 +1+2 &#x3D; 3种方法（初始状态变成2层 &#x3D;&gt; 上两层）</li>
<li>–</li>
</ol>
</li>
<li>初始条件是f(1) &#x3D; 1; f(2) &#x3D; 2</li>
<li>递推顺序是从小到大</li>
<li>举例推导</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 爬上i阶有dp[i]种方法</span></span><br><span class="line">        <span class="comment">// dp[i] = dp[i - 1] + dp[i - 2]</span></span><br><span class="line">        <span class="comment">// 初始化 dp[1] = 1; dp[2] = 2;</span></span><br><span class="line">        <span class="comment">// 从小到大</span></span><br><span class="line">        <span class="comment">// -</span></span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>)  <span class="keyword">return</span> n;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>; dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt; dp.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="使用最小花费爬楼梯"><a href="#使用最小花费爬楼梯" class="headerlink" title="使用最小花费爬楼梯"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/min-cost-climbing-stairs/description/">使用最小花费爬楼梯</a></h4><ol>
<li>思路：找到从n-1阶或n-2阶爬上来所需花费的最小值，所以递推公式为dp[i] &#x3D; min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);，注意0和1阶不用花费</li>
<li>爬到第i层楼梯需要支付dp[i]的费用，爬第i层需要支付cost[i]的费用</li>
<li>爬到第i层的方法有两种<ol>
<li>到i-1层往上爬1层 -&gt; dp[i - 1] + cost[i - 1]， 其中dp[i - 1]是到i-1层之前的花费、cost[i - 1]是爬i-1层需要的花费</li>
<li>到i-2层往上爬2层 -&gt; dp[i - 2] + cost[i - 2]，与1同理</li>
<li>要找到最小花费，就是从这2种方法里面找到更小的的那个 -&gt; 递推公式为<br>dp[i] &#x3D; min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);</li>
</ol>
</li>
<li>因为第1层和第2层都是可以自由选择的 -&gt; dp[0] &#x3D; 0, dp[1] &#x3D; 0 (但是选择了就要支付对应的cost)</li>
<li>因为是一层一层（索引0-size()）往上爬，所以是从数组的begin遍历到end</li>
<li>最后要到cost.end()这个位置的，因为这个位置才是楼顶</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 爬到i阶最少需要花费dp[i]</span></span><br><span class="line">        <span class="comment">// dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);</span></span><br><span class="line">        <span class="comment">// 初始化 dp[0] = 0; dp[1] = 0;</span></span><br><span class="line">        <span class="comment">// 遍历顺序 从小到大</span></span><br><span class="line">        <span class="comment">// -</span></span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(cost.size() + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="comment">// dp[0] = 0; dp[1] = 0; //初始化的逻辑, 因为都是0可以省略掉</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; dp.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>]);</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;dp[&quot; &lt;&lt; i &lt;&lt; &quot;]=&quot; &lt;&lt; dp[i] &lt;&lt; endl; //打印数组的逻辑</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[cost.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths/">不同路径</a></h4><ol>
<li>思路：要到达当前位置，要么往下走要么往右走；注意一直往下和一直往右走都分别只有一条路径</li>
<li>从(0, 0)到(m, n)有多少条路径 -&gt; 从(0, 0)到(i , j)有dp[i][j]条路径</li>
<li>到达(i, j)路径的方法：<ol>
<li>(i - 1, j)往下走一格到(i, j)，dp[i - 1][j]代表走到(i - 1, j)有多少条路径（1里面说清楚了这里不用赘述）</li>
<li>(i, j - 1)往右走一格到(i, j)</li>
<li>那么综合以上两种方法，总共有dp[i][j] &#x3D;dp[i - 1][j] + dp[i][j - 1]条路径可以到达(i , j)</li>
</ol>
</li>
<li>因为直走到最右一格和直走到最下一个都只有一条路径，所以初始化的时候<ol>
<li>dp[0][j] &#x3D; 1</li>
<li>dp[i][0] &#x3D; 1</li>
</ol>
</li>
<li>走路径一定是从(0 , 0)开始的，从数组的begin到end递推</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 走到[i, j]总共有dp[i][j]条路径</span></span><br><span class="line">        <span class="comment">// 要么往下, 要么往右: dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</span></span><br><span class="line">        <span class="comment">// 往右直走和往下直走都只有一条路径可以到达: dp[0][j] = 1; dp[i][0] = 1;</span></span><br><span class="line">        <span class="comment">// 初始化是从小到大, 因为起点是(0, 0)</span></span><br><span class="line">        <span class="comment">// -</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="不同路径Ⅱ"><a href="#不同路径Ⅱ" class="headerlink" title="不同路径Ⅱ"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths-ii/">不同路径Ⅱ</a></h4><ol>
<li>思路：和不同路径类似，区别是只有在无障碍物的时候才用公式递推</li>
<li>走到(i, j)一共有dp(i, j)条路径可以到达；因为棋盘是二维的，两个变量就能够表达所有位置(obstacleGrid代表了整个棋盘)</li>
<li>因为机器人每次只能向下或者向右移动<ol>
<li>往下移动 -&gt; dp[i - 1][j]</li>
<li>往右移动 -&gt; dp[i][j - 1]</li>
<li>所以能够到达(i, j)的路径有dp[i][j] &#x3D; dp[i - 1][j] + dp[i][j - 1]</li>
<li>另外还有条件，如果网格中有障碍物，那么不能进行下一步递推 -&gt; continue处理</li>
</ol>
</li>
<li>dp数组的初始化：一直向下或一直向右，只有一条路径可以到达<ol>
<li>一直向下dp[i][0] &#x3D; 1</li>
<li>一直向右dp[0][j] &#x3D; 1</li>
<li>碰到障碍物的话就不能继续递推</li>
</ol>
</li>
<li>只能从起点到终点所以只能是从前往后递推</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 到达(i, j)总共有dp[i][j]条路径可以到达</span></span><br><span class="line">        <span class="comment">// 2. 当没有障碍物的时候可以往下走或者往右走 if (obstacleGrid[i][j] == 0) dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</span></span><br><span class="line">        <span class="comment">// 2. 否则就用原来的0, 表示0条路径可到达</span></span><br><span class="line">        <span class="comment">// 初始化 往右走或往下走在不碰到障碍之前都只有一条路径</span></span><br><span class="line">        <span class="comment">// 遍历顺序从小到大</span></span><br><span class="line">        <span class="comment">// -</span></span><br><span class="line">        <span class="type">int</span> n = obstacleGrid.<span class="built_in">size</span>(), m = obstacleGrid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n &amp;&amp; obstacleGrid[i][<span class="number">0</span>] == <span class="number">0</span>; ++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m &amp;&amp; obstacleGrid[<span class="number">0</span>][j] == <span class="number">0</span>; ++j) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][m - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="整数拆分"><a href="#整数拆分" class="headerlink" title="整数拆分"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/integer-break/">整数拆分</a></h4><ol>
<li>思路：拆成2个数或者是2个数以上的乘积，2个数用i,i-j表示，2个数以上用i,dp[i-j]表示；这里dp[i-j]在遍历计算的过程中是会变小的，所以需要有取最大值的逻辑</li>
<li>正整数i的最大乘积为dp[i]</li>
<li>乘积可以由两个数构成(i - j)*j，也可以由多个数构成dp[i - j]*j，其中dp[i - j]是若干个数构成的结果<ol>
<li>因为要找最大值 -&gt; 得递推公式dp[i] &#x3D; max(dp[i], max((i-j)*j, dp[i - j]*j));</li>
<li>其中加入dp[i]的目的是保存当前的最大值</li>
<li>i最大一定是题目给定的n；j是i拆出来的数，所以最大只能到i-1</li>
</ol>
</li>
<li>初始化，最小只有2能拆 -&gt; vector<int>dp(n + 1);dp[2] &#x3D; 1x1 &#x3D; 1;<ol>
<li>没有意义的值不需要初始化</li>
</ol>
</li>
<li>从小到大验证，i的拆分结果可供i+1进行使用</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">integerBreak</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将i拆成j, i-j, 乘积最大为j*dp[i-j]或者是j*(i-j)</span></span><br><span class="line">        <span class="comment">// 递推公式dp[i]=(i-j)*dp[j]</span></span><br><span class="line">        <span class="comment">// 初始化dp[2] = 1;</span></span><br><span class="line">        <span class="comment">// 遍历顺序从小到大</span></span><br><span class="line">        <span class="comment">// -</span></span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123; <span class="comment">//拆成接近的2个数相乘才是最大的, 所以这里可以做一个剪枝, 条件换成j &lt;= i / 2</span></span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], <span class="built_in">max</span>(j * (i - j), j * dp[i - j]));</span><br><span class="line">                <span class="comment">// printf(&quot;i=%d, j=%d, dp[%d]=%d\n&quot;, i, j, i, dp[i]);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="不同的二叉搜索树"><a href="#不同的二叉搜索树" class="headerlink" title="不同的二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-binary-search-trees/">不同的二叉搜索树</a></h4><ol>
<li>思路：节点值范围是[1, n]，可以定义一个变量j让每一个值都做一次根节点，然后累加所有情况</li>
<li>由i个节点能够组成的二叉搜索树有dp[i]种</li>
<li>递推公式：以j为节点，那么[1, j - 1]是这个二叉搜索树的左子树，[j + 1, i]是这个二叉搜索树的右子树 dp[i] +&#x3D; dp[j - 1] * dp[i - j]</li>
<li>初始化dp[0] &#x3D; 1;因为空树也算一个二叉搜索树</li>
<li>遍历顺序是从小到大</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 由i个节点组成且节点值从1到i, 可以组成dp[i]种二叉搜索树</span></span><br><span class="line">        <span class="comment">// 让j做根节点: dp[j - 1] * dp[i - j];</span></span><br><span class="line">        <span class="comment">// 因为每个j做根节点情况要累加, 所以最后结果要求和dp[i] += dp[j - 1] * dp[i - j];</span></span><br><span class="line">        <span class="comment">// 空树也是1种二叉搜索树: dp[0] = 1 </span></span><br><span class="line">        <span class="comment">// 遍历顺序从小到大</span></span><br><span class="line">        <span class="comment">// -</span></span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">                dp[i] += dp[j - <span class="number">1</span>] * dp[i - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><h4 id="01背包理论基础（滚动数组）"><a href="#01背包理论基础（滚动数组）" class="headerlink" title="01背包理论基础（滚动数组）"></a><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1046">01背包理论基础（滚动数组）</a></h4><ol>
<li>思路：统一使用滚动数组来解决01背包问题，倒序遍历背包容量，分为装与不装两种情况，取最大值</li>
<li>背包剩余空间j，可以装下最大价值为dp[j]的物品</li>
<li>递推公式：<ol>
<li>首先判断剩余背包容量是否能够装下当前遍历的物品j&gt;&#x3D; weight[i]</li>
<li>如果装下物品那么有dp[j] &#x3D; dp[j - weight[i]] + value[i]</li>
<li>如果不装下当前物品dp[j] &#x3D; dp[j]，因为没有装东西所以剩余空间不会改变</li>
<li>综上，取最大值dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i]);</li>
</ol>
</li>
<li>初始化<ol>
<li>空间为0的时候什么都装不下：dp[0] &#x3D; 0;初始化vector的值本来就是0，所以这里可以不写</li>
</ol>
</li>
<li>背包容量从大到小遍历、物品从小到大？<ol>
<li>为什么背包的容量要从大到小遍历 -&gt; 因为把数组的元素都初始化为0，从小到大遍历的话，会把已经装进背包的元素再装一遍</li>
<li>反向遍历因为dp数</li>
<li>组里面都是空的，所以涉及到dp的位置都是0，只有物品的价值是非零值</li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 背包空间剩余j, 能够携带研究材料的最大价值为dp[j]</span></span><br><span class="line">    <span class="comment">// 装i物品dp[j] = dp[j - weight[i]] + values[i]</span></span><br><span class="line">    <span class="comment">// 不装i物品dp[j] = dp[j]</span></span><br><span class="line">    <span class="comment">// 取最大值dp[j] = max(dp[j], dp[j - weight[i]] + values[i])</span></span><br><span class="line">    <span class="comment">// 初始化: dp[0] = 0;可以不写 </span></span><br><span class="line">    <span class="comment">// 遍历顺序j从大到小, i从小到大</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">values</span><span class="params">(m, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">weight</span><span class="params">(m, <span class="number">0</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 收集数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; weight[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">        cin &gt;&gt; values[j];</span><br><span class="line">    &#125;   </span><br><span class="line">            </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= weight[i]; --j) &#123;</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + values[i]);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;j=%d, dp[j]=%d&quot;</span>, j, dp[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"> </span><br><span class="line">    cout &lt;&lt; dp[n] &lt;&lt; endl;   <span class="comment">//最后返回dp[n]，代表剩余容量为n时能装下最大物品价值为dp[n] </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-equal-subset-sum/">分割等和子集</a></h4><ol>
<li>思路：01背包的应用，背包剩余空间是还需要的大小，背包所装物品的价值是已有的大小；最后的结果要返回：当背包剩余空间为target的时候，能否正好装下价值为target的物品</li>
<li>要注意dp数组的初始化，dp[target]是包括在里面的，初始化的时候要用vector<int> dp(target+1, 0)</li>
<li>背包容量逆序遍历（如果顺序遍历就会根据本轮的状态进行迭代，逆序遍历是根据上一轮的状态进行迭代），但每换一次物品都会更新一次背包容量为target的情况，这里取最大值</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 目标为j的数组已有的元素之和为dp[j]</span></span><br><span class="line">        <span class="comment">// 2. 加入当前元素: dp[j] = dp[j - nums[i]] + nums[i]</span></span><br><span class="line">        <span class="comment">// 2. 不加入当前元素: dp[j] = dp[j];</span></span><br><span class="line">        <span class="comment">// 2. 取最大值, 接近目标 -&gt; dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);</span></span><br><span class="line">        <span class="comment">// 3. 初始化: dp[0] = 0;</span></span><br><span class="line">        <span class="comment">// 4. nums数组中的元素顺序遍历, j逆序遍历 -&gt; 元素不能重复放入, 而且需要离目标越来越近</span></span><br><span class="line">        <span class="comment">// 5. 达成target这个目标的时候, 元素之和dp[j]正好为target -&gt; dp[target] == target;</span></span><br><span class="line">        <span class="comment">// 5. 物品价值和占用空间是一样的</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = target; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= nums[i]) &#123;</span><br><span class="line">                    dp[j] = <span class="built_in">max</span>(dp[j], dp[j - nums[i]] + nums[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[target] == target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="最后一块石头的重量Ⅱ"><a href="#最后一块石头的重量Ⅱ" class="headerlink" title="最后一块石头的重量Ⅱ"></a>最后一块石头的重量Ⅱ</h4><ol>
<li>思路：类似于416等和分割子集，区别在于最后要返回的是两个子集的差值；要注意动规计算的是已有子集dp[target]，剩余另一个子集是sum - dp[target]</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lastStoneWeightII</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 目标石块的重量为j的时候, 已有石块重量为dp[j]</span></span><br><span class="line">        <span class="comment">// 2. 加入当前石块 -&gt; dp[j] = dp[j - stones[i]] + stones[i];</span></span><br><span class="line">        <span class="comment">// 2. 不加入当前石块 -&gt; dp[j] = dp[j];</span></span><br><span class="line">        <span class="comment">// 3. 初始化 dp[0] = 0;</span></span><br><span class="line">        <span class="comment">// 4. 石块重量顺序遍历, 目标石块重量逆序遍历 -&gt; 因为不能重复加入</span></span><br><span class="line">        <span class="comment">// 5. 目标石块的重量应该是总重量的一半, 才会让石头返回最小重量</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> sum = <span class="built_in">accumulate</span>(stones.<span class="built_in">begin</span>(), stones.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> target = sum / <span class="number">2</span>; <span class="comment">//一定是小的那堆</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; stones.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = target; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= stones[i]) &#123;</span><br><span class="line">                    dp[j] = <span class="built_in">max</span>(dp[j], dp[j - stones[i]] + stones[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (sum - dp[target]) - dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="目标和"><a href="#目标和" class="headerlink" title="目标和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/target-sum/">目标和</a></h4><ol>
<li>思路：分为left和right两个部分，left-right&#x3D;target, left+right&#x3D;sum，所以left&#x3D;(sum+target)&#x2F;2，最后需要找到子集总和为left的组合数</li>
<li>要注意如果(target+sum)%2 &#x3D;&#x3D; 1说明这两个子集分不出来；另外dp[0]&#x3D;1的含义是，要填满剩余空间为0的背包，组合数有1种，那就是什么也不放</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 让最终目标和为j的方法一共有dp[j]种</span></span><br><span class="line">        <span class="comment">// 2. 加入当前元素 dp[j] = dp[j] + dp[j - nums[i]];(dp[i][j] = dp[i - 1][j - nums[i]])</span></span><br><span class="line">        <span class="comment">// 2. 不加入当前元素 dp[j] = dp[j]; (dp[i][j] = dp[i - 1][j])</span></span><br><span class="line">        <span class="comment">// 2. 取最大值 -&gt; 接近目标 -&gt; dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);</span></span><br><span class="line">        <span class="comment">// 3. 初始化 dp[0] = 0 -&gt; 不用动</span></span><br><span class="line">        <span class="comment">// 4. nums元素顺序遍历, target逆序遍历 -&gt; 因为要越来越接近目标, 且放入的元素不能重新放入</span></span><br><span class="line">        <span class="comment">// 5. ↓</span></span><br><span class="line">        <span class="comment">// 将数组分成left和right(2份), left + right = sum</span></span><br><span class="line">        <span class="comment">// left - right = target</span></span><br><span class="line">        <span class="comment">// left = (target + sum) / 2;</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> ((target + sum) % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//left-right不能等于target</span></span><br><span class="line">        <span class="keyword">if</span> (sum &lt; <span class="built_in">abs</span>(target)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = (target + sum) / <span class="number">2</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(left + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = left; j &gt;= nums[i]; --j) &#123;</span><br><span class="line">                <span class="comment">// if (j &gt;= nums[i] ) &#123;</span></span><br><span class="line">                    dp[j] += dp[j - nums[i]];   </span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="一和零"><a href="#一和零" class="headerlink" title="一和零"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ones-and-zeroes/">一和零</a></h4><ol>
<li>思路：01背包问题的应用，剩余背包容量为i和j时，能够装下最大物品价值为dp[i][j]</li>
<li>这里背包容量有2个维度，一个是0一个是1；</li>
<li>根据上一轮小容量的背包数量来推，如果增加了zeroNum和oneNum，能装下的子集长度发生了什么样的变化；也就是所基于上一轮背包存储情况推出当前轮的背包存储情况</li>
<li>物品和背包的遍历顺序一定是背包在内层，只有背包在内层才能够在遍历每个物品的时候把dp数组全部元素都更新一次；</li>
<li>如果背包在外层，那么遍历完全部也才更新一次dp数组，里面的元素是背包容量为j的时候能装下最大的一件物品的价值；因为他不根据其他背包容量来更新（表面上看是有，但是实际上它参考的值全都是0，所以本质上并没有参考其他背包容量的值）</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMaxForm</span><span class="params">(vector&lt;string&gt;&amp; strs, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. strs子集中还需要i个0和j个1时, 其最大长度为dp[i][j]</span></span><br><span class="line">        <span class="comment">// 2. 将元素加入到当前子集 dp[i][j] = dp[i - zeroNum][j - oneNum] + 1; -&gt; 需求减少, 长度+1</span></span><br><span class="line">        <span class="comment">// 2. 不加入当前元素: dp[i][j] = dp[i][j] -&gt; 需求不变, 长度不变</span></span><br><span class="line">        <span class="comment">// 2. 取最大值dp[i][j] = max(dp[i - zeroNum][j - oneNum] + 1, dp[i][j]);</span></span><br><span class="line">        <span class="comment">// 3. dp[0][0] = 0;</span></span><br><span class="line">        <span class="comment">// 4. 需求是越来越少的 -&gt; 逆序遍历</span></span><br><span class="line">        <span class="comment">// 5. 注意dp数组的索引范围</span></span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> string&amp; str : strs) &#123;    <span class="comment">//物品</span></span><br><span class="line">            <span class="type">int</span> zeroNum = <span class="number">0</span>, oneNum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="type">char</span>&amp; ch : str) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ch == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                    ++zeroNum;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ++oneNum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;zeroNum = &quot; &lt;&lt; zeroNum &lt;&lt; &quot;; oneNum = &quot; &lt;&lt; oneNum &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = m; i &gt;= <span class="number">0</span>; --i) &#123;  <span class="comment">//背包</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i &gt;= zeroNum &amp;&amp; j &gt;= oneNum) &#123;</span><br><span class="line">                        dp[i][j] = <span class="built_in">max</span>(dp[i - zeroNum][j - oneNum] + <span class="number">1</span>, dp[i][j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1052">完全背包</a></h4><ol>
<li>思路：完全背包就是在01背包的基础上可以重复放入物品；所以更新dp数组的时候可以基于本轮背包装过的物品来进行更新</li>
<li>本轮装过的物品可以再装，所以背包的容量是顺序遍历的</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 背包空间剩余j时, 装下的最大物品价值为dp[j]</span></span><br><span class="line">    <span class="comment">// 2. 装下当前物品, 则空间减少, 价值增加 -&gt; dp[j] = dp[j - weights[i]] + values[i]</span></span><br><span class="line">    <span class="comment">// 2. 不装当前物品, 则空间和价值都不变 -&gt; dp[j] = dp[j] </span></span><br><span class="line">    <span class="comment">// 3. 暂不初始化</span></span><br><span class="line">    <span class="comment">// 4. 材料顺序遍历, 材料可以重复取用 -&gt; 顺序遍历</span></span><br><span class="line">    <span class="comment">// 5. -</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m, bagWeight;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; bagWeight;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">weights</span><span class="params">(m, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">values</span><span class="params">(m, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; weights[i] &gt;&gt; values[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(bagWeight + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; weights.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = weights[i]; j &lt;= bagWeight; ++j) &#123;</span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j - weights[i]] + values[i], dp[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; dp[bagWeight] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="零钱兑换Ⅱ"><a href="#零钱兑换Ⅱ" class="headerlink" title="零钱兑换Ⅱ"></a>零钱兑换Ⅱ</h4><ol>
<li>思路：完全背包问题（物品可以重复放入），另外要注意力扣示例中有两个元素相加超过int的情况，所以这里元素定义为uint32_t，或者加if判断也行</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">change</span><span class="params">(<span class="type">int</span> amount, vector&lt;<span class="type">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 目标金额为j时, 已有的硬币组合数为dp[j]</span></span><br><span class="line">        <span class="comment">// 2. 加入当前硬币 dp[j] = dp[j - coins[i]]</span></span><br><span class="line">        <span class="comment">// 2. 不加入当前硬币 dp[j] = dp[j] -&gt; dp[j] = dp[j - coins[i]] + dp[j]</span></span><br><span class="line">        <span class="comment">// 2. dp[j] += dp[j - coins[i]]</span></span><br><span class="line">        <span class="comment">// 3. 初始化dp[0] = 1;</span></span><br><span class="line">        <span class="comment">// 4. 硬币顺序遍历, 背包顺序遍历 -&gt; 因为可以重复放入</span></span><br><span class="line">        <span class="comment">// 5. -</span></span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">uint32_t</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; coins.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = coins[i]; j &lt;= amount; ++j) &#123;</span><br><span class="line">                dp[j] += dp[j - coins[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="组合总和Ⅳ"><a href="#组合总和Ⅳ" class="headerlink" title="组合总和Ⅳ"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-iv/">组合总和Ⅳ</a></h4><ol>
<li>思路：完全背包问题，求排列数就是在内层遍历物品(为什么？不理解)</li>
<li>暂时这样理解：每次都遍历全部物品，那么在物品不同的时候就算作不同情况</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">combinationSum4</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 目标总数为j时, 所包含的元素组合个数为dp[j]</span></span><br><span class="line">        <span class="comment">// 2. 加入当前元素 -&gt; dp[j] = dp[j - nums[i]]</span></span><br><span class="line">        <span class="comment">// 2. 不加入当前元素 -&gt; dp[j] = dp[j]</span></span><br><span class="line">        <span class="comment">// 2. 此时目标为j所包含的元素组合个数为dp[j] = dp[j] + dp[j - nums[i]] -&gt; dp[j] += dp[j - nums[i]];</span></span><br><span class="line">        <span class="comment">// 3. 初始化: dp[0] = 1;</span></span><br><span class="line">        <span class="comment">// 4. 背包顺序遍历 -&gt; 元素可以重复放入; 物品放入的顺序不同, 算作不同的组合 -&gt; 物品要放在内层进行遍历</span></span><br><span class="line">        <span class="comment">// 5. -</span></span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">uint32_t</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= target; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= nums[i]) &#123;</span><br><span class="line">                    dp[j] += dp[j - nums[i]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="爬楼梯进阶版"><a href="#爬楼梯进阶版" class="headerlink" title="爬楼梯进阶版"></a><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1067">爬楼梯进阶版</a></h4><ol>
<li>思路：完全背包问题，且要求排列数，所以物品在内层循环</li>
<li>因为放过的元素还可以再放，所以属于完全背包问题；爬123和爬132是两种不同的方法，所以物品要在内层遍历</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 距离楼顶剩余j时, 爬到楼顶的方法有dp[j]种</span></span><br><span class="line">    <span class="comment">// 2. 爬1-m阶 -&gt; 物品是1-m可以让我选</span></span><br><span class="line">    <span class="comment">// 2. 爬i阶 -&gt; dp[j] = dp[j - i];</span></span><br><span class="line">    <span class="comment">// 2. 不爬, 其实也就是累计之前的状态 -&gt; dp[j] = dp[j] -&gt; dp[j] += dp[j - i];</span></span><br><span class="line">    <span class="comment">// 3. dp[1] = 1; -&gt; ***dp[0] = 1才对***</span></span><br><span class="line">    <span class="comment">// 4. 爬过了还可以再爬 -&gt; 物品可以重复放入 -&gt; 背包空间顺序遍历</span></span><br><span class="line">    <span class="comment">// 4. 爬23和爬32是两种不同的爬法 -&gt; 物品放入的顺序是有区分的 -&gt; 物品在内层</span></span><br><span class="line">    <span class="comment">// 5. 如果是dp[1] = 1, dp[0] = 0的话,每次都会少加一个dp[0] = 1</span></span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= i) &#123;</span><br><span class="line">                dp[j] += dp[j - i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; dp[n] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change/">零钱兑换</a></h4><ol>
<li>思路：完全背包问题，已经放入的物品还可以重新放入；取组合数的最小值</li>
<li>将初始值初始为有效值范围外的数值，就不会影响到有效数据的更新，但是要根据题目来具体定</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 要凑成j元, 所需要最少的硬币数量为dp[j]</span></span><br><span class="line">        <span class="comment">// 2. 放入当前硬币 -&gt; dp[j] = dp[j - coins[i]] + 1;</span></span><br><span class="line">        <span class="comment">// 2. 不放入当前硬币 -&gt; dp[j] = dp[j]</span></span><br><span class="line">        <span class="comment">// 2. 取最小值 dp[j] = min(dp[j], dp[j - coins[i]] + 1);</span></span><br><span class="line">        <span class="comment">// 3. 初始化: dp[0] = 0;</span></span><br><span class="line">        <span class="comment">// 4. 硬币可以重复放入 -&gt; 背包顺序遍历; 硬币放入的顺序不重要 -&gt; 硬币在外层</span></span><br><span class="line">        <span class="comment">// 5. 如果dp[j - coins[i]]是初始值要跳过? 为什么? 说明没有这种情况</span></span><br><span class="line">        <span class="keyword">if</span> (amount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; coins.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = coins[i]; j &lt;= amount; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[j - coins[i]] != INT_MAX) &#123;<span class="comment">//***</span></span><br><span class="line">                    dp[j] = <span class="built_in">min</span>(dp[j], dp[j - coins[i]] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for (const int&amp; v: dp) &#123;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; v &lt;&lt; &quot; &quot;;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (dp[amount] == INT_MAX) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/perfect-squares/">完全平方数</a></h4><ol>
<li>思路：物品是i*i, 背包剩余空间是n；因为物品可以重复放入，所以是完全背包问题</li>
<li>这里要对0进行初始化，因为0没有完全平方数</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSquares</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 和为j的完全平方数最少数量为dp[j]</span></span><br><span class="line">        <span class="comment">// 2. 加入 -&gt; dp[j] = dp[j - i*i] + 1;</span></span><br><span class="line">        <span class="comment">// 2. 不加入 -&gt; dp[j] = dp[j]</span></span><br><span class="line">        <span class="comment">// 2. 要求最小数量, 取最小值 -&gt; dp[j] = min(dp[j], dp[j - i*i] + 1);</span></span><br><span class="line">        <span class="comment">// 3. vector&lt;int&gt; dp(n + 1, INT_MAX); dp[0] = 0; dp[1] = 1;</span></span><br><span class="line">        <span class="comment">// 4. 平方数可以重复 -&gt; 顺序遍历, 平方数加入的顺序不重要 -&gt; 物品在外层</span></span><br><span class="line">        <span class="comment">// 5. 这里不用if是因为从1*1开始, 已经把dp[i]每个元素都变成了有效值, 然后再慢慢减少数量</span></span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i*i; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="comment">// if (dp[j - i*i] != INT_MAX) &#123;</span></span><br><span class="line">                    dp[j] = <span class="built_in">min</span>(dp[j], dp[j - i*i] + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">                cout &lt;&lt; dp[j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dp[n] == INT_MAX) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="单词拆分"><a href="#单词拆分" class="headerlink" title="单词拆分"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-break/">单词拆分</a></h4><ol>
<li>思路：单词可以重复放入-&gt;完全背包问题；单词放入的顺序影响判断结果-&gt;背包问题中的排列问题</li>
<li>截取字符串的方法是s.substr(pos, n); pos是位置，n是长度；如果pos超过了s.size()会返回out_of_range，如果pos+n超过了s.size()，只会到末尾</li>
<li>截取字符串内层循环第一个是最长的，然后逐个去掉第一个字母进行匹配</li>
<li>dp数组的含义是j之前能够装下的情况是dp[j]，所以既要判断之前的i可以（dp[i]&#x3D;&#x3D;true）又要判断j-i可以（wordSet.find(word) !&#x3D; wordSet.end()）</li>
<li>这里转成unordered_set是为了调用关联容器的find方法</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 物品是wordDict, 背包是s</span></span><br><span class="line">        <span class="comment">// 1. 能够装下j个字符前的情况为dp[j]</span></span><br><span class="line">        <span class="comment">// 2. 出现在字典里 -&gt; dp[j] = true;</span></span><br><span class="line">        <span class="comment">// 2. 没有出现在字典里 -&gt; dp[j] = false;</span></span><br><span class="line">        <span class="comment">// 3. 初始化 都为false, 然后空字符是可以的</span></span><br><span class="line">        <span class="comment">// 4. 先遍历背包后遍历物品 -&gt; 物品的顺序是固定好的 -&gt; 物品要在内层</span></span><br><span class="line">        <span class="comment">// 5. -</span></span><br><span class="line">        <span class="function">unordered_set&lt;string&gt; <span class="title">wordSet</span><span class="params">(wordDict.begin(), wordDict.end())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(s.size() + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= s.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; j; ++i) &#123;</span><br><span class="line">                string word = s.<span class="built_in">substr</span>(i, j - i);</span><br><span class="line">                <span class="comment">// cout &lt;&lt; word &lt;&lt; &quot; &quot;;</span></span><br><span class="line">                <span class="keyword">if</span> (wordSet.<span class="built_in">find</span>(word) != wordSet.<span class="built_in">end</span>() &amp;&amp; dp[i]) &#123;</span><br><span class="line">                    dp[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[s.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1066">多重背包</a></h4><ol>
<li>思路：多重背包就是在01背包的基础上多了个数，所以我们要多遍历一个数量的数组</li>
<li>要注意的是，背包所能装下最大价值，是可以针对每个物品从0-&gt;nums[i]进行选择的，而不是每个都选最大值，具体可以看k的定义</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> bagWeight, n;</span><br><span class="line">    cin &gt;&gt; bagWeight &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">weights</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">values</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) cin &gt;&gt; weights[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) cin &gt;&gt; values[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) cin &gt;&gt; nums[i];</span><br><span class="line">    <span class="comment">// 1. 剩余容量为j, 当前遍历到的矿石数量剩余k时, 能够装下的最大矿石的价值为dp[j];</span></span><br><span class="line">    <span class="comment">// 2. 装下-&gt; if (j &gt;= weight[i] &amp;&amp; k &gt; 0) dp[j] = dp[j - weight[i]] + k * values[i];</span></span><br><span class="line">    <span class="comment">// 2. 不装 dp[j] = dp[j]</span></span><br><span class="line">    <span class="comment">// 2. 取最大值 dp[j] = max(dp[j], dp[j - weight[i]] + k * values[i]);</span></span><br><span class="line">    <span class="comment">// 3. 初始化:</span></span><br><span class="line">    <span class="comment">// 4. 物品放入的顺序不重要 -&gt; 物品在外层; 物品不能重复放入 -&gt; 背包容量倒序遍历</span></span><br><span class="line">    <span class="comment">// 5. -</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(bagWeight + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = bagWeight; j &gt;= weights[i]; --j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = nums[i]; k &gt; <span class="number">0</span>; --k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= k * weights[i])</span><br><span class="line">                    dp[j] = <span class="built_in">max</span>(dp[j], dp[j - k * weights[i]] + k * values[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; dp[bagWeight] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="打家劫舍问题"><a href="#打家劫舍问题" class="headerlink" title="打家劫舍问题"></a>打家劫舍问题</h3><h3 id="股票问题"><a href="#股票问题" class="headerlink" title="股票问题"></a>股票问题</h3><h3 id="编辑距离问题"><a href="#编辑距离问题" class="headerlink" title="编辑距离问题"></a>编辑距离问题</h3>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/leetcode/" rel="tag"># leetcode</a>
              <a href="/tags/algorithm/" rel="tag"># algorithm</a>
              <a href="/tags/dynamic-programming/" rel="tag"># dynamic programming</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/11/16/Analysis-of-Low-Memory/" rel="prev" title="Computer System | Analysis of Low Memory">
      <i class="fa fa-chevron-left"></i> Computer System | Analysis of Low Memory
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9F%BA%E7%A1%80%E9%A2%98%E7%9B%AE"><span class="nav-number">1.</span> <span class="nav-text">动态规划基础题目</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0"><span class="nav-number">1.1.</span> <span class="nav-text">斐波那契数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%88%AC%E6%A5%BC%E6%A2%AF1"><span class="nav-number">1.2.</span> <span class="nav-text">爬楼梯1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="nav-number">1.3.</span> <span class="nav-text">使用最小花费爬楼梯</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84"><span class="nav-number">1.4.</span> <span class="nav-text">不同路径</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%E2%85%A1"><span class="nav-number">1.5.</span> <span class="nav-text">不同路径Ⅱ</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86"><span class="nav-number">1.6.</span> <span class="nav-text">整数拆分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">1.7.</span> <span class="nav-text">不同的二叉搜索树</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-number">2.</span> <span class="nav-text">背包问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#01%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%EF%BC%88%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84%EF%BC%89"><span class="nav-number">2.1.</span> <span class="nav-text">01背包理论基础（滚动数组）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86"><span class="nav-number">2.2.</span> <span class="nav-text">分割等和子集</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F%E2%85%A1"><span class="nav-number">2.3.</span> <span class="nav-text">最后一块石头的重量Ⅱ</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87%E5%92%8C"><span class="nav-number">2.4.</span> <span class="nav-text">目标和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E5%92%8C%E9%9B%B6"><span class="nav-number">2.5.</span> <span class="nav-text">一和零</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85"><span class="nav-number">2.6.</span> <span class="nav-text">完全背包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2%E2%85%A1"><span class="nav-number">2.7.</span> <span class="nav-text">零钱兑换Ⅱ</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A3"><span class="nav-number">2.8.</span> <span class="nav-text">组合总和Ⅳ</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%88%AC%E6%A5%BC%E6%A2%AF%E8%BF%9B%E9%98%B6%E7%89%88"><span class="nav-number">2.9.</span> <span class="nav-text">爬楼梯进阶版</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2"><span class="nav-number">2.10.</span> <span class="nav-text">零钱兑换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0"><span class="nav-number">2.11.</span> <span class="nav-text">完全平方数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86"><span class="nav-number">2.12.</span> <span class="nav-text">单词拆分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85"><span class="nav-number">2.13.</span> <span class="nav-text">多重背包</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E9%97%AE%E9%A2%98"><span class="nav-number">3.</span> <span class="nav-text">打家劫舍问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98"><span class="nav-number">4.</span> <span class="nav-text">股票问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%E9%97%AE%E9%A2%98"><span class="nav-number">5.</span> <span class="nav-text">编辑距离问题</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Make1tRight"
      src="/uploads/xiaoxin.jpg">
  <p class="site-author-name" itemprop="name">Make1tRight</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/make1tRight" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;make1tRight" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:xliang9809@163.com" title="E-Mail → mailto:xliang9809@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Make1tRight</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
