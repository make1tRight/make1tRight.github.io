<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Make it right.">
<meta property="og:url" content="http://example.com/default-index/index.html">
<meta property="og:site_name" content="Make it right.">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Make1tRight">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/default-index/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Make it right.</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Make it right.</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/03/07/List/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/xiaoxin.jpg">
      <meta itemprop="name" content="Make1tRight">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Make it right.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/03/07/List/" class="post-title-link" itemprop="url">List</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-03-07 23:55:55" itemprop="dateCreated datePublished" datetime="2025-03-07T23:55:55+08:00">2025-03-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-03-21 22:56:42" itemprop="dateModified" datetime="2025-03-21T22:56:42+08:00">2025-03-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/data-structure/" itemprop="url" rel="index"><span itemprop="name">data structure</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="增"><a class="markdownIt-Anchor" href="#增"></a> 增</h3>
<h4 id="随机链表的复制"><a class="markdownIt-Anchor" href="#随机链表的复制"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/copy-list-with-random-pointer/description/?envType=study-plan-v2&amp;envId=top-100-liked">随机链表的复制</a></h4>
<p>深拷贝一个随机链表<br />
<strong>解题步骤与思路O(n)/O(n):</strong></p>
<ol>
<li>构造哈希表记录已构造链表防止无限递归</li>
<li>递归遍历链表</li>
<li>将节点加入到哈希表中</li>
<li>递归拷贝next指针</li>
<li>递归拷贝random指针</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;Node*, Node*&gt; nmap;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!nmap.<span class="built_in">count</span>(head)) &#123;</span><br><span class="line">            Node* newnode = <span class="keyword">new</span> <span class="built_in">Node</span>(head-&gt;val);</span><br><span class="line">            nmap[head] = newnode;</span><br><span class="line">            newnode-&gt;next = <span class="built_in">copyRandomList</span>(head-&gt;next);</span><br><span class="line">            newnode-&gt;random = <span class="built_in">copyRandomList</span>(head-&gt;random);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nmap[head];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="删"><a class="markdownIt-Anchor" href="#删"></a> 删</h3>
<h3 id="查"><a class="markdownIt-Anchor" href="#查"></a> 查</h3>
<h4 id="回文链表"><a class="markdownIt-Anchor" href="#回文链表"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindrome-linked-list/description/?envType=study-plan-v2&amp;envId=top-100-liked">回文链表</a></h4>
<p>给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。</p>
<p><strong>思路1：O(n)/O(n)</strong></p>
<ol>
<li>遍历链表, 记录所有节点到数组</li>
<li>双指针判断数组是否为回文串</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* curr = head;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">        <span class="comment">// 遍历链表, 记录所有节点到数组</span></span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(curr-&gt;val);</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 双指针判断数组是否为回文串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = vec.<span class="built_in">size</span>() - <span class="number">1</span>; i &lt; j; ++i, --j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vec[i] != vec[j]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>思路2：O(n)/O(1)</strong></p>
<ol>
<li>快慢指针找到链表中点/右半链表第一个节点</li>
<li>反转后半链表, 得到2个子链表</li>
<li>各自遍历子链表, 两边值只要不同直接返回false, 否则返回true</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 快慢指针找到链表中点/右半链表第一个节点</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">findMid</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode* temp = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* mid = <span class="built_in">findMid</span>(head);</span><br><span class="line">        <span class="comment">// 反转后半链表, 得到2个子链表</span></span><br><span class="line">        ListNode* head2 = <span class="built_in">reverseList</span>(mid);</span><br><span class="line">        <span class="comment">// 各自遍历子链表, 两边值只要不同直接返回false, 否则返回true</span></span><br><span class="line">        <span class="keyword">while</span> (head2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head-&gt;val != head2-&gt;val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            head2 = head2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="改"><a class="markdownIt-Anchor" href="#改"></a> 改</h3>
<h4 id="反转链表"><a class="markdownIt-Anchor" href="#反转链表"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/description/?envType=study-plan-v2&amp;envId=top-100-liked">反转链表</a></h4>
<p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p>
<p><strong>思路：</strong></p>
<ol>
<li>翻转链表需要3个指针
<ol>
<li>变动的是curr的指针, 所以指针在变动前需要有一个temp指针用于备份下一个节点位置</li>
<li>curr更新完后要指向的是prev节点</li>
<li>调整完指针以后, prev和curr各自向前移位1个节点</li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode* temp = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = prev;<span class="comment">// 反转的逻辑</span></span><br><span class="line">            <span class="comment">// 走到下一个节点</span></span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="反转链表ii"><a class="markdownIt-Anchor" href="#反转链表ii"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list-ii/">反转链表Ⅱ</a></h4>
<p>给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;= right 。<br />
请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。</p>
<p><strong>思路：</strong></p>
<ol>
<li>翻转链表需要3个指针 - 同反转链表</li>
<li>这一题定义虚拟头结点的意义是在开始前记录一下状态</li>
<li>本题的难点在于处理左右边界的条件
<ol>
<li>和反转链表的区别在于, 首个要调整的节点指针要先保存, 因为他要指向的对象还没到</li>
<li>保存完1的状态以后, prev和curr往前走1个节点再开始进行中间节点的调整</li>
<li>因为prev的next要指向最终的prev, curr的next要指向最终的curr</li>
</ol>
</li>
</ol>
<ul>
<li>做题的时候还是要自己模拟一遍, 再开始写代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line">        </span><br><span class="line">        ListNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* curr = dummyHead;</span><br><span class="line">        <span class="type">int</span> diff = right - left;</span><br><span class="line">        <span class="keyword">while</span> (left--) &#123;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意不要成环</span></span><br><span class="line">        ListNode* startNode = prev;</span><br><span class="line">        ListNode* endNode = curr;</span><br><span class="line"></span><br><span class="line">        prev = prev-&gt;next;</span><br><span class="line">        curr = curr-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (diff--) &#123;</span><br><span class="line">            ListNode* temp = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        startNode-&gt;next = prev;</span><br><span class="line">        endNode-&gt;next = curr;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/19/Greedy-Algorithm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/xiaoxin.jpg">
      <meta itemprop="name" content="Make1tRight">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Make it right.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/19/Greedy-Algorithm/" class="post-title-link" itemprop="url">Greedy Algorithm</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-12-19 08:57:20 / Modified: 09:37:46" itemprop="dateCreated datePublished" datetime="2024-12-19T08:57:20+08:00">2024-12-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!-- ![greedy_algorithm](../images/greedy_algorithm_summary.png) -->

<h3 id="需要模拟一次局部最优"><a href="#需要模拟一次局部最优" class="headerlink" title="需要模拟一次局部最优"></a>需要模拟一次局部最优</h3><h4 id="分发饼干"><a href="#分发饼干" class="headerlink" title="分发饼干"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/assign-cookies/description/">分发饼干</a></h4><ol>
<li>思路1：遍历饼干尺寸的写法(小饼干先喂饱小胃口)：<ol>
<li>对饼干尺寸和孩子胃口数组进行排序</li>
<li>直接用result当作孩子胃口数组的索引</li>
<li>那么这时候孩子的胃口是最小的，使用的饼干尺寸也要最小，满足不了当前孩子就换一个大的饼干，所以饼干数组正序遍历</li>
<li>如果最小饼干尺寸连胃口最小的孩子都无法满足，则直接<code>result = 0</code></li>
</ol>
</li>
<li>思路2：遍历孩子胃口的写法(大饼干喂饱大胃口)：<ol>
<li>对饼干尺寸和孩子胃口数组进行排序</li>
<li>如果当前能分发出去的最大饼干尺寸能满足孩子则分发</li>
<li>因为是最大饼干尺寸，所以需要优先满足胃口最大的孩子，满足不了大胃口的孩子就用相同饼干去匹配小一点胃口的孩子，所以孩子数组逆序遍历</li>
<li>如果连最大饼干都无法满足胃口最小的孩子，返回result</li>
</ol>
</li>
<li>两边数组的索引都要对边界条件进行限定，因为不知道是饼干多还是孩子多</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*********思路1：遍历饼干尺寸的写法(小饼干先喂饱小胃口)***********/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; g, vector&lt;<span class="type">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(g.<span class="built_in">begin</span>(), g.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>() &amp;&amp; result &lt; g.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] &lt; g[result]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********思路2：遍历孩子胃口的写法(大饼干喂饱大胃口)***********/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; g, vector&lt;<span class="type">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(g.<span class="built_in">begin</span>(), g.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> j = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = g.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[j] &gt;= g[i]) &#123;</span><br><span class="line">                --j;</span><br><span class="line">                ++result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="摆动序列"><a href="#摆动序列" class="headerlink" title="摆动序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/wiggle-subsequence/">摆动序列</a></h4><ol>
<li>思路：比较上一对差值和当前对差值，如果当前对差值与上一对差值相反，或者上一对差值为0当前对差值不为0，记录结果并更新上一对差值</li>
<li>用curDiff记录当前元素与上一元素的差值，preDiff记录上一对摆动序列差值</li>
<li>记录结果的逻辑中，preDiff能够&#x3D;0(初始值是0)，用于将前2个元素加入到摆动序列中，因为数组的前两个元素一定能构成摆动序列</li>
<li>当<code>curDiff=0</code>的时候不是摆动序列，直接遍历下一对元素</li>
<li>注意这里使用bool变量没有办法分辨平坡的情况，所以还是需要定义一个int变量preDiff来记录上一次差值</li>
<li>为了让结果不受平坡情况的影响，只在出现摆动序列的时候才更新preDiff</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">wiggleMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> preDiff = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> curDiff = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            curDiff = nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> ((preDiff &lt;= <span class="number">0</span> &amp;&amp; curDiff &gt; <span class="number">0</span>) || (preDiff &gt;= <span class="number">0</span> &amp;&amp; curDiff &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">                ++result;</span><br><span class="line">                preDiff = curDiff;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/">最大子数组和</a></h4><ol>
<li>思路：总和&lt;0则放弃，因为和为负数只会拖累后面的总和统计；总和&gt;0则继续累加；记录最大值</li>
<li>如果前几项（就算只有一个元素）之和是个负数，<ol>
<li>那么最多只记录一个负数，因为当数组所有元素都是负数时，只取一个元素就是最大的连续子数组</li>
<li>假设后面有一个数能把前面的和将负数变为正数，那还不如直接取那一个正数：<ol>
<li>如果这个正数后面和是负数的情况，就是最大的连续子数组；</li>
<li>如果这个正数后面和是正数，那么最大的连续子数组继续往后延申</li>
</ol>
</li>
</ol>
</li>
<li>count可以是0，因为循环的第一个语句就将count的数值更新了</li>
<li>result需要是最小负数(INT32_MIN和INT_MIN都可以通过)，不可以是0，因为有可能碰到数组元素都是负数的情况；这时候返回0就不对</li>
<li>局部最优的情况：连续和为负数立即放弃，从下一个元素重新计算连续和</li>
<li>全局最优的情况：选取最大连续和</li>
<li>最大连续和的记录可以通过if (count &gt; result) result &#x3D; count;或者result &#x3D; max(result, count)来实现</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//遍历数组, 和小于0直接放弃之前的</span></span><br><span class="line">        <span class="comment">//和大于0继续累加</span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> result = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            count += nums[i];</span><br><span class="line">            result = <span class="built_in">max</span>(result, count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="买卖股票的最佳时机II"><a href="#买卖股票的最佳时机II" class="headerlink" title="买卖股票的最佳时机II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">买卖股票的最佳时机II</a></h4><ol>
<li>思路：取新数组的正数和，相当于是在前一天买进、当天卖出；收集正利润的区间就是股票买卖的区间</li>
<li>表示股票价格的数组，从第二个元素开始，相邻两个元素作差得到新的数组</li>
<li>把利润分解成以每天为单位，收集每天的正利润（局部最优），进而推出全局最优</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; profit;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            profit.<span class="built_in">push_back</span>(prices[i] - prices[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; profit.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (profit[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                result += profit[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="加油站"><a href="#加油站" class="headerlink" title="加油站"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/gas-station/description/">加油站</a></h4><ol>
<li>思路：从start开始计算，直到位置i能存下的油量总和curSum，每当油量总和curSum为负数则直接更新curSum&#x3D;0，将当前位置作为起点start</li>
<li>在总量totalSum上-比+多 -&gt; 说明从哪个站点出发都无法走完一圈</li>
<li>为什么不需要用到循环数组？因为totalSum保证了能够记录到无论如何都走不了1圈的情况。如果totalSum&gt;0，那么就说明一定有一个起点可以走完一圈，从头遍历到位1次就可以</li>
<li>在已经确定有解的情况下，如果在顺序遍历数组的任意一段<code>[start, i)</code>的过程中，剩余的油量出现了负数的情况，说明点i之前都行不通 -&gt; 更新start &#x3D; i且重新记录curSum</li>
<li>局部最优：累加<code>rest[i]</code>和<code>curSum&gt;0</code>，否则直接放弃，从当前位置i开始计算</li>
<li>全局最优：找到可以跑一圈的起始位置</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//防御式编程, 先判断, 后修改</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">canCompleteCircuit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; gas, vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> curSum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> totalSum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; gas.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curSum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                start = i;</span><br><span class="line">                curSum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curSum += gas[i] - cost[i];</span><br><span class="line">            totalSum += gas[i] - cost[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (totalSum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下面是O(n) O(n)的实现</span></span><br><span class="line">    <span class="comment">// 简化了哪些逻辑?</span></span><br><span class="line">    <span class="comment">// 没有创建一个相同大小的数组去存储每个位置的数据, 只是构造了一个变量而已</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">canCompleteCircuit2</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; gas, vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果可以任意选位置, 为什么不选油最大的初始位置呢?</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; remains;</span><br><span class="line">        <span class="type">int</span> maxVal = INT_MIN;</span><br><span class="line">        <span class="type">int</span> start = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; gas.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxVal &lt; (gas[i] - cost[i])) &#123;</span><br><span class="line">                maxVal = (gas[i] - cost[i]);</span><br><span class="line">                start = i;</span><br><span class="line">            &#125;</span><br><span class="line">            remains.<span class="built_in">push_back</span>(gas[i] - cost[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> sum = <span class="built_in">accumulate</span>(remains.<span class="built_in">begin</span>(), remains.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum = remains[start];</span><br><span class="line">        <span class="comment">// 这里是真的搜索完了1圈, 上面的解法并没有搜索1圈, 因为如果有解只需要遍历1次数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start + <span class="number">1</span>; i &lt; remains.<span class="built_in">size</span>() * <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                start = i % remains.<span class="built_in">size</span>();</span><br><span class="line">                sum = remains[start];</span><br><span class="line">                i = start + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((i % remains.<span class="built_in">size</span>()) == start) &#123; <span class="comment">//回到了原点</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sum += remains[i % remains.<span class="built_in">size</span>()];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> start; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="需要模拟多次局部最优"><a href="#需要模拟多次局部最优" class="headerlink" title="需要模拟多次局部最优"></a>需要模拟多次局部最优</h3><h4 id="分发糖果"><a href="#分发糖果" class="headerlink" title="分发糖果"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/candy/description/">分发糖果</a></h4><ol>
<li>思路：相邻孩子比较拆分成右孩子比左孩子大（顺序遍历）、左孩子比右孩子大（逆序遍历）两种情况</li>
<li>计算相邻孩子应该给的最小糖果数（局部最优） -&gt; 得到能够分发出去最小数量的糖果（全局最优）；这里要注意仅仅只是比较相邻孩子，如果中间间隔有1个孩子并不保证得分高的糖果更多</li>
<li>用<code>vector&lt;int&gt; candyVec(ratings.size(), 1);</code>来初始化容器，因为孩子最少都要有一个糖果</li>
<li>当右边孩子分数更高时 -&gt; <code>candyVec[i] = candyVec[i - 1] + 1;</code>右边孩子要多得一块糖果</li>
<li>但是<code>candyVec[i] = candyVec[i - 1] + 1;</code>没有办法处理左边孩子比右边孩子分数更高的情况，因为如果左边孩子分数更高他要多拿一块糖果</li>
<li>于是需要逆向遍历一次序列，利用条件candyVec[i] &#x3D; max(candyVec[i], candyVec[i + 1] + 1);处理左边孩子分数更高的情况；如果i的糖果本身就比i+1更多则直接继承，否则在i+1的基础上多1个就好<ol>
<li>为什么必须逆向遍历序列才能够处理左边孩子分数更高的情况？ -&gt; 因为i与i+1的比较要用上i+1与i+2的比较结果</li>
<li>i是在i+1所获得糖果的基础上增加的，i+1是在i+2所获得糖果的基础上增加的，以此类推，必须逆向遍历</li>
</ol>
</li>
<li>在左孩子比右孩子分数更高的情况，这里max的2个条件是<code>candyVec[i]</code>是左孩子糖果更多的情况，<code>candyVec[i + 1] + 1</code>是右孩子糖果更多的情况，使用max能够同时满足2个条件</li>
<li>最后遍历candyVec统计总和sum</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">candy</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; ratings)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">candyNum</span><span class="params">(ratings.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; ratings.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                candyNum[i] += candyNum[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = ratings.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i + <span class="number">1</span>] &lt; ratings[i]) &#123;</span><br><span class="line">                candyNum[i] = <span class="built_in">max</span>(candyNum[i], candyNum[i + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> sum = <span class="built_in">accumulate</span>(candyNum.<span class="built_in">begin</span>(), candyNum.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="根据身高重建队列"><a href="#根据身高重建队列" class="headerlink" title="根据身高重建队列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/queue-reconstruction-by-height/description/">根据身高重建队列</a></h4><ol>
<li>思路：在原数组中对身高h进行倒序排列，后构造一个新数组按k作为位置插入；</li>
<li>因为身高矮的往前插不会影响后面k值的正确性，所以在新数组中先插入高的后插入矮的，这也是为什么身高要倒序排列的原因；</li>
<li>为什么要构造一个新的数组用于插入？ 因为原数组的位置不能再改变了，且插入位置每次要按k动态进行</li>
<li>身高和前面更高（一样高）人数是两个维度，一次只对一个维度的数据进行处理</li>
<li>使用vector的插入操作时间复杂度是很高的，因为如果插入元素&gt;当前size，那么vector需要进行扩容,这个扩容操作是创建一个容量x2的新空间 -&gt; 把元素全部复制到新创建的空间中去O(n)</li>
<li>考虑3，如果是刚insert完容量不够的情况，那么单纯一个插入操作的时间复杂度就是O(n^2)</li>
<li>如何避免vector扩容时间复杂度高的问题？<ol>
<li>vector的底层实现是数组 -&gt; 使用连续的内存所以需要根据3去扩大自己的容量</li>
<li>使用链表的话则没有这个劣势 -&gt; 链表扩容只需要添加指向下一元素的指针和下一元素</li>
<li>考虑2，list的底层实现就是链表，所以这题用链表来做是更高效的</li>
</ol>
</li>
<li>关于容器的选择，按位置（或者说索引来访问）可以用顺序容器；如果是按关键字来访问，使用关联容器；关联容器是不支持按位置插入的操作的</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; lhs, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; rhs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lhs[<span class="number">0</span>] == rhs[<span class="number">0</span>]) <span class="keyword">return</span> lhs[<span class="number">1</span>] &lt; rhs[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> lhs[<span class="number">0</span>] &gt; rhs[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//数组实现</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; people) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(people.<span class="built_in">begin</span>(), people.<span class="built_in">end</span>(), compare);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; people.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="type">int</span> position = people[i][<span class="number">1</span>];</span><br><span class="line">            result.<span class="built_in">insert</span>(result.<span class="built_in">begin</span>() + position, people[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 链表实现</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">reconstructQueueByList</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; people) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(people.<span class="built_in">begin</span>(), people.<span class="built_in">end</span>(), compare);</span><br><span class="line">        list&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; people.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="type">int</span> position = people[i][<span class="number">1</span>];</span><br><span class="line">            list&lt;vector&lt;<span class="type">int</span>&gt;&gt;::iterator it = result.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">while</span> (position--) &#123;</span><br><span class="line">                ++it;</span><br><span class="line">            &#125;</span><br><span class="line">            result.<span class="built_in">insert</span>(it, people[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="划分字母区间"><a href="#划分字母区间" class="headerlink" title="划分字母区间"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-labels/description/">划分字母区间</a></h4><ol>
<li>思路：哈希表记录每个字母最后出现的位置，因为只有字母所以可以用数组做哈希表；遍历字符串的每个字母，取遍历过的所有字母中出现的最后位置作为右边界，当遍历到右边界的时候更新左边界</li>
<li>如果要对固定数量的元素构造哈希表，优先选用数组</li>
<li>找到每个字符出现的最远边界，作为划分的依据</li>
<li>当for循环遍历到右边界的时候再收集结果、更新左边界</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">partitionLabels</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> dis[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            dis[s[i] - <span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            right = <span class="built_in">max</span>(right, dis[s[i] - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">            <span class="keyword">if</span> (i == right) &#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(right - left + <span class="number">1</span>);</span><br><span class="line">                left = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="覆盖范围与重叠区间"><a href="#覆盖范围与重叠区间" class="headerlink" title="覆盖范围与重叠区间"></a>覆盖范围与重叠区间</h3><h4 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/jump-game/">跳跃游戏</a></h4><ol>
<li>思路：定义当前可跳跃范围作为for循环的条件，动态调整for循环可覆盖的范围，若超过数组最后一位索引则视为可以到达，返回true，否则返回false</li>
<li>不需要精确到每一步是怎么样的，只需要计算跳跃距离cover最大是否能够覆盖整个数组就可以</li>
<li>计算每一个位置的<code>curDistance = i + nums[i];</code>计算最大的<code>curDistance = max(i + num[i], curDistance)</code></li>
<li>具体跳几步无所谓，重要的是能够跳的范围</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> curDistance = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= curDistance; ++i) &#123;</span><br><span class="line">            curDistance = <span class="built_in">max</span>(curDistance, i + nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (curDistance &gt;= nums.<span class="built_in">size</span>() - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="跳跃游戏Ⅱ"><a href="#跳跃游戏Ⅱ" class="headerlink" title="跳跃游戏Ⅱ"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/jump-game-ii/description/">跳跃游戏Ⅱ</a></h4><ol>
<li>思路1：每次计算下一步所能够覆盖的最大范围，如果超过了当前可覆盖的最大范围则跳跃步数+1，并且将当前可覆盖范围更新为下一步所能覆盖的最大范围，如果当前可覆盖范围cover到最后一个元素则返回</li>
<li>思路2：遍历数组并记录下一步可覆盖范围最大值，如果指针超过了当前可覆盖范围则将下一步可覆盖范围更新为当前可覆盖范围，步数累加1</li>
<li>这个版本的跳跃游戏是一定能到达目的地的</li>
<li>更新完本轮的ans后，能够覆盖到的最远距离如果已经到达了集合终点就不用再<code>ans++</code>操作了直接中止循环即可</li>
<li>共同点：指针超过了当前可覆盖范围则将下一步可覆盖范围更新为当前可覆盖范围，步数累加1</li>
<li>不同点：一个是将当前所能覆盖的范围作为遍历范围，一个是将整个数组作为遍历范围</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/***思路1：每次计算下一步所能够覆盖的最大范围，如果超过了当前可覆盖的最大范围则跳跃步数+1****/</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> curCover = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> nextCover = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= curCover; ++i) &#123;</span><br><span class="line">            nextCover = <span class="built_in">max</span>(nextCover, i + nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (i == curCover) &#123;</span><br><span class="line">                ++result;</span><br><span class="line">                curCover = nextCover;</span><br><span class="line">                <span class="keyword">if</span> (curCover &gt;= nums.<span class="built_in">size</span>() - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/******思路2：遍历数组并记录下一步可覆盖范围最大值********/</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jump2</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> nextDistance = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> curDistance = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            nextDistance = <span class="built_in">max</span>(nextDistance, i + nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (i == curDistance) &#123;</span><br><span class="line">                ++result;</span><br><span class="line">                curDistance = nextDistance;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="用最少数量的箭引爆气球"><a href="#用最少数量的箭引爆气球" class="headerlink" title="用最少数量的箭引爆气球"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/description/">用最少数量的箭引爆气球</a></h4><ol>
<li>思路：先排序，再处理；气球重叠则更新当前气球右边界为重叠区间右边界最小值，气球不重叠则箭数+1</li>
<li>因为不能错过气球，重叠区间右边多出来的部分没有意义，直接无视掉即可</li>
<li>如果每个元素里面有两个数，只想比较其中一个的话，需要自己构造sort谓词</li>
<li>引爆气球并不一定说，要把元素给去掉，也可以只记录箭数、遍历数组元素</li>
<li>这个右边界是为了保证两个气球都能够射到，所以取当前气球和上一个气球右边界的最小值<code>min(points[i][1], points[i - 1][1]);</code>否则上一个气球就要被错过了</li>
<li>非空区间最少需要一只箭，所以result初始化为1</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMinArrowShots</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (points.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(points.<span class="built_in">begin</span>(), points.<span class="built_in">end</span>(), [](<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; lhs, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; rhs) &#123;</span><br><span class="line">            <span class="keyword">return</span> lhs[<span class="number">0</span>] &lt; rhs[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;[&quot;;</span></span><br><span class="line">        <span class="comment">// for (const vector&lt;int&gt;&amp; point : points) &#123;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; &quot;[&quot; &lt;&lt; point[0]&lt;&lt; &quot;,&quot; &lt;&lt; point[1] &lt;&lt; &quot;]&quot;;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;]&quot; &lt;&lt; endl;</span></span><br><span class="line">        <span class="type">int</span> result = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; points.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (points[i][<span class="number">0</span>] &lt;= points[i - <span class="number">1</span>][<span class="number">1</span>]) &#123;<span class="comment">//重叠则更新右边界为重叠区间右边界</span></span><br><span class="line">                points[i][<span class="number">1</span>] = <span class="built_in">min</span>(points[i][<span class="number">1</span>], points[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (points[i][<span class="number">0</span>] &gt; points[i - <span class="number">1</span>][<span class="number">1</span>]) &#123;<span class="comment">//不重叠result+1</span></span><br><span class="line">                ++result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="无重叠区间"><a href="#无重叠区间" class="headerlink" title="无重叠区间"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/non-overlapping-intervals/description/">无重叠区间</a></h4><ol>
<li>思路1：按左边界进行排序，当前区间左边界小于上一区间的右边界则更新当前区间右边界为两区间右边界最小值 ，然后result+1说明当前区间是需要去掉的（参考452射气球的做法）</li>
<li>思路2：按照右边界进行排序，忽略所有左边界小于当前右边界的段，统计左边界大于右边界的段作为无重叠区间，将数组与无重叠区间统计结果作差得到需要去掉的重叠区间数</li>
<li>c++的成员函数会默认带有this指针，在leetcode刷题的时候定义新的函数都是在class Solution里面进行的，所以是class Solution的成员函数；而如果要给sort函数传递新的谓词，因为谓词不能有this指针 -&gt; 定义成static就可以不带this指针</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思路1：左边界排序的做法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; lhs, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; rhs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lhs[<span class="number">0</span>] == rhs[<span class="number">0</span>]) <span class="keyword">return</span> lhs[<span class="number">1</span>] &lt; rhs[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> lhs[<span class="number">0</span>] &lt; rhs[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), compare);</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;[&quot;;</span></span><br><span class="line">        <span class="comment">// for (const vector&lt;int&gt;&amp; interval : intervals) &#123;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; &quot;[&quot; &lt;&lt; interval[0] &lt;&lt; &quot;,&quot; &lt;&lt; interval[1] &lt;&lt; &quot;]&quot;;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;]&quot; &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; intervals.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &gt;= intervals[i - <span class="number">1</span>][<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++result;</span><br><span class="line">            intervals[i][<span class="number">1</span>] = <span class="built_in">min</span>(intervals[i][<span class="number">1</span>], intervals[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//思路2：右边界排序的做法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; lhs, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; rhs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lhs[<span class="number">1</span>] &lt; rhs[<span class="number">1</span>];<span class="comment">//按照右边界进行排序</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), compare);</span><br><span class="line">        <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> end = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; intervals.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &lt; end) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++count;</span><br><span class="line">            end = <span class="built_in">max</span>(intervals[i - <span class="number">1</span>][<span class="number">1</span>], intervals[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intervals.<span class="built_in">size</span>() - count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-intervals/description/">合并区间</a></h4><ol>
<li>思路1：按左边界对数组进行排序；先把一维向量加进去，发生区间重叠时更新当前一维向量的右边界；区间不重叠时加入下一区间，重叠则更新右边界<ol>
<li>这一题是先把一维向量加进去，再更改里面的值（发生区间重叠的情况）<ol>
<li>因为vector是基于数组实现的，做查找操作<code>result.back()[1]</code>的时候复杂度是O(1)</li>
</ol>
</li>
<li>把第一个元素先放入到结果中，如果当前元素与结果中的back()右边界重叠，则更新back()的右边界为<code>max(result.back()[1], intervals[i][1])</code></li>
<li>如果当前元素与结果中的back()右边界不重叠，则直接放入当前元素</li>
<li>这种做法相当于是把当前元素与上一元素进行比较，这样result不会漏掉最后一个元素</li>
</ol>
</li>
<li>思路2：定义2个表述边界的变量，重叠时左取最小值右取最大值；不重叠时更新为下一边界；这种做法会漏掉最后一对，所以要在循坏外部额外添加最后一个区间</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; lhs, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; rhs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lhs[<span class="number">0</span>] == rhs[<span class="number">0</span>]) <span class="keyword">return</span> lhs[<span class="number">1</span>] &lt; rhs[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> lhs[<span class="number">0</span>] &lt; rhs[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//思路2</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        <span class="comment">//按左边界排序</span></span><br><span class="line">        <span class="comment">//如果当前区间的左边界小于等于上一区间的右边界 -&gt; 合并 -&gt; 左区间取最小值, 右区间取最大值</span></span><br><span class="line">        <span class="comment">//如果当前区间的左边界大于上一区间的右边界 -&gt; 保存结果 -&gt; 更新左区间</span></span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), compare);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="type">int</span> left = intervals[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> right = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; intervals.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &lt;= right) &#123;</span><br><span class="line">                left = <span class="built_in">min</span>(left, intervals[i][<span class="number">0</span>]);</span><br><span class="line">                right = <span class="built_in">max</span>(right, intervals[i][<span class="number">1</span>]);</span><br><span class="line">                <span class="comment">// cout &lt;&lt; &quot;left=&quot; &lt;&lt; left &lt;&lt; &quot;, right=&quot; &lt;&lt; right &lt;&lt; endl;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &gt; right) &#123;</span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; vec&#123;left, right&#125;;</span><br><span class="line">                result.<span class="built_in">push_back</span>(vec);</span><br><span class="line">                left = intervals[i][<span class="number">0</span>];</span><br><span class="line">                right = intervals[i][<span class="number">1</span>];</span><br><span class="line">                <span class="comment">// cout &lt;&lt; &quot;left=&quot; &lt;&lt; left &lt;&lt; &quot;, right=&quot; &lt;&lt; right &lt;&lt; endl;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result.<span class="built_in">push_back</span>(&#123;left, right&#125;);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//思路1</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        <span class="comment">//按左边界排序</span></span><br><span class="line">        <span class="comment">//如果当前区间的左边界小于等于上一区间的右边界 -&gt; 合并 -&gt; 左区间取最小值, 右区间取最大值</span></span><br><span class="line">        <span class="comment">//如果当前区间的左边界大于上一区间的右边界 -&gt; 保存结果 -&gt; 更新左区间</span></span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), compare);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        result.<span class="built_in">push_back</span>(intervals[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; intervals.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (result.<span class="built_in">back</span>()[<span class="number">1</span>] &gt;= intervals[i][<span class="number">0</span>]) &#123;</span><br><span class="line">                result.<span class="built_in">back</span>()[<span class="number">1</span>] = <span class="built_in">max</span>(result.<span class="built_in">back</span>()[<span class="number">1</span>], intervals[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (result.<span class="built_in">back</span>()[<span class="number">1</span>] &lt; intervals[i][<span class="number">0</span>]) &#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(intervals[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="需要自己定义最优的状态"><a href="#需要自己定义最优的状态" class="headerlink" title="需要自己定义最优的状态"></a>需要自己定义最优的状态</h3><h4 id="K次取反后最大化的数组和"><a href="#K次取反后最大化的数组和" class="headerlink" title="K次取反后最大化的数组和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/description/">K次取反后最大化的数组和</a></h4><ol>
<li>思路：局部最优是每次选取最小的值进行取反，整体最优是和最大</li>
<li>算法的局部最优分析<ol>
<li>要使得和最大要把负数变成正数，绝对值大的负数优先</li>
<li>如果没有负数的话就把最小的正数变成负数，有以下2种情况<ol>
<li>如果k是偶数，在保证没有负数的基础上把最小的数x偶数个-1 -&gt; 相当于不变</li>
<li>如果k是奇数，在保证没有负数的基础上把最小的数变成负数</li>
</ol>
</li>
<li>以上算法的时间复杂度是O(nlogn)</li>
</ol>
</li>
<li>另一种局部最优的算法是：每次遍历数组并且取最小值及其索引，将最小值进行取反；这种算法的时间复杂度是O(k * n)，取决于k的大小；所以还是上面的算法更好</li>
<li>给sort函数传递谓词的时候，当结果返回true -&gt; 位置不变；当结果返回false -&gt; 位置调换</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; a, <span class="type">const</span> <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(a) &gt; <span class="built_in">abs</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// O(nlogn)</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestSumAfterKNegations</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), compare);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; <span class="number">0</span> &amp;&amp; k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                --k;</span><br><span class="line">                nums[i] *= <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k % <span class="number">2</span> == <span class="number">1</span>) nums[nums.<span class="built_in">size</span>() - <span class="number">1</span>] *= <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="柠檬水找零"><a href="#柠檬水找零" class="headerlink" title="柠檬水找零"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lemonade-change/description/">柠檬水找零</a></h4><ol>
<li>思路：分别判断5，10，20三种情况，局部最优是留5</li>
<li>有5、10、20三种情况：<ol>
<li>5直接收，</li>
<li>10有5可以收、否则false，</li>
<li>20有10和5可以收、或者有3个5可以收、否则false</li>
</ol>
</li>
<li>当值为20的时候有一个贪心策略，因为5更万能，尽量把5留住就是局部最优</li>
<li>实现全局最优就是尽可能多收5，保证能够符合更多的情况</li>
<li>20不需要统计，因为不会用来找零，只能收</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">lemonadeChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; bills)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> five = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ten = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// int twenty = 0;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; bills.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bills[i] == <span class="number">5</span>) &#123;</span><br><span class="line">                ++five;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (bills[i] == <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> == five) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                --five;</span><br><span class="line">                ++ten;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (bills[i] == <span class="number">20</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ten &gt; <span class="number">0</span> &amp;&amp; five &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    --ten;</span><br><span class="line">                    --five;</span><br><span class="line">                    <span class="comment">// ++twenty;</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (five &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                    five -= <span class="number">3</span>;</span><br><span class="line">                    <span class="comment">// ++twenty;</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="单调递增的数字"><a href="#单调递增的数字" class="headerlink" title="单调递增的数字"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/monotone-increasing-digits/description/">单调递增的数字</a></h4><ol>
<li>思路：高位比低位大，高位-1后面全部更新为9；整数单调自增还要最大，9就是最大的</li>
<li>要判断数字各位数上的关系，可以把数字int通过to_string(n)转换成string类型strNum</li>
<li>处理完成后，要记得把string类型通过stoi(strNum)转换成int类型</li>
<li>只要出现了前一位数比后一位数大，<ol>
<li>后一位数只能变小，所以后一位数不管怎么变都无法满足条件</li>
<li>只能是前一位数-1，为了保证数值更大，后一位数只能是9最大，所以才有strNum[i] &#x3D; ‘9’的处理逻辑</li>
<li>flag要记录遍历顺序中最后-1那个数的下一位数，因为要从flag这个位置开始填9 -&gt; 保证值最大</li>
</ol>
</li>
<li>从后向前遍历才能够保证前一位数一定都比后一位数大；才能保证处理过后的那位数还能继续和前一位数进行比较 -&gt; 保证最后的结果是满足条件的</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">monotoneIncreasingDigits</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        string strNum = <span class="built_in">to_string</span>(n);</span><br><span class="line">        <span class="type">int</span> flag = strNum.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = strNum.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (strNum[i - <span class="number">1</span>] &gt; strNum[i]) &#123;</span><br><span class="line">                flag = i;</span><br><span class="line">                strNum[i - <span class="number">1</span>]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = flag; i &lt; strNum.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            strNum[i] = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stoi</span>(strNum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="监控二叉树"><a href="#监控二叉树" class="headerlink" title="监控二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-cameras/description/">监控二叉树</a></h4><ol>
<li>思路：后序遍历；0表示未覆盖要装摄像头；2表示有覆盖考虑装摄像头；1表示装摄像头的位置孩子节点和父节点都是有覆盖2；</li>
<li>用返回值来记录状态就不用更改二叉树</li>
<li>叶子节点的数量不会比根节点数量少，所以优先处理叶子节点 -&gt; 选用后序遍历</li>
<li>使用数字来记录二叉树结点的状态，但是又不需要构造一个实际的容器去保存这些数值（通过递归来记录各结点的状态）</li>
<li>只有当孩子节点存在未被摄像头覆盖的情况才需要在当前节点装摄像头，否则就要错过了</li>
<li>如果孩子节点都被摄像头覆盖了，那么当前节点可以等遍历到他的父节点再判断是否要装摄像头（局部最优）</li>
<li>最后，因为是通过孩子节点的状态来判断自己要不要装摄像头，那么到根节点的时候如果两个孩子节点都是覆盖状态 -&gt; 根节点也不会再装摄像头（这样会漏掉根节点） -&gt; 主程序中要对根节点多一次判断</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> camera;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">traversal</span><span class="params">(TreeNode* cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="built_in">traversal</span>(cur-&gt;left);</span><br><span class="line">        <span class="type">int</span> right = <span class="built_in">traversal</span>(cur-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">2</span> &amp;&amp; right == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">0</span> || right == <span class="number">0</span>) &#123;</span><br><span class="line">            ++camera;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">1</span> || right == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCameraCover</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        camera = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">traversal</span>(root) == <span class="number">0</span>) &#123;</span><br><span class="line">            ++camera;<span class="comment">//</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// traversal(root);</span></span><br><span class="line">        <span class="keyword">return</span> camera;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/10/Backtracking/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/xiaoxin.jpg">
      <meta itemprop="name" content="Make1tRight">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Make it right.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/10/Backtracking/" class="post-title-link" itemprop="url">Backtracking</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-12-10 11:54:24" itemprop="dateCreated datePublished" datetime="2024-12-10T11:54:24+08:00">2024-12-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-12-26 09:07:16" itemprop="dateModified" datetime="2024-12-26T09:07:16+08:00">2024-12-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/../images/backtracking_summary.png" alt="backtracking_summary"></p>
<h3 id="组合问题"><a href="#组合问题" class="headerlink" title="组合问题"></a>组合问题</h3><h4 id="组合问题-1"><a href="#组合问题-1" class="headerlink" title="组合问题"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combinations/">组合问题</a></h4><ol>
<li>思路：用start保证横向遍历加入不同元素，用k来限制纵向遍历的次数，也就是限制加入结果集的子集长度；保证了结果能够及时返回</li>
<li>一维向量存储路径，二维向量存储路径的总和（也就是结果）</li>
<li>回溯法三部曲；递归函数的返回值以及参数，回溯函数终止条件，单层搜索过程；<ol>
<li>递归函数为什么不需要返回结果？因为在private成员当中定义了存储结果和路径的向量。参数：需要n和k是为了满足题目中每次组合1-n的k个元素，需要startIndex是为了记录路径，不让元素重复组合</li>
<li>回溯函数终止条件：达到叶子结点；怎样才算到达了叶子结点？根据题意，一个组合要有k个元素，那么路径的大小达到了k就说明到达了叶子结点。这时就可以把路径path加入到结果result中</li>
<li>单层搜索过程：通过for循环来取第一个数，通过递归来取第一个数后面的元素，返回[1, x, x, …, x]1是for循环干的事情，递归负责组合后面的xxx，而且可能会有多种组合另外每次要记得回溯，否则会直接在原来已经走完的路径上继续前进</li>
</ol>
</li>
<li>剪枝：如果列表中的元素(n - i) + 1&lt;&#x3D; 剩余需要的元素(k - path.size())【这里+1是因为i本身也没有遍历】；因为后面已经组不成k个元素的组合了，所以后面的i可以直接放弃掉</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt;= end; ++i) &#123;</span><br><span class="line">        <span class="comment">// for (int i = start; i &lt;= end - (k - path.size()) + 1; ++i) &#123; //剪枝优化</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="built_in">backtracking</span>(i<span class="number">+1</span>, end, k);</span><br><span class="line"></span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">        result.<span class="built_in">clear</span>();</span><br><span class="line">        path.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">backtracking</span>(<span class="number">1</span>, n, k);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="组合总和Ⅲ"><a href="#组合总和Ⅲ" class="headerlink" title="组合总和Ⅲ"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-iii/">组合总和Ⅲ</a></h4><ol>
<li>思路：当子集长度&#x3D;k的时候终止纵向遍历（递归），并且如果总和为n的时候收集结果；横向遍历的时候因为每个元素只可以加入一次，所以每次都要做偏移</li>
<li>在终止条件中<code>vec.size() == k</code>和<code>sum == targetSum</code>不可以并列，<code>vec.size() == k</code>必须返回，而<code>sum == targetSum</code>才收集结果<ol>
<li>如果<code>sum != targetSum</code>那么永远也无法return，也就没有办法回溯，最后导致sum溢出（int）或超时</li>
</ol>
</li>
<li>记得回溯：sum要减去当前的数，vec要pop_back当前的数，才能够退回找到前几位数相同的组合</li>
<li>因为把存放结果的容器定义成了私有成员，所以每次执行主函数的时候最好清空容器</li>
<li>递归取组合的第x位数、for循环遍历1-9剩余元素</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> remain, <span class="type">int</span> startIndex)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//直接把存放结果的容器定义成私有成员，每次在执行主函数的时候清空</span></span><br><span class="line">        <span class="comment">//remain的初始值是n; remain=0的时候说明正好收集到了n</span></span><br><span class="line">        <span class="comment">//startIndex是为了记录数字，让数字的组合不重复</span></span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (remain == <span class="number">0</span>) &#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= <span class="number">9</span>; ++i) &#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(i);</span><br><span class="line">            remain -= i;</span><br><span class="line">            <span class="built_in">backtracking</span>(k, remain, i + <span class="number">1</span>);</span><br><span class="line">            remain += i;</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">        result.<span class="built_in">clear</span>();</span><br><span class="line">        path.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">backtracking</span>(k, n, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="电话号码的数字组合"><a href="#电话号码的数字组合" class="headerlink" title="电话号码的数字组合"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">电话号码的数字组合</a></h4><ol>
<li>思路：横向遍历当前数字的每个字母，纵向遍历不同数字的每个字母；抽象地看这题每个数字是不同的集合，本题求的是不同集合之间元素的组合</li>
<li>0-10的map不需要去定义一个键值对，使用string和索引就可以实现目的</li>
<li>string转换成int可以通过计算和‘0’的偏移量来实现</li>
<li>当给定的字符串是空或者是2-9以外的数字要注意特殊处理</li>
<li>这里为什么使用原生数组（const string[]类型）而不是使用vector<ol>
<li>const string[]内存分配在栈上，固定大小，访问速度快</li>
<li>vector内存分配在堆上，更适用于有增删元素的情况</li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string path;</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    <span class="type">const</span> string letterMap[<span class="number">10</span>] &#123;</span><br><span class="line">        <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;abc&quot;</span>,</span><br><span class="line">        <span class="string">&quot;def&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ghi&quot;</span>,</span><br><span class="line">        <span class="string">&quot;jkl&quot;</span>,</span><br><span class="line">        <span class="string">&quot;mno&quot;</span>,</span><br><span class="line">        <span class="string">&quot;pqrs&quot;</span>,</span><br><span class="line">        <span class="string">&quot;tuv&quot;</span>,</span><br><span class="line">        <span class="string">&quot;wxyz&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">const</span> string&amp; digits, <span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == digits.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> digit = digits[index] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        string letters = letterMap[digit];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; letters.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(letters[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(digits, index + <span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        result.<span class="built_in">clear</span>();</span><br><span class="line">        path.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">if</span> (digits.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">backtracking</span>(digits, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum/">组合总和</a></h4><ol>
<li>思路：纵向遍历作为结果集的下一个数，横向遍历是遍历输入数组，可以重复所以传索引的时候不用自增。</li>
<li>candidates中的数字可以无限制重复选取，所以用来遍历candidates的startIndex在回溯过程中是可以重复从当前元素开始的</li>
<li>但是startIndex在回溯的时候没有必要从0开始，因为前一个元素的遍历一定包含了0-i的情况</li>
<li>终止条件不一定是有多少个元素，要根据题意来，这一题是要让元素的总和&#x3D;target，如果元素总和正好是target则记录，超过了target就不需要记录直接返回即可</li>
<li>可以排序以后进行剪枝，让后面的数都是大数，直接把总和超过target的情况全部忽略 -&gt; 可以大大减少程序运行时间</li>
<li>这里需要设置startIndex，用来保证横线遍历的时候每次可以取到不一样的数据，起到去重的作用</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> startIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; candidates.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            target -= candidates[i];</span><br><span class="line">            <span class="built_in">backtracking</span>(candidates, target, i);</span><br><span class="line">            target += candidates[i];</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(candidates, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="组合总和Ⅱ"><a href="#组合总和Ⅱ" class="headerlink" title="组合总和Ⅱ"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-ii/">组合总和Ⅱ</a></h4><ol>
<li>思路：横向遍历每个元素，纵向遍历元素的组合；定义bool数组true用于同一树枝去重，false用于不同高度的树层之间的去重</li>
<li>used可以使用具有相同数值的不同元素情况下，去掉重复的组合；记录了元素的使用状况，<code>used[i - 1] = true</code>代表当前树枝（纵向遍历）使用过；<code>used[i - 1] = false</code>代表当前的树层（横向遍历）使用过；</li>
<li>为什么相邻两个数相同的时候，true就是同一树枝去重，false就是同一数层去重呢？<ol>
<li>因为前一个数是true时说明是基于前一个数进行更深一层的递归，取的数虽然值相同但不是同一个数；另外，当<code>used[i] = true</code>的时候也意味着这个元素被放进了path里面，正在找由他组成的组合</li>
<li>但是前一个数是false的时候，说明已经被遍历过并且状态已经从true恢复为false了，那么这种组合在前面的树枝就已经被考虑过了，本次树枝（循环）可以直接用continue跳过</li>
<li>startIndex控制从左到右遍历数组的“进度”，startIndex就是遍历过程中第一个<code>used[i] = true</code>的索引</li>
</ol>
</li>
<li>因为要去除相同元素，所以需要通过排序将相同元素排列在一起</li>
<li>startIndex决定了每次遍历的起点，避免了重复取值的情况</li>
<li>难点在于如何将重复的数组组合进行去重，最好是在加入之前就排除掉重复的数组组合</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; candidates, vector&lt;<span class="type">bool</span>&gt;&amp; used, <span class="type">int</span> target, <span class="type">int</span> startIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; candidates.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            path.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            target -= candidates[i];</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">backtracking</span>(candidates, used, target, i + <span class="number">1</span>);</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">            target += candidates[i];</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">        result.<span class="built_in">clear</span>();</span><br><span class="line">        path.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">used</span><span class="params">(candidates.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="built_in">backtracking</span>(candidates, used, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="分割回文串"><a href="#分割回文串" class="headerlink" title="分割回文串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindrome-partitioning/">分割回文串</a></h4><ol>
<li>思路：遍历数组元素，判断每个开始元素到终止元素之间是否为回文串，将回文串加入到path中；最终树枝遍历索引startIndex到达字符数组末尾的时候收集结果</li>
<li>切割字符数组用c.substr(index, len)；判断回文字符串用双指针法</li>
<li>startIndex表示的是下一次递归起始位置，分割线startIndex &#x3D;&#x3D; s.size() 就不用再往下递归了，因为已经切到了最后一个元素，此时应当返回</li>
<li>如果子串不是回文串不能直接break；应该使用continue，例如efe，ef的时候就不是回文串，不能因为ef不是就放弃后面的判断</li>
<li>分割回文串的遍历过程是深度优先的，先深入到每一树枝的叶子节点然后回退；每次都从startIndex开始切，每次截断都会进行下一层次的遍历</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; result;</span><br><span class="line">    vector&lt;string&gt; path;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isParlindrome</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start, j = end; i &lt; j; ++i, --j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] != s[j]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> startIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (startIndex == s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isParlindrome</span>(s, startIndex, i)) &#123;</span><br><span class="line">                <span class="comment">//s.substr(index, len) //substr的用法是取索引为index开始，长度为len的子</span></span><br><span class="line">                string str = s.<span class="built_in">substr</span>(startIndex, i - startIndex + <span class="number">1</span>);</span><br><span class="line">                path.<span class="built_in">push_back</span>(str);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isParlindrome</span>(s, startIndex, i)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">backtracking</span>(s, i + <span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">partition</span>(string s) &#123;</span><br><span class="line">        result.<span class="built_in">clear</span>();</span><br><span class="line">        path.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">backtracking</span>(s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="复原IP地址"><a href="#复原IP地址" class="headerlink" title="复原IP地址"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/restore-ip-addresses/">复原IP地址</a></h4><ol>
<li>思路：实现一个判断各点之间数值有效性的函数，当且仅当数值有效，才修改s；当4个数值都有效时，记录结果</li>
<li>判断记录结果的逻辑是收集到了3个小数点，另外，最后一个数值的有效性还没有判断，因此需要在收集结果之前进行判断</li>
<li>为什么可以直接修改s？因为增加了回溯的逻辑所以符合有效性函数条件的s都可以被修改并且加入result</li>
<li>关于有效性的判断逻辑：<ol>
<li>字符转整数用字符与‘0’的偏移量可实现</li>
<li>数值用num&#x3D;num*10 + xxx可实现进位逻辑</li>
<li>数值大于255、起始与终止位置倒置、非0数值有前置0；均可直接返回false</li>
</ol>
</li>
<li>判断有效性的范围是[startIndex, i], startIndex是每层递归的起点；另外，向容器插入元素的时候要使用迭代器，元素插入到容器中是插入到迭代器指向元素的前面，插入后元素的位置就是指定的那个位置</li>
<li>剪枝逻辑：IP地址最少4位最多12位</li>
<li>可以用小数点的个数来判断是否遍历到最后一个数字</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s.insert(s.begin() + i + 1 , &#x27;.&#x27;);        //这里的s.begin()不可以去掉，因为第一个参数是个迭代器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(string&amp; s, <span class="type">int</span> startIndex, <span class="type">int</span> pointNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pointNum == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isValid</span>(s, startIndex, s.<span class="built_in">size</span>() - <span class="number">1</span>)) &#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isValid</span>(s, startIndex, i)) &#123;</span><br><span class="line">                s.<span class="built_in">insert</span>(s.<span class="built_in">begin</span>() + i + <span class="number">1</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                ++pointNum;</span><br><span class="line">                <span class="built_in">backtracking</span>(s, i + <span class="number">2</span>, pointNum);</span><br><span class="line">                --pointNum;</span><br><span class="line">                s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>() + i + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (end &lt; start) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s[start] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; start != end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt;= end; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] &lt; <span class="string">&#x27;0&#x27;</span> || s[i] &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            num = num * <span class="number">10</span> + (s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (num &gt; <span class="number">255</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">restoreIpAddresses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        result.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() &lt; <span class="number">4</span> || s.<span class="built_in">size</span>() &gt; <span class="number">12</span>) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">backtracking</span>(s, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="子集问题"><a href="#子集问题" class="headerlink" title="子集问题"></a>子集问题</h3><h4 id="子集"><a href="#子集" class="headerlink" title="子集"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets/">子集</a></h4><ol>
<li>思路：每次收集nums[i]，并递归收集下一位</li>
<li>startIndex递增的方向与递归方向相同，i递增的方向与for循环的方向相同</li>
<li>result.push_back(path)不需要有终止条件的限制，因为空集也需要收集</li>
<li>这题可以把终止条件去掉，为什么？终止条件是startIndex &gt;&#x3D; nums.size()其实和for循环用的条件i &lt; nums.size()是互为补集的</li>
<li>本题不会发生无限递归的原因在于，每次调用更深层次的递归都会使得i+1，最终可以通过for循环的i &lt; nums.size()条件来终止本轮递归</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> startIndex)</span> </span>&#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(nums, i + <span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="子集Ⅱ"><a href="#子集Ⅱ" class="headerlink" title="子集Ⅱ"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets-ii/">子集Ⅱ</a></h4><ol>
<li>思路：在子集问题的基础上，增加去重逻辑——使用used来标记已经取过的元素，true表示树枝用过，false表示树层用过</li>
<li>去重问题需要判断条件nums[i] &#x3D;&#x3D; nums[i - 1]，所以容器nums要记得sort一下</li>
<li>定义为私有成员的变量可以不加入到参数中，但是用之前要记得clear一下，防止里面还存有垃圾数据</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">bool</span>&gt;&amp; used, <span class="type">int</span> startIndex)</span> </span>&#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">backtracking</span>(nums, used, i + <span class="number">1</span>);</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        result.<span class="built_in">clear</span>();</span><br><span class="line">        path.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">used</span><span class="params">(nums.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="built_in">backtracking</span>(nums, used, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="非递减子序列"><a href="#非递减子序列" class="headerlink" title="非递减子序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/non-decreasing-subsequences/">非递减子序列</a></h4><ol>
<li>思路：每层定义一个unordered_set用于标记已经使用过的元素，实现去重逻辑；判断数组当前元素与path末尾元素的大小实现非递减逻辑；</li>
<li>为什么不能像组合总和Ⅱ那样定义used数组？因为used数组去重的要求是相同的元素必须放在一起，也就是需要排序，但是求子序列不可以排序，排序就不是原来的序列了</li>
<li>对每一层定义unordered_set（关联容器用insert添加元素）的目的是：同层跳过值相同的元素去重；并且只负责本层；因为每次进行更深层的递归会重新定义unordered_set；为什么要去重？相同元素的处理已经在前面的树枝实现了，树层没有必要再实现一次</li>
<li>每一层都会定义一个自己的unordered_set，回溯回来的时候不能erase掉元素，否则记录的重复元素会被删除，去重的效果也就没有了</li>
<li>关于返回的逻辑，回溯会随着i&#x3D;startIndex&#x3D;nums.size()自动返回，所以不用专门设置返回条件；只需要在子序列长度&gt;1的时候记录即可</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> startIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">        &#125;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; uset;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((!path.<span class="built_in">empty</span>() &amp;&amp; nums[i] &lt; path.<span class="built_in">back</span>()) ||</span><br><span class="line">                (uset.<span class="built_in">find</span>(nums[i]) != uset.<span class="built_in">end</span>())) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            uset.<span class="built_in">insert</span>(nums[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(nums, i + <span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">findSubsequences</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        result.<span class="built_in">clear</span>();</span><br><span class="line">        path.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">backtracking</span>(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="排列问题"><a href="#排列问题" class="headerlink" title="排列问题"></a>排列问题</h3><h4 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations/">全排列</a></h4><ol>
<li>思路：与组合总和Ⅱ的区别在于，每次都需要从头开始取元素；标记已经用过的元素通过条件判断跳过；当path的大小&#x3D;数组的大小<code>path.size() = nums.size()</code>的时候 -&gt; 收集结果</li>
<li>去重的逻辑：定义一个存储bool变量类型的动态数组，标记已经用过的元素；当下一层遍历到已经用过的元素直接continue跳过即可</li>
<li>收集结果的逻辑：建立在去重的基础上，path的大小&#x3D;数组的大小，说明已经将所有的元素都放进来了；每深一层递归就多一个元素，数组有多大递归深度就有多深</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">bool</span>&gt;&amp; used)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (used[i] == <span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">backtracking</span>(nums, used);</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        result.<span class="built_in">clear</span>();</span><br><span class="line">        path.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">used</span><span class="params">(nums.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="built_in">backtracking</span>(nums, used);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="全排列II"><a href="#全排列II" class="headerlink" title="全排列II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations-ii/">全排列II</a></h4><ol>
<li>思路：在全排列I的基础上做去重操作</li>
<li>used数组中，递归过程中true代表用过false代表没有用过；</li>
<li>for循环选数过程中就算没有用过（false）如果数值和前一位相同，也一样会得到重复的组合，所以要去掉（和全排列I的区别也就是这个）</li>
<li>如果只使用used数组，used数组中，递归过程中true代表用过false代表没有用过；nums[i] &#x3D;&#x3D; nums[i - 1]这个条件在使用前要记得把nums排序一下（全排列只在意是否用过，不在意顺序）</li>
<li>如果在全排列I的基础上修改，使用used数组和uset的话，可以使用unordered_set<int>来记录每一层出现过的元素（不用排序），如果已经出现过就可以直接continue跳过本次循环</li>
<li>终止条件中的return也可以去掉，因为path.size() &#x3D;&#x3D; nums.size()的时候for循环也结束了</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************在全排列I的基础上加去重逻辑*****************/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">bool</span>&gt;&amp; used)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="comment">// return;</span></span><br><span class="line">        &#125;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; uset;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (used[i] == <span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (uset.<span class="built_in">find</span>(nums[i]) != uset.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            uset.<span class="built_in">insert</span>(nums[i]);</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(nums, used);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">used</span><span class="params">(nums.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">        result.<span class="built_in">clear</span>();</span><br><span class="line">        path.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">backtracking</span>(nums, used);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************只用used数组要记得排序****************/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">bool</span>&gt;&amp; used)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (used[i] == <span class="literal">false</span>) &#123; <span class="comment">//used[i] == true的时候说明元素已经被用过了 -&gt; 跳过</span></span><br><span class="line">                used[i] = <span class="literal">true</span>;</span><br><span class="line">                path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                <span class="built_in">backtracking</span>(nums, used);</span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">                used[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">used</span><span class="params">(nums.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">        result.<span class="built_in">clear</span>();</span><br><span class="line">        path.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">backtracking</span>(nums, used);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><h4 id="重新安排行程"><a href="#重新安排行程" class="headerlink" title="重新安排行程"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reconstruct-itinerary/">重新安排行程</a></h4><ol>
<li>思路：每次遍历result末尾的元素作为起点，找到它能够到达的目的地；如果能够用完所有的机票则返回true，否则返回false</li>
<li>unordered_map来记录source和destination之间的映射关系，为了避免死循环用map来记录目的地和票数量之间的映射关系；</li>
<li>遍历map时，关键字是不能修改的最好定义为const，因为关键字修改了查找操作将变得无效或效率低下</li>
<li><code>unordered_map&lt;string, map&lt;string, int&gt;&gt;</code>这里第一个string是起点，第二个string是终点，int代表有一张票，这个int可以有效代替避免了我们删除元素的操作，因为删除元素会导致迭代器失效</li>
<li>终止条件的意思是：票数+1就是途径的地点数</li>
<li>返回值设置为bool类型是因为，只要找到了一条路就说明成功了</li>
<li>for循环里面遍历的是目的地(第二个string)和能去的次数(int)<ol>
<li>for循环里面pair类型的变量要带引用，才能够记录已到达过的机场</li>
<li>带了引用以后key就不能改变了，所以key要带上const</li>
</ol>
</li>
<li>map中键值对的类型是<code>pair&lt;const Key, Value&gt;</code>，关键字是一个const类型；因为map的底层实现是红黑树，为了保证红黑树的结构不被破坏，所以key是带const的</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;string, map&lt;string, <span class="type">int</span>&gt;&gt; targets;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> ticketNum, vector&lt;string&gt;&amp; result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (result.<span class="built_in">size</span>() == ticketNum + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (pair&lt;<span class="type">const</span> string, <span class="type">int</span>&gt;&amp; elem : targets[result[result.<span class="built_in">size</span>() - <span class="number">1</span>]]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (elem.second &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(elem.first);</span><br><span class="line">                --elem.second;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">backtracking</span>(ticketNum, result)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                ++elem.second;</span><br><span class="line">                result.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findItinerary</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span> </span>&#123;</span><br><span class="line">        targets.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> vector&lt;string&gt;&amp; ticket : tickets) &#123;</span><br><span class="line">            targets[ticket[<span class="number">0</span>]][ticket[<span class="number">1</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;string&gt; result;</span><br><span class="line">        result.<span class="built_in">push_back</span>(<span class="string">&quot;JFK&quot;</span>);</span><br><span class="line">        <span class="built_in">backtracking</span>(tickets.<span class="built_in">size</span>(), result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-queens/">N皇后</a></h4><ol>
<li>思路：<strong>每次遍历棋盘的一行</strong>，满足N皇后有效性检查就递归深一层，也代表着棋盘的下一行；当递归的行数&#x3D;棋盘的行数时回收结果</li>
<li>判断有效性<ol>
<li>同行同列不能出现Q - 同行不需要检查，同列需要检查；因为同一行只会放一个Q，遍历同行的元素的时候会有重置回<code>&#39;.&#39;</code>的逻辑，所以有效性检查只需要检查同列是否有Q</li>
<li>45°不能出现Q - (i-1, j-1)</li>
<li>135°不能出现Q - (i-1, j+1)</li>
</ol>
</li>
<li>chessboard用一个vector<string>就可以表示，string表示棋盘的一行</li>
<li>终止条件是row &#x3D;&#x3D; n result直接回收结果并返回，因为有效性的判断逻辑在每层递归里</li>
<li>每层递归判断有效性后放置皇后并递归遍历下一行</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; result;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col, vector&lt;string&gt;&amp; chessboard, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//检查同列是否有皇后</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chessboard[i][col] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//检查45°是否有皇后</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; --i, --j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chessboard[i][j] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//检查135°是否有皇后</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; --i, ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chessboard[i][j] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> row, vector&lt;string&gt;&amp; chessboard)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == row) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(chessboard);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; n; ++col) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isValid</span>(row, col, chessboard, n)) &#123;</span><br><span class="line">                chessboard[row][col] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">                <span class="comment">//深一层, 棋盘就往下一行</span></span><br><span class="line">                <span class="built_in">backtracking</span>(n, row + <span class="number">1</span>, chessboard);</span><br><span class="line">                chessboard[row][col] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">solveNQueens</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        result.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">chessboard</span><span class="params">(n, string(n, <span class="string">&#x27;.&#x27;</span>))</span></span>;</span><br><span class="line">        <span class="built_in">backtracking</span>(n, <span class="number">0</span>, chessboard);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="解数独"><a href="#解数独" class="headerlink" title="解数独"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sudoku-solver/">解数独</a></h4><ol>
<li>思路：暴力遍历数组中的每一个元素，碰到’.’进行1-9的填数判断；</li>
<li>有效性的判断<ol>
<li>board行检查与board列检查</li>
<li>小格子检查可以使用条件startRow &#x3D; (row&#x2F;3) * 3；结果是小格子的起点，余数是row或者col在小格子中的具体位置；终止条件就是startRow+3，因为小格子固定大小是9x9</li>
</ol>
</li>
<li>必须是<code>&#39;.&#39;</code>的情况才能够填入数字，填入数字可以直接用char型变量不要转来转去</li>
<li>为什么使用的是bool作为返回的条件？因为只要有一种可能性成立即可收集结果</li>
<li>为什么不需要终止条件？</li>
<li>其实有：因为只要有一个格子填1-9都不能够满足有效性 -&gt; 直接返回false不再进行后续的递归</li>
<li>只有当backtracking函数遍历整个board，每个’.’的位置都满足有效性检查的时候才会进行更深一层的递归 -&gt; 最终返回true</li>
<li>如果棋盘上所有的<code>&#39;.&#39;</code>都遍历完了且没有返回false，说明找到了合适的棋盘位置，此时应该返回true</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, <span class="type">int</span> row, <span class="type">int</span> col, <span class="type">char</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][col] == num) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[row][j] == num) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> startRow = (row / <span class="number">3</span>) * <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> startCol = (col / <span class="number">3</span>) * <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startRow; i &lt; startRow + <span class="number">3</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = startCol; j &lt; startCol + <span class="number">3</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == num) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">backtracking</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; board.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">char</span> k = <span class="string">&#x27;1&#x27;</span>; k &lt;= <span class="string">&#x27;9&#x27;</span>; ++k) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="built_in">isValid</span>(board, i, j, k)) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    board[i][j] = k;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">backtracking</span>(board)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solveSudoku</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(board);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/02/Dynamic-Programming/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/xiaoxin.jpg">
      <meta itemprop="name" content="Make1tRight">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Make it right.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/02/Dynamic-Programming/" class="post-title-link" itemprop="url">Dynamic Programming</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-12-02 08:45:48" itemprop="dateCreated datePublished" datetime="2024-12-02T08:45:48+08:00">2024-12-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-12-10 11:54:59" itemprop="dateModified" datetime="2024-12-10T11:54:59+08:00">2024-12-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/../images/dynamic_programming_summary.png" alt="Dynamic-Programming"></p>
<h3 id="动态规划基础题目"><a href="#动态规划基础题目" class="headerlink" title="动态规划基础题目"></a>动态规划基础题目</h3><h4 id="斐波那契数"><a href="#斐波那契数" class="headerlink" title="斐波那契数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fibonacci-number/">斐波那契数</a></h4><ol>
<li>思路：递推公式照搬，注意2之前的输出就可以</li>
<li>动规五部曲：数组含义 -&gt; 递推公式 -&gt; 初始化 -&gt; 遍历顺序 -&gt; 举例</li>
<li>第i个斐波那契数是dp[i]</li>
<li>递归公式是f(n) &#x3D; f(n - 1) + f(n - 2)</li>
<li>初始条件是f(0) &#x3D; 0; f(1) &#x3D; 1;</li>
<li>递推顺序是从小到大</li>
<li>举例推导（自己算前几个数）</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// dp数组含义 第i项是dp[i]</span></span><br><span class="line">        <span class="comment">// 递推公式 dp[i] = dp[i - 1] + dp[i - 2]</span></span><br><span class="line">        <span class="comment">// 初始化 dp[0] = 0; dp[1] = 1</span></span><br><span class="line">        <span class="comment">// 遍历顺序 从小到大</span></span><br><span class="line">        <span class="comment">// dp数组</span></span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>; dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; dp.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="爬楼梯1"><a href="#爬楼梯1" class="headerlink" title="爬楼梯1"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/">爬楼梯1</a></h4><ol>
<li>思路：要达到n层，有剩1步和剩2步的情况，剩1步 -&gt; 那么有dp[i - 1]种方法能到达i - 1层，剩2步 -&gt; 那么有dp[i - 2]种方法能到达i - 2层；总共有dp[i - 1] + dp[i - 2]种方法能到达i层</li>
<li>爬到第i阶楼梯的时候有dp[i]种方法</li>
<li>递归公式是f(n) &#x3D; f(n - 1) + f(n - 2) ：<ol>
<li>假设自己在第一层 -&gt; 只有一种方法能上到1层 &#x3D;&gt; +1</li>
<li>现在要上第三层 -&gt; 有两种方法能往上2层 &#x3D;&gt; +2</li>
<li>所以要到第三层有 +1+2 &#x3D; 3种方法（初始状态变成2层 &#x3D;&gt; 上两层）</li>
<li>–</li>
</ol>
</li>
<li>初始条件是f(1) &#x3D; 1; f(2) &#x3D; 2</li>
<li>递推顺序是从小到大</li>
<li>举例推导</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 爬上i阶有dp[i]种方法</span></span><br><span class="line">        <span class="comment">// dp[i] = dp[i - 1] + dp[i - 2]</span></span><br><span class="line">        <span class="comment">// 初始化 dp[1] = 1; dp[2] = 2;</span></span><br><span class="line">        <span class="comment">// 从小到大</span></span><br><span class="line">        <span class="comment">// -</span></span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>)  <span class="keyword">return</span> n;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>; dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt; dp.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="使用最小花费爬楼梯"><a href="#使用最小花费爬楼梯" class="headerlink" title="使用最小花费爬楼梯"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/min-cost-climbing-stairs/description/">使用最小花费爬楼梯</a></h4><ol>
<li>思路：找到从n-1阶或n-2阶爬上来所需花费的最小值，所以递推公式为dp[i] &#x3D; min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);，注意0和1阶不用花费</li>
<li>爬到第i层楼梯需要支付dp[i]的费用，爬第i层需要支付cost[i]的费用</li>
<li>爬到第i层的方法有两种<ol>
<li>到i-1层往上爬1层 -&gt; dp[i - 1] + cost[i - 1]， 其中dp[i - 1]是到i-1层之前的花费、cost[i - 1]是爬i-1层需要的花费</li>
<li>到i-2层往上爬2层 -&gt; dp[i - 2] + cost[i - 2]，与1同理</li>
<li>要找到最小花费，就是从这2种方法里面找到更小的的那个 -&gt; 递推公式为<br>dp[i] &#x3D; min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);</li>
</ol>
</li>
<li>因为第1层和第2层都是可以自由选择的 -&gt; dp[0] &#x3D; 0, dp[1] &#x3D; 0 (但是选择了就要支付对应的cost)</li>
<li>因为是一层一层（索引0-size()）往上爬，所以是从数组的begin遍历到end</li>
<li>最后要到cost.end()这个位置的，因为这个位置才是楼顶</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 爬到i阶最少需要花费dp[i]</span></span><br><span class="line">        <span class="comment">// dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);</span></span><br><span class="line">        <span class="comment">// 初始化 dp[0] = 0; dp[1] = 0;</span></span><br><span class="line">        <span class="comment">// 遍历顺序 从小到大</span></span><br><span class="line">        <span class="comment">// -</span></span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(cost.size() + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="comment">// dp[0] = 0; dp[1] = 0; //初始化的逻辑, 因为都是0可以省略掉</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; dp.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>]);</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;dp[&quot; &lt;&lt; i &lt;&lt; &quot;]=&quot; &lt;&lt; dp[i] &lt;&lt; endl; //打印数组的逻辑</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[cost.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths/">不同路径</a></h4><ol>
<li>思路：要到达当前位置，要么往下走要么往右走；注意一直往下和一直往右走都分别只有一条路径</li>
<li>从(0, 0)到(m, n)有多少条路径 -&gt; 从(0, 0)到(i , j)有dp[i][j]条路径</li>
<li>到达(i, j)路径的方法：<ol>
<li>(i - 1, j)往下走一格到(i, j)，dp[i - 1][j]代表走到(i - 1, j)有多少条路径（1里面说清楚了这里不用赘述）</li>
<li>(i, j - 1)往右走一格到(i, j)</li>
<li>那么综合以上两种方法，总共有dp[i][j] &#x3D;dp[i - 1][j] + dp[i][j - 1]条路径可以到达(i , j)</li>
</ol>
</li>
<li>因为直走到最右一格和直走到最下一个都只有一条路径，所以初始化的时候<ol>
<li>dp[0][j] &#x3D; 1</li>
<li>dp[i][0] &#x3D; 1</li>
</ol>
</li>
<li>走路径一定是从(0 , 0)开始的，从数组的begin到end递推</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 走到[i, j]总共有dp[i][j]条路径</span></span><br><span class="line">        <span class="comment">// 要么往下, 要么往右: dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</span></span><br><span class="line">        <span class="comment">// 往右直走和往下直走都只有一条路径可以到达: dp[0][j] = 1; dp[i][0] = 1;</span></span><br><span class="line">        <span class="comment">// 初始化是从小到大, 因为起点是(0, 0)</span></span><br><span class="line">        <span class="comment">// -</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="不同路径Ⅱ"><a href="#不同路径Ⅱ" class="headerlink" title="不同路径Ⅱ"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths-ii/">不同路径Ⅱ</a></h4><ol>
<li>思路：和不同路径类似，区别是只有在无障碍物的时候才用公式递推</li>
<li>走到(i, j)一共有dp(i, j)条路径可以到达；因为棋盘是二维的，两个变量就能够表达所有位置(obstacleGrid代表了整个棋盘)</li>
<li>因为机器人每次只能向下或者向右移动<ol>
<li>往下移动 -&gt; dp[i - 1][j]</li>
<li>往右移动 -&gt; dp[i][j - 1]</li>
<li>所以能够到达(i, j)的路径有dp[i][j] &#x3D; dp[i - 1][j] + dp[i][j - 1]</li>
<li>另外还有条件，如果网格中有障碍物，那么不能进行下一步递推 -&gt; continue处理</li>
</ol>
</li>
<li>dp数组的初始化：一直向下或一直向右，只有一条路径可以到达<ol>
<li>一直向下dp[i][0] &#x3D; 1</li>
<li>一直向右dp[0][j] &#x3D; 1</li>
<li>碰到障碍物的话就不能继续递推</li>
</ol>
</li>
<li>只能从起点到终点所以只能是从前往后递推</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 到达(i, j)总共有dp[i][j]条路径可以到达</span></span><br><span class="line">        <span class="comment">// 2. 当没有障碍物的时候可以往下走或者往右走 if (obstacleGrid[i][j] == 0) dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</span></span><br><span class="line">        <span class="comment">// 2. 否则就用原来的0, 表示0条路径可到达</span></span><br><span class="line">        <span class="comment">// 初始化 往右走或往下走在不碰到障碍之前都只有一条路径</span></span><br><span class="line">        <span class="comment">// 遍历顺序从小到大</span></span><br><span class="line">        <span class="comment">// -</span></span><br><span class="line">        <span class="type">int</span> n = obstacleGrid.<span class="built_in">size</span>(), m = obstacleGrid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n &amp;&amp; obstacleGrid[i][<span class="number">0</span>] == <span class="number">0</span>; ++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m &amp;&amp; obstacleGrid[<span class="number">0</span>][j] == <span class="number">0</span>; ++j) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][m - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="整数拆分"><a href="#整数拆分" class="headerlink" title="整数拆分"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/integer-break/">整数拆分</a></h4><ol>
<li>思路：拆成2个数或者是2个数以上的乘积，2个数用i,i-j表示，2个数以上用i,dp[i-j]表示；这里dp[i-j]在遍历计算的过程中是会变小的，所以需要有取最大值的逻辑</li>
<li>正整数i的最大乘积为dp[i]</li>
<li>乘积可以由两个数构成(i - j)*j，也可以由多个数构成dp[i - j]*j，其中dp[i - j]是若干个数构成的结果<ol>
<li>因为要找最大值 -&gt; 得递推公式dp[i] &#x3D; max(dp[i], max((i-j)*j, dp[i - j]*j));</li>
<li>其中加入dp[i]的目的是保存当前的最大值</li>
<li>i最大一定是题目给定的n；j是i拆出来的数，所以最大只能到i-1</li>
</ol>
</li>
<li>初始化，最小只有2能拆 -&gt; vector<int>dp(n + 1);dp[2] &#x3D; 1x1 &#x3D; 1;<ol>
<li>没有意义的值不需要初始化</li>
</ol>
</li>
<li>从小到大验证，i的拆分结果可供i+1进行使用</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">integerBreak</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将i拆成j, i-j, 乘积最大为j*dp[i-j]或者是j*(i-j)</span></span><br><span class="line">        <span class="comment">// 递推公式dp[i]=(i-j)*dp[j]</span></span><br><span class="line">        <span class="comment">// 初始化dp[2] = 1;</span></span><br><span class="line">        <span class="comment">// 遍历顺序从小到大</span></span><br><span class="line">        <span class="comment">// -</span></span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123; <span class="comment">//拆成接近的2个数相乘才是最大的, 所以这里可以做一个剪枝, 条件换成j &lt;= i / 2</span></span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], <span class="built_in">max</span>(j * (i - j), j * dp[i - j]));</span><br><span class="line">                <span class="comment">// printf(&quot;i=%d, j=%d, dp[%d]=%d\n&quot;, i, j, i, dp[i]);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="不同的二叉搜索树"><a href="#不同的二叉搜索树" class="headerlink" title="不同的二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-binary-search-trees/">不同的二叉搜索树</a></h4><ol>
<li>思路：节点值范围是[1, n]，可以定义一个变量j让每一个值都做一次根节点，然后累加所有情况</li>
<li>由i个节点能够组成的二叉搜索树有dp[i]种</li>
<li>递推公式：以j为节点，那么[1, j - 1]是这个二叉搜索树的左子树，[j + 1, i]是这个二叉搜索树的右子树 dp[i] +&#x3D; dp[j - 1] * dp[i - j]</li>
<li>初始化dp[0] &#x3D; 1;因为空树也算一个二叉搜索树</li>
<li>遍历顺序是从小到大</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 由i个节点组成且节点值从1到i, 可以组成dp[i]种二叉搜索树</span></span><br><span class="line">        <span class="comment">// 让j做根节点: dp[j - 1] * dp[i - j];</span></span><br><span class="line">        <span class="comment">// 因为每个j做根节点情况要累加, 所以最后结果要求和dp[i] += dp[j - 1] * dp[i - j];</span></span><br><span class="line">        <span class="comment">// 空树也是1种二叉搜索树: dp[0] = 1 </span></span><br><span class="line">        <span class="comment">// 遍历顺序从小到大</span></span><br><span class="line">        <span class="comment">// -</span></span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">                dp[i] += dp[j - <span class="number">1</span>] * dp[i - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><h4 id="01背包理论基础（滚动数组）"><a href="#01背包理论基础（滚动数组）" class="headerlink" title="01背包理论基础（滚动数组）"></a><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1046">01背包理论基础（滚动数组）</a></h4><ol>
<li>思路：统一使用滚动数组来解决01背包问题，倒序遍历背包容量，分为装与不装两种情况，取最大值</li>
<li>背包剩余空间j，可以装下最大价值为dp[j]的物品</li>
<li>递推公式：<ol>
<li>首先判断剩余背包容量是否能够装下当前遍历的物品j&gt;&#x3D; weight[i]</li>
<li>如果装下物品那么有dp[j] &#x3D; dp[j - weight[i]] + value[i]</li>
<li>如果不装下当前物品dp[j] &#x3D; dp[j]，因为没有装东西所以剩余空间不会改变</li>
<li>综上，取最大值dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i]);</li>
</ol>
</li>
<li>初始化<ol>
<li>空间为0的时候什么都装不下：dp[0] &#x3D; 0;初始化vector的值本来就是0，所以这里可以不写</li>
</ol>
</li>
<li>背包容量从大到小遍历、物品从小到大？<ol>
<li>为什么背包的容量要从大到小遍历 -&gt; 因为把数组的元素都初始化为0，从小到大遍历的话，会把已经装进背包的元素再装一遍</li>
<li>反向遍历因为dp数</li>
<li>组里面都是空的，所以涉及到dp的位置都是0，只有物品的价值是非零值</li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 背包空间剩余j, 能够携带研究材料的最大价值为dp[j]</span></span><br><span class="line">    <span class="comment">// 装i物品dp[j] = dp[j - weight[i]] + values[i]</span></span><br><span class="line">    <span class="comment">// 不装i物品dp[j] = dp[j]</span></span><br><span class="line">    <span class="comment">// 取最大值dp[j] = max(dp[j], dp[j - weight[i]] + values[i])</span></span><br><span class="line">    <span class="comment">// 初始化: dp[0] = 0;可以不写 </span></span><br><span class="line">    <span class="comment">// 遍历顺序j从大到小, i从小到大</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">values</span><span class="params">(m, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">weight</span><span class="params">(m, <span class="number">0</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 收集数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; weight[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">        cin &gt;&gt; values[j];</span><br><span class="line">    &#125;   </span><br><span class="line">            </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= weight[i]; --j) &#123;</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + values[i]);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;j=%d, dp[j]=%d&quot;</span>, j, dp[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"> </span><br><span class="line">    cout &lt;&lt; dp[n] &lt;&lt; endl;   <span class="comment">//最后返回dp[n]，代表剩余容量为n时能装下最大物品价值为dp[n] </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-equal-subset-sum/">分割等和子集</a></h4><ol>
<li>思路：01背包的应用，背包剩余空间是还需要的大小，背包所装物品的价值是已有的大小；最后的结果要返回：当背包剩余空间为target的时候，能否正好装下价值为target的物品</li>
<li>要注意dp数组的初始化，dp[target]是包括在里面的，初始化的时候要用vector<int> dp(target+1, 0)</li>
<li>背包容量逆序遍历（如果顺序遍历就会根据本轮的状态进行迭代，逆序遍历是根据上一轮的状态进行迭代），但每换一次物品都会更新一次背包容量为target的情况，这里取最大值</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 目标为j的数组已有的元素之和为dp[j]</span></span><br><span class="line">        <span class="comment">// 2. 加入当前元素: dp[j] = dp[j - nums[i]] + nums[i]</span></span><br><span class="line">        <span class="comment">// 2. 不加入当前元素: dp[j] = dp[j];</span></span><br><span class="line">        <span class="comment">// 2. 取最大值, 接近目标 -&gt; dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);</span></span><br><span class="line">        <span class="comment">// 3. 初始化: dp[0] = 0;</span></span><br><span class="line">        <span class="comment">// 4. nums数组中的元素顺序遍历, j逆序遍历 -&gt; 元素不能重复放入, 而且需要离目标越来越近</span></span><br><span class="line">        <span class="comment">// 5. 达成target这个目标的时候, 元素之和dp[j]正好为target -&gt; dp[target] == target;</span></span><br><span class="line">        <span class="comment">// 5. 物品价值和占用空间是一样的</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = target; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= nums[i]) &#123;</span><br><span class="line">                    dp[j] = <span class="built_in">max</span>(dp[j], dp[j - nums[i]] + nums[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[target] == target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="最后一块石头的重量Ⅱ"><a href="#最后一块石头的重量Ⅱ" class="headerlink" title="最后一块石头的重量Ⅱ"></a>最后一块石头的重量Ⅱ</h4><ol>
<li>思路：类似于416等和分割子集，区别在于最后要返回的是两个子集的差值；要注意动规计算的是已有子集dp[target]，剩余另一个子集是sum - dp[target]</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lastStoneWeightII</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 目标石块的重量为j的时候, 已有石块重量为dp[j]</span></span><br><span class="line">        <span class="comment">// 2. 加入当前石块 -&gt; dp[j] = dp[j - stones[i]] + stones[i];</span></span><br><span class="line">        <span class="comment">// 2. 不加入当前石块 -&gt; dp[j] = dp[j];</span></span><br><span class="line">        <span class="comment">// 3. 初始化 dp[0] = 0;</span></span><br><span class="line">        <span class="comment">// 4. 石块重量顺序遍历, 目标石块重量逆序遍历 -&gt; 因为不能重复加入</span></span><br><span class="line">        <span class="comment">// 5. 目标石块的重量应该是总重量的一半, 才会让石头返回最小重量</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> sum = <span class="built_in">accumulate</span>(stones.<span class="built_in">begin</span>(), stones.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> target = sum / <span class="number">2</span>; <span class="comment">//一定是小的那堆</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; stones.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = target; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= stones[i]) &#123;</span><br><span class="line">                    dp[j] = <span class="built_in">max</span>(dp[j], dp[j - stones[i]] + stones[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (sum - dp[target]) - dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="目标和"><a href="#目标和" class="headerlink" title="目标和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/target-sum/">目标和</a></h4><ol>
<li>思路：分为left和right两个部分，left-right&#x3D;target, left+right&#x3D;sum，所以left&#x3D;(sum+target)&#x2F;2，最后需要找到子集总和为left的组合数</li>
<li>要注意如果(target+sum)%2 &#x3D;&#x3D; 1说明这两个子集分不出来；另外dp[0]&#x3D;1的含义是，要填满剩余空间为0的背包，组合数有1种，那就是什么也不放</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 让最终目标和为j的方法一共有dp[j]种</span></span><br><span class="line">        <span class="comment">// 2. 加入当前元素 dp[j] = dp[j] + dp[j - nums[i]];(dp[i][j] = dp[i - 1][j - nums[i]])</span></span><br><span class="line">        <span class="comment">// 2. 不加入当前元素 dp[j] = dp[j]; (dp[i][j] = dp[i - 1][j])</span></span><br><span class="line">        <span class="comment">// 2. 取最大值 -&gt; 接近目标 -&gt; dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);</span></span><br><span class="line">        <span class="comment">// 3. 初始化 dp[0] = 0 -&gt; 不用动</span></span><br><span class="line">        <span class="comment">// 4. nums元素顺序遍历, target逆序遍历 -&gt; 因为要越来越接近目标, 且放入的元素不能重新放入</span></span><br><span class="line">        <span class="comment">// 5. ↓</span></span><br><span class="line">        <span class="comment">// 将数组分成left和right(2份), left + right = sum</span></span><br><span class="line">        <span class="comment">// left - right = target</span></span><br><span class="line">        <span class="comment">// left = (target + sum) / 2;</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> ((target + sum) % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//left-right不能等于target</span></span><br><span class="line">        <span class="keyword">if</span> (sum &lt; <span class="built_in">abs</span>(target)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = (target + sum) / <span class="number">2</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(left + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = left; j &gt;= nums[i]; --j) &#123;</span><br><span class="line">                <span class="comment">// if (j &gt;= nums[i] ) &#123;</span></span><br><span class="line">                    dp[j] += dp[j - nums[i]];   </span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="一和零"><a href="#一和零" class="headerlink" title="一和零"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ones-and-zeroes/">一和零</a></h4><ol>
<li>思路：01背包问题的应用，剩余背包容量为i和j时，能够装下最大物品价值为dp[i][j]</li>
<li>这里背包容量有2个维度，一个是0一个是1；</li>
<li>根据上一轮小容量的背包数量来推，如果增加了zeroNum和oneNum，能装下的子集长度发生了什么样的变化；也就是所基于上一轮背包存储情况推出当前轮的背包存储情况</li>
<li>物品和背包的遍历顺序一定是背包在内层，只有背包在内层才能够在遍历每个物品的时候把dp数组全部元素都更新一次；</li>
<li>如果背包在外层，那么遍历完全部也才更新一次dp数组，里面的元素是背包容量为j的时候能装下最大的一件物品的价值；因为他不根据其他背包容量来更新（表面上看是有，但是实际上它参考的值全都是0，所以本质上并没有参考其他背包容量的值）</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMaxForm</span><span class="params">(vector&lt;string&gt;&amp; strs, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. strs子集中还需要i个0和j个1时, 其最大长度为dp[i][j]</span></span><br><span class="line">        <span class="comment">// 2. 将元素加入到当前子集 dp[i][j] = dp[i - zeroNum][j - oneNum] + 1; -&gt; 需求减少, 长度+1</span></span><br><span class="line">        <span class="comment">// 2. 不加入当前元素: dp[i][j] = dp[i][j] -&gt; 需求不变, 长度不变</span></span><br><span class="line">        <span class="comment">// 2. 取最大值dp[i][j] = max(dp[i - zeroNum][j - oneNum] + 1, dp[i][j]);</span></span><br><span class="line">        <span class="comment">// 3. dp[0][0] = 0;</span></span><br><span class="line">        <span class="comment">// 4. 需求是越来越少的 -&gt; 逆序遍历</span></span><br><span class="line">        <span class="comment">// 5. 注意dp数组的索引范围</span></span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> string&amp; str : strs) &#123;    <span class="comment">//物品</span></span><br><span class="line">            <span class="type">int</span> zeroNum = <span class="number">0</span>, oneNum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="type">char</span>&amp; ch : str) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ch == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                    ++zeroNum;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ++oneNum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;zeroNum = &quot; &lt;&lt; zeroNum &lt;&lt; &quot;; oneNum = &quot; &lt;&lt; oneNum &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = m; i &gt;= <span class="number">0</span>; --i) &#123;  <span class="comment">//背包</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i &gt;= zeroNum &amp;&amp; j &gt;= oneNum) &#123;</span><br><span class="line">                        dp[i][j] = <span class="built_in">max</span>(dp[i - zeroNum][j - oneNum] + <span class="number">1</span>, dp[i][j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1052">完全背包</a></h4><ol>
<li>思路：完全背包就是在01背包的基础上可以重复放入物品；所以更新dp数组的时候可以基于本轮背包装过的物品来进行更新</li>
<li>本轮装过的物品可以再装，所以背包的容量是顺序遍历的</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 背包空间剩余j时, 装下的最大物品价值为dp[j]</span></span><br><span class="line">    <span class="comment">// 2. 装下当前物品, 则空间减少, 价值增加 -&gt; dp[j] = dp[j - weights[i]] + values[i]</span></span><br><span class="line">    <span class="comment">// 2. 不装当前物品, 则空间和价值都不变 -&gt; dp[j] = dp[j] </span></span><br><span class="line">    <span class="comment">// 3. 暂不初始化</span></span><br><span class="line">    <span class="comment">// 4. 材料顺序遍历, 材料可以重复取用 -&gt; 顺序遍历</span></span><br><span class="line">    <span class="comment">// 5. -</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m, bagWeight;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; bagWeight;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">weights</span><span class="params">(m, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">values</span><span class="params">(m, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; weights[i] &gt;&gt; values[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(bagWeight + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; weights.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = weights[i]; j &lt;= bagWeight; ++j) &#123;</span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j - weights[i]] + values[i], dp[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; dp[bagWeight] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="零钱兑换Ⅱ"><a href="#零钱兑换Ⅱ" class="headerlink" title="零钱兑换Ⅱ"></a>零钱兑换Ⅱ</h4><ol>
<li>思路：完全背包问题（物品可以重复放入），另外要注意力扣示例中有两个元素相加超过int的情况，所以这里元素定义为uint32_t，或者加if判断也行</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">change</span><span class="params">(<span class="type">int</span> amount, vector&lt;<span class="type">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 目标金额为j时, 已有的硬币组合数为dp[j]</span></span><br><span class="line">        <span class="comment">// 2. 加入当前硬币 dp[j] = dp[j - coins[i]]</span></span><br><span class="line">        <span class="comment">// 2. 不加入当前硬币 dp[j] = dp[j] -&gt; dp[j] = dp[j - coins[i]] + dp[j]</span></span><br><span class="line">        <span class="comment">// 2. dp[j] += dp[j - coins[i]]</span></span><br><span class="line">        <span class="comment">// 3. 初始化dp[0] = 1;</span></span><br><span class="line">        <span class="comment">// 4. 硬币顺序遍历, 背包顺序遍历 -&gt; 因为可以重复放入</span></span><br><span class="line">        <span class="comment">// 5. -</span></span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">uint32_t</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; coins.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = coins[i]; j &lt;= amount; ++j) &#123;</span><br><span class="line">                dp[j] += dp[j - coins[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="组合总和Ⅳ"><a href="#组合总和Ⅳ" class="headerlink" title="组合总和Ⅳ"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-iv/">组合总和Ⅳ</a></h4><ol>
<li>思路：完全背包问题，求排列数就是在内层遍历物品(为什么？不理解)</li>
<li>暂时这样理解：每次都遍历全部物品，那么在物品不同的时候就算作不同情况</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">combinationSum4</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 目标总数为j时, 所包含的元素组合个数为dp[j]</span></span><br><span class="line">        <span class="comment">// 2. 加入当前元素 -&gt; dp[j] = dp[j - nums[i]]</span></span><br><span class="line">        <span class="comment">// 2. 不加入当前元素 -&gt; dp[j] = dp[j]</span></span><br><span class="line">        <span class="comment">// 2. 此时目标为j所包含的元素组合个数为dp[j] = dp[j] + dp[j - nums[i]] -&gt; dp[j] += dp[j - nums[i]];</span></span><br><span class="line">        <span class="comment">// 3. 初始化: dp[0] = 1;</span></span><br><span class="line">        <span class="comment">// 4. 背包顺序遍历 -&gt; 元素可以重复放入; 物品放入的顺序不同, 算作不同的组合 -&gt; 物品要放在内层进行遍历</span></span><br><span class="line">        <span class="comment">// 5. -</span></span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">uint32_t</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= target; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= nums[i]) &#123;</span><br><span class="line">                    dp[j] += dp[j - nums[i]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="爬楼梯进阶版"><a href="#爬楼梯进阶版" class="headerlink" title="爬楼梯进阶版"></a><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1067">爬楼梯进阶版</a></h4><ol>
<li>思路：完全背包问题，且要求排列数，所以物品在内层循环</li>
<li>因为放过的元素还可以再放，所以属于完全背包问题；爬123和爬132是两种不同的方法，所以物品要在内层遍历</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 距离楼顶剩余j时, 爬到楼顶的方法有dp[j]种</span></span><br><span class="line">    <span class="comment">// 2. 爬1-m阶 -&gt; 物品是1-m可以让我选</span></span><br><span class="line">    <span class="comment">// 2. 爬i阶 -&gt; dp[j] = dp[j - i];</span></span><br><span class="line">    <span class="comment">// 2. 不爬, 其实也就是累计之前的状态 -&gt; dp[j] = dp[j] -&gt; dp[j] += dp[j - i];</span></span><br><span class="line">    <span class="comment">// 3. dp[1] = 1; -&gt; ***dp[0] = 1才对***</span></span><br><span class="line">    <span class="comment">// 4. 爬过了还可以再爬 -&gt; 物品可以重复放入 -&gt; 背包空间顺序遍历</span></span><br><span class="line">    <span class="comment">// 4. 爬23和爬32是两种不同的爬法 -&gt; 物品放入的顺序是有区分的 -&gt; 物品在内层</span></span><br><span class="line">    <span class="comment">// 5. 如果是dp[1] = 1, dp[0] = 0的话,每次都会少加一个dp[0] = 1</span></span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= i) &#123;</span><br><span class="line">                dp[j] += dp[j - i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; dp[n] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change/">零钱兑换</a></h4><ol>
<li>思路：完全背包问题，已经放入的物品还可以重新放入；取组合数的最小值</li>
<li>将初始值初始为有效值范围外的数值，就不会影响到有效数据的更新，但是要根据题目来具体定</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 要凑成j元, 所需要最少的硬币数量为dp[j]</span></span><br><span class="line">        <span class="comment">// 2. 放入当前硬币 -&gt; dp[j] = dp[j - coins[i]] + 1;</span></span><br><span class="line">        <span class="comment">// 2. 不放入当前硬币 -&gt; dp[j] = dp[j]</span></span><br><span class="line">        <span class="comment">// 2. 取最小值 dp[j] = min(dp[j], dp[j - coins[i]] + 1);</span></span><br><span class="line">        <span class="comment">// 3. 初始化: dp[0] = 0;</span></span><br><span class="line">        <span class="comment">// 4. 硬币可以重复放入 -&gt; 背包顺序遍历; 硬币放入的顺序不重要 -&gt; 硬币在外层</span></span><br><span class="line">        <span class="comment">// 5. 如果dp[j - coins[i]]是初始值要跳过? 为什么? 说明没有这种情况</span></span><br><span class="line">        <span class="keyword">if</span> (amount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; coins.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = coins[i]; j &lt;= amount; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[j - coins[i]] != INT_MAX) &#123;<span class="comment">//***</span></span><br><span class="line">                    dp[j] = <span class="built_in">min</span>(dp[j], dp[j - coins[i]] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for (const int&amp; v: dp) &#123;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; v &lt;&lt; &quot; &quot;;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (dp[amount] == INT_MAX) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/perfect-squares/">完全平方数</a></h4><ol>
<li>思路：物品是i*i, 背包剩余空间是n；因为物品可以重复放入，所以是完全背包问题</li>
<li>这里要对0进行初始化，因为0没有完全平方数</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSquares</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 和为j的完全平方数最少数量为dp[j]</span></span><br><span class="line">        <span class="comment">// 2. 加入 -&gt; dp[j] = dp[j - i*i] + 1;</span></span><br><span class="line">        <span class="comment">// 2. 不加入 -&gt; dp[j] = dp[j]</span></span><br><span class="line">        <span class="comment">// 2. 要求最小数量, 取最小值 -&gt; dp[j] = min(dp[j], dp[j - i*i] + 1);</span></span><br><span class="line">        <span class="comment">// 3. vector&lt;int&gt; dp(n + 1, INT_MAX); dp[0] = 0; dp[1] = 1;</span></span><br><span class="line">        <span class="comment">// 4. 平方数可以重复 -&gt; 顺序遍历, 平方数加入的顺序不重要 -&gt; 物品在外层</span></span><br><span class="line">        <span class="comment">// 5. 这里不用if是因为从1*1开始, 已经把dp[i]每个元素都变成了有效值, 然后再慢慢减少数量</span></span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i*i; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="comment">// if (dp[j - i*i] != INT_MAX) &#123;</span></span><br><span class="line">                    dp[j] = <span class="built_in">min</span>(dp[j], dp[j - i*i] + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">                cout &lt;&lt; dp[j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dp[n] == INT_MAX) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="单词拆分"><a href="#单词拆分" class="headerlink" title="单词拆分"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-break/">单词拆分</a></h4><ol>
<li>思路：单词可以重复放入-&gt;完全背包问题；单词放入的顺序影响判断结果-&gt;背包问题中的排列问题</li>
<li>截取字符串的方法是s.substr(pos, n); pos是位置，n是长度；如果pos超过了s.size()会返回out_of_range，如果pos+n超过了s.size()，只会到末尾</li>
<li>截取字符串内层循环第一个是最长的，然后逐个去掉第一个字母进行匹配</li>
<li>dp数组的含义是j之前能够装下的情况是dp[j]，所以既要判断之前的i可以（dp[i]&#x3D;&#x3D;true）又要判断j-i可以（wordSet.find(word) !&#x3D; wordSet.end()）</li>
<li>这里转成unordered_set是为了调用关联容器的find方法</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 物品是wordDict, 背包是s</span></span><br><span class="line">        <span class="comment">// 1. 能够装下j个字符前的情况为dp[j]</span></span><br><span class="line">        <span class="comment">// 2. 出现在字典里 -&gt; dp[j] = true;</span></span><br><span class="line">        <span class="comment">// 2. 没有出现在字典里 -&gt; dp[j] = false;</span></span><br><span class="line">        <span class="comment">// 3. 初始化 都为false, 然后空字符是可以的</span></span><br><span class="line">        <span class="comment">// 4. 先遍历背包后遍历物品 -&gt; 物品的顺序是固定好的 -&gt; 物品要在内层</span></span><br><span class="line">        <span class="comment">// 5. -</span></span><br><span class="line">        <span class="function">unordered_set&lt;string&gt; <span class="title">wordSet</span><span class="params">(wordDict.begin(), wordDict.end())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(s.size() + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= s.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; j; ++i) &#123;</span><br><span class="line">                string word = s.<span class="built_in">substr</span>(i, j - i);</span><br><span class="line">                <span class="comment">// cout &lt;&lt; word &lt;&lt; &quot; &quot;;</span></span><br><span class="line">                <span class="keyword">if</span> (wordSet.<span class="built_in">find</span>(word) != wordSet.<span class="built_in">end</span>() &amp;&amp; dp[i]) &#123;</span><br><span class="line">                    dp[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[s.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1066">多重背包</a></h4><ol>
<li>思路：多重背包就是在01背包的基础上多了个数，所以我们要多遍历一个数量的数组</li>
<li>要注意的是，背包所能装下最大价值，是可以针对每个物品从0-&gt;nums[i]进行选择的，而不是每个都选最大值，具体可以看k的定义</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> bagWeight, n;</span><br><span class="line">    cin &gt;&gt; bagWeight &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">weights</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">values</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) cin &gt;&gt; weights[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) cin &gt;&gt; values[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) cin &gt;&gt; nums[i];</span><br><span class="line">    <span class="comment">// 1. 剩余容量为j, 当前遍历到的矿石数量剩余k时, 能够装下的最大矿石的价值为dp[j];</span></span><br><span class="line">    <span class="comment">// 2. 装下-&gt; if (j &gt;= weight[i] &amp;&amp; k &gt; 0) dp[j] = dp[j - weight[i]] + k * values[i];</span></span><br><span class="line">    <span class="comment">// 2. 不装 dp[j] = dp[j]</span></span><br><span class="line">    <span class="comment">// 2. 取最大值 dp[j] = max(dp[j], dp[j - weight[i]] + k * values[i]);</span></span><br><span class="line">    <span class="comment">// 3. 初始化:</span></span><br><span class="line">    <span class="comment">// 4. 物品放入的顺序不重要 -&gt; 物品在外层; 物品不能重复放入 -&gt; 背包容量倒序遍历</span></span><br><span class="line">    <span class="comment">// 5. -</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(bagWeight + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = bagWeight; j &gt;= weights[i]; --j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = nums[i]; k &gt; <span class="number">0</span>; --k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= k * weights[i])</span><br><span class="line">                    dp[j] = <span class="built_in">max</span>(dp[j], dp[j - k * weights[i]] + k * values[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; dp[bagWeight] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="打家劫舍问题"><a href="#打家劫舍问题" class="headerlink" title="打家劫舍问题"></a>打家劫舍问题</h3><h4 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber/">打家劫舍</a></h4><ol>
<li>思路：偷到j家能获取的最大金额数为dp[j]; 偷当前家那么上上家一定要偷dp[j] &#x3D; dp[j -2] + nums[j], 不偷当前家那么继承上一个状态dp[j - 1]，然后取最大值</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 偷到j家能获得的最大金额数为dp[j]</span></span><br><span class="line">        <span class="comment">// 2. 如果偷这一家 -&gt; dp[j] = dp[j - 2] + nums[j]; 上上家一定要偷不然就错过了</span></span><br><span class="line">        <span class="comment">// 2. 如果不偷这一家 -&gt; 偷上一家 -&gt; dp[j] = dp[j - 1]</span></span><br><span class="line">        <span class="comment">// 2. 求最大值: dp[j] = max(dp[j - 2] + nums[j], dp[j - 1]); 一个变量就够了</span></span><br><span class="line">        <span class="comment">// 3. 初始化: dp[0] = nums[0]; dp[1] = max(nums[0], nums[1]);</span></span><br><span class="line">        <span class="comment">// 4. 遍历顺序:j是从前往后推算的, 所以只能是从前往后遍历</span></span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j &lt; nums.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j - <span class="number">2</span>] + nums[j], dp[j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="打家劫舍Ⅱ"><a href="#打家劫舍Ⅱ" class="headerlink" title="打家劫舍Ⅱ"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber-ii/">打家劫舍Ⅱ</a></h4><ol>
<li>思路：在打家劫舍的基础上，只能选择偷第一家或者偷最后一家</li>
<li>构造一个函数，分别查找偷第一家的情况和偷最后一家的情况，然后取最大值</li>
<li>为什么不能使用循环数组？因为会遍历2次</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">robRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == end) <span class="keyword">return</span> nums[end];</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(end + <span class="number">1</span>, <span class="number">0</span>)</span></span>; <span class="comment">//end是索引</span></span><br><span class="line">        dp[start] = nums[start];    <span class="comment">//这里把0 -&gt; start应对不同起始索引的情况</span></span><br><span class="line">        dp[start + <span class="number">1</span>] = <span class="built_in">max</span>(nums[start], nums[start + <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = start + <span class="number">2</span>; j &lt;= end; ++j) &#123;    <span class="comment">//这里end是索引, 索引可以取等号</span></span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j - <span class="number">2</span>] + nums[j], dp[j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[end];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> result1 = <span class="built_in">robRange</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">2</span>);        <span class="comment">//其实就是把环分成了2种不同情况 -&gt; 取最大值</span></span><br><span class="line">        <span class="type">int</span> result2 = <span class="built_in">robRange</span>(nums, <span class="number">1</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(result1, result2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="打家劫舍Ⅲ"><a href="#打家劫舍Ⅲ" class="headerlink" title="打家劫舍Ⅲ"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber-iii/">打家劫舍Ⅲ</a></h4><ol>
<li>思路：因为要根据孩子节点的情况来判断当前节点偷不偷，所以先判断孩子节点再判断当前节点，选用后序遍历；利用递归的调用栈来保存每个节点偷与不偷的两种状态；</li>
<li>如果偷当前节点，那么两个孩子节点都不能偷；如果不偷当前节点，那么两个孩子节点各自判断偷与不偷的最大值，注意：两个是不干扰的</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 1. dp[i][0] -&gt; 不偷当前结点, 能够盗取的最高金额; dp[i][1] -&gt; 偷当前结点能够盗取的最高金额</span></span><br><span class="line">    <span class="comment">// 2. 递推公式: val1 = cur-&gt;val + dp[left][0] + dp[right][0]; 偷了当前节点, 孩子节点就不能偷</span></span><br><span class="line">    <span class="comment">// 2. val2 = max(dp[left][0], dp[left][1]) + max(dp[right][0], dp[right][1]); 偷孩子节点的最大值</span></span><br><span class="line">    <span class="comment">// 3. 初始化: 空节点偷不偷都是0; val1 = 0, val2 = 0;</span></span><br><span class="line">        <span class="comment">// 4. 因为要根据是否偷孩子节点来判断当前节点要不要偷 -&gt; 只能采用后序遍历, 利用递归函数的返回值来做下一步计算</span></span><br><span class="line">        <span class="comment">// 5. 虽然只用了一个二维数组, 但是每一层递归都会有一个二维数组来记录节点的状态 -&gt; 保存在系统栈内</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">robTree</span><span class="params">(TreeNode* cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>) <span class="keyword">return</span> &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// vector&lt;int&gt; dp(2, 0);</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; left = <span class="built_in">robTree</span>(cur-&gt;left);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; right = <span class="built_in">robTree</span>(cur-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> val1 = cur-&gt;val + left[<span class="number">0</span>] + right[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> val2 = <span class="built_in">max</span>(left[<span class="number">0</span>], left[<span class="number">1</span>]) + <span class="built_in">max</span>(right[<span class="number">0</span>], right[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;val2, val1&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result = <span class="built_in">robTree</span>(root);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(result[<span class="number">0</span>], result[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="股票问题"><a href="#股票问题" class="headerlink" title="股票问题"></a>股票问题</h3><h4 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/">买卖股票的最佳时机</a></h4><ol>
<li>思路（动规）：dp数组描述持有和不持有的两种状态；持有有当前持有和昨天持有两种情况，不持有有当前卖出和昨天不持有两种情况；注意这里买入直接-prices[i]就可以，因为只有一次买入的机会</li>
<li>思路（贪心）：顺序遍历，统计最小值，统计与最小值的差值result，最后返回result的最大值</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 在第i天不持有股票最多能拿dp[i][0]; 第i天持有股票最多能拿dp[i][1]</span></span><br><span class="line">        <span class="comment">// 2. dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);前一天不持有, 和今天刚卖出取最大值</span></span><br><span class="line">        <span class="comment">// 2. dp[i][1] = max(dp[i - 1][1], -prices[i]);  前一天持有, 和今天刚买入取最大值</span></span><br><span class="line">        <span class="comment">// 3. 初始化 dp[0][0] = 0; dp[0][1] = -prices[0]; 其余值全为0</span></span><br><span class="line">        <span class="comment">// 4. 遍历顺序: 因为要用前一天推后一天 -&gt; 顺序遍历</span></span><br><span class="line">        <span class="comment">// 5. 不持有一定比持有剩下的现金更多, 因为最终是看现金数量的</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> len = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(len, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], -prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 贪心解法</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> low = INT_MAX;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            low = <span class="built_in">min</span>(low, prices[i]);  <span class="comment">// 取最左最小价格</span></span><br><span class="line">            result = <span class="built_in">max</span>(result, prices[i] - low); <span class="comment">// 直接取最大区间利润</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="买卖股票的最佳时机Ⅱ-可以多次买卖"><a href="#买卖股票的最佳时机Ⅱ-可以多次买卖" class="headerlink" title="买卖股票的最佳时机Ⅱ - 可以多次买卖"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/">买卖股票的最佳时机Ⅱ - 可以多次买卖</a></h4><ol>
<li>思路：对比买卖股票的最佳时机，就是不持有的状态下，有保持昨天不持有的状态和当天卖出这两种情况，差异在于，当天卖出要根据上一次持有的状态推出</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法一: 动态规划</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 第i天不持有最多能获得收益dp[i][0]; 第i天持有最多能获得收益dp[i][1]</span></span><br><span class="line">        <span class="comment">// 2. 第i天不持有: dp[i][0] = max(dp[i - 1][0] , dp[i - 1][1] + prices[i]);</span></span><br><span class="line">        <span class="comment">// 2. 第i天持有： dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);</span></span><br><span class="line">        <span class="comment">// 3. dp[0][0] = 0; dp[0][1] = -prices[0];</span></span><br><span class="line">        <span class="comment">// 4. 前一天推出后一天的状态 -&gt; 只能是正序遍历</span></span><br><span class="line">        <span class="comment">// 5. </span></span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>; </span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>] , dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法二: 贪心</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            result += <span class="built_in">max</span>(<span class="number">0</span>, prices[i] - prices[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="买卖股票的最佳时机Ⅲ-可以买卖2次"><a href="#买卖股票的最佳时机Ⅲ-可以买卖2次" class="headerlink" title="买卖股票的最佳时机Ⅲ - 可以买卖2次"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/">买卖股票的最佳时机Ⅲ - 可以买卖2次</a></h4><ol>
<li>思路：将买卖股票的状态分为不持有、第一次买入、第一次卖出、第二次买入、第二次卖出5种状态；因为第二次卖出的利润包含了2次操作带来是收益，所以一定是第二次卖出的状态钱最多</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 第i天不持有dp[i][0]; 第i天买入dp[i][1]; 第i天卖出dp[i][2]</span></span><br><span class="line">        <span class="comment">// 1. 第i天第二次买入dp[i][3]; 第i天第二次卖出dp[i][4];</span></span><br><span class="line">        <span class="comment">// 2. dp[i][0] = dp[i - 1][0]; </span></span><br><span class="line">        <span class="comment">// 2. dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);</span></span><br><span class="line">        <span class="comment">// 2. dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i]);</span></span><br><span class="line">        <span class="comment">// 2. dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]);</span></span><br><span class="line">        <span class="comment">// 2. dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]);</span></span><br><span class="line">        <span class="comment">// 3. dp[0][0] = 0; dp[0][1] = -prices[0]; dp[0][2] = 0; dp[0][3] = -prices[0]; dp[0][4] = 0;</span></span><br><span class="line">        <span class="comment">// 4. 前一天的状态推出后一天的状态 -&gt; 只能是正序遍历</span></span><br><span class="line">        <span class="comment">// 5. -</span></span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">5</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">3</span>] = -prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">2</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">2</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">3</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">3</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">4</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">4</span>], dp[i - <span class="number">1</span>][<span class="number">3</span>] + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">4</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="买卖股票的最佳时机IV"><a href="#买卖股票的最佳时机IV" class="headerlink" title="买卖股票的最佳时机IV"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">买卖股票的最佳时机IV</a></h4><ol>
<li>思路：买卖股票的最佳时机Ⅲ的抽象化，买入（以及买入后）的状态记为奇数，卖出（以及卖出后）的状态记为偶数，不持有记为0，将Ⅲ的代码写成循环即可</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 第i天, 不持有股票最大利润为dp[i][0]; 第一次买入股票最大利润为dp[i][1]</span></span><br><span class="line">        <span class="comment">// 1. 第一次卖出股票最大利润为dp[i][2]; 以此类推,</span></span><br><span class="line">        <span class="comment">// 1. 第k次买入股票的最大利润为dp[i][2*k - 1], 第k次卖出股票的最大利润为dp[i][2*k]</span></span><br><span class="line">        <span class="comment">// 2. 第i天不持有(单独一个状态, 因卖出而不持有的状态是dp[i][2*k]) -&gt; dp[i][0] = dp[i - 1][0]; </span></span><br><span class="line">        <span class="comment">// 2. dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]); -&gt; 可推出(直接从1开始遍历)</span></span><br><span class="line">        <span class="comment">// 2. 第k次买入:dp[i][2 * k - 1] = max(dp[i - 1][2 * k - 1], dp[i - 1][2 * k - 2] - prices[i]);</span></span><br><span class="line">        <span class="comment">// 2. 第k次卖出:dp[i][2 * k] = max(dp[i - 1][2 * k], dp[i - 1][2 * k - 1] + prices[i]);</span></span><br><span class="line">        <span class="comment">// 3. 初始化: dp[i][2 * k - 1] = -prices[i];</span></span><br><span class="line">        <span class="comment">// 4. 由前一天的状态推出后一天的状态 -&gt; 顺序遍历</span></span><br><span class="line">        <span class="comment">// 5. -</span></span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>*k + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">2</span>*k + <span class="number">1</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = -prices[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= k; ++j) &#123;</span><br><span class="line">                dp[i][<span class="number">2</span> * j - <span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">2</span> * j - <span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span> * j - <span class="number">2</span>] - prices[i]);</span><br><span class="line">                dp[i][<span class="number">2</span> * j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">2</span> * j], dp[i - <span class="number">1</span>][<span class="number">2</span> * j - <span class="number">1</span>] + prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">2</span> * k];        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="最佳买卖股票时机含冷冻期"><a href="#最佳买卖股票时机含冷冻期" class="headerlink" title="最佳买卖股票时机含冷冻期"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">最佳买卖股票时机含冷冻期</a></h4><ol>
<li>思路：分为不持有、买入、卖出、冷冻期4种状态，返回的结果中一定是股票卖出以后收益是最大的；股票卖出的状态分为卖出和冷冻期两种，所以最后的结果要取最大值</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 第i天: 不持有股票的状态dp[i][0]; 买入股票的状态dp[i][1]; 当天卖出股票的状态dp[i][2]</span></span><br><span class="line">        <span class="comment">// 1. 卖出股票后的冷冻期dp[i][3];</span></span><br><span class="line">        <span class="comment">// 2. 一直不持有或者说前一天是冷冻期:dp[i][0] = max(dp[i - 1][0], dp[i - 1][3]); </span></span><br><span class="line">        <span class="comment">// 2. dp[i][1] = max(dp[i - 1][1], max(dp[i - 1][0] - prices[i], dp[i - 1][3] - prices[i]));</span></span><br><span class="line">        <span class="comment">// 2. dp[i][2] = dp[i - 1][1] + prices[i];</span></span><br><span class="line">        <span class="comment">// 2. dp[i][3] = dp[i - 1][2];</span></span><br><span class="line">        <span class="comment">// 3. dp[0][0] = 0; dp[0][1] = -prices[0]; dp[0][2] = 0; dp[0][3] = 0;</span></span><br><span class="line">        <span class="comment">// 4. 前一天的状态推出后一天的状态 -&gt; 顺序遍历</span></span><br><span class="line">        <span class="comment">// 5. -</span></span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">4</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">3</span>]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i], dp[i - <span class="number">1</span>][<span class="number">3</span>] - prices[i]));</span><br><span class="line">            dp[i][<span class="number">2</span>] = dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i];</span><br><span class="line">            dp[i][<span class="number">3</span>] = dp[i - <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">0</span>], <span class="built_in">max</span>(dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">2</span>], dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">3</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="买卖股票的最佳时机含手续费"><a href="#买卖股票的最佳时机含手续费" class="headerlink" title="买卖股票的最佳时机含手续费"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">买卖股票的最佳时机含手续费</a></h4><ol>
<li>思路：将状态规划为不持有0和持有1两种状态，只是在买卖股票的最佳时机Ⅱ的基础上多了手续费</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices, <span class="type">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 第i天不持有股票的状态是dp[i][0]; 持有股票的状态是dp[i][1];</span></span><br><span class="line">        <span class="comment">// 2. dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i] - fee);</span></span><br><span class="line">        <span class="comment">// 2. dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);</span></span><br><span class="line">        <span class="comment">// 3. dp[0][1] = -prices[0];</span></span><br><span class="line">        <span class="comment">// 4. 因为要根据前一天推出后一天的状态 -&gt; 顺序遍历</span></span><br><span class="line">        <span class="comment">// 5. 因为要求获得利润的最大值, 如果在第一天买入又卖出, 最大利润直接-2 -&gt; 没有意义</span></span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i] - fee);</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="编辑距离问题"><a href="#编辑距离问题" class="headerlink" title="编辑距离问题"></a>编辑距离问题</h3><h4 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-increasing-subsequence/description/">最长递增子序列</a></h4><ol>
<li>思路：结尾为第i位元素之前（包括第i位），最长严格递增子序列的长度为dp[i]；在每次统计dp[i]的时候都要对比i前面每一个元素j，才能确定dp[i]的值</li>
<li>最终的结果需要定义一个result取最大值，因为最长递增子串不一定以最后一位元素为结尾</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 第i位之前, 最长严格递增子序列的长度为dp[i]</span></span><br><span class="line">        <span class="comment">// 2. 在满足nums[j] &lt; nums[i]的条件下, 有如下递推公式</span></span><br><span class="line">        <span class="comment">// 2. dp[i] = max(dp[i], dp[j] + 1); 这里j是指代i前一位数的最长子序列</span></span><br><span class="line">        <span class="comment">// 3. 初始化: dp[i]都为1 -&gt; 最长严格递增子序列的长度不可能比1还小</span></span><br><span class="line">        <span class="comment">// 4. 顺序遍历 -&gt; 因为后一位要比前一位更大</span></span><br><span class="line">        <span class="comment">// 5. 这里的result是取最大值, 不是最后一位;</span></span><br><span class="line">        <span class="comment">// 5. 可以在每次取得dp数组后更新最大值result的数值 -&gt; 保存最大值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[i])</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result = <span class="built_in">max</span>(result, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="最长连续递增子序列"><a href="#最长连续递增子序列" class="headerlink" title="最长连续递增子序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/">最长连续递增子序列</a></h4><ol>
<li>思路：如果递增则继承上一个状态的dp，并自增1；如果不递增就使用默认值；因为是连续的所以不用再定义j去判断子序列里面各元素</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            result = <span class="built_in">max</span>(result, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="最长重复子序列"><a href="#最长重复子序列" class="headerlink" title="最长重复子序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/">最长重复子序列</a></h4><ol>
<li>思路：难点在于dp数组的定义，以i-1为结尾的nums1子数组和以j-1为结尾的num2子数组最长重复子序列长度为dp[i][j]</li>
<li>为什么要以i-1为结尾以j-1为结尾，因为如果直接定义i，j为结尾，那么需要单独讨论两边第0位元素与另一数组元素的相同情况，需要多2个for循环</li>
<li>这里如果元素不相同不用继承上一个状态，直接写0就可以，因为dp数组讨论的是以当前元素为结尾的子串；如果元素相同dp[i][j]就在上一个状态的基础上+1</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 以i - 1结尾的nums1, 以j - 1结尾的nums2公共最长子序列长度为dp[i][j]</span></span><br><span class="line">        <span class="comment">// 2. if (nums1[i - 1] == nums2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;</span></span><br><span class="line">        <span class="comment">// 3. dp[0][j]和dp[i][0]都是没有意义的, 因为长度都不一样而且dp[i][j]是以i-1和j-1为结尾的 负索引没有意义 -&gt; 直接设置为0</span></span><br><span class="line">        <span class="comment">// 4. 顺序遍历(但是要能包括最后一位数)</span></span><br><span class="line">        <span class="comment">// 5. -</span></span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(nums<span class="number">1.</span><span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(nums<span class="number">2.</span><span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= nums<span class="number">1.</span><span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= nums<span class="number">2.</span><span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>]) </span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                result = <span class="built_in">max</span>(result, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-common-subsequence/">最长公共子序列</a></h4><ol>
<li>思路：两边相同的时候在上一个状态的基础上+1，两边不相同的时候继承上一个状态的最大值，最终返回结尾为最后一位元素的子串</li>
<li>因为不要求连续，所以如果当前元素不相同可以继承上一个状态（当前元素不相等就不改变dp数组）</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/uncrossed-lines/">应用题版本</a></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. text1的i-1位前与text2的j-1位前最大公共子序列长度为dp[i][j]</span></span><br><span class="line">        <span class="comment">// 2. 如果i-1位与j-1位相同 -&gt; dp[i][j] = dp[i - 1][j - 1] + 1;</span></span><br><span class="line">        <span class="comment">// 2. 如果i-1位与j-1位不相同 -&gt; 因为不要求连续,所以可以看上一位是否相同</span></span><br><span class="line">        <span class="comment">// 2. dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);</span></span><br><span class="line">        <span class="comment">// 3. 初始化: 都是0, 因为公共子序列的个数不一定存在</span></span><br><span class="line">        <span class="comment">// 4. 公共子序列的相对顺序不能乱, 顺序遍历比较方便</span></span><br><span class="line">        <span class="comment">// 5. 最终结果是看最后一位, 因为只有看完了最后一位才能知道最后一位之前公共子序列的长度</span></span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(text<span class="number">1.</span><span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(text<span class="number">2.</span><span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= text<span class="number">1.</span><span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= text<span class="number">2.</span><span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);<span class="comment">//不要求连续就可以加这句</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[text<span class="number">1.</span><span class="built_in">size</span>()][text<span class="number">2.</span><span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="最大子数组和-动规和贪心"><a href="#最大子数组和-动规和贪心" class="headerlink" title="最大子数组和 - 动规和贪心"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/">最大子数组和 - 动规和贪心</a></h4><ol>
<li>思路：dp数组的含义：以i为结尾元素的子数组，最大和为dp[i]；如果加上当前元素更大则加，如果当前元素比之前合起来都大那么直接放弃之前的状态从当前位置重新统计</li>
<li>因为dp数组代表的是以i为结尾元素的子数组，以最后一位元素为结尾的子数组不一定具有最大和，所以需要额外定义一个变量来统计最大和</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. i位之前的子数组最大和为dp[i]</span></span><br><span class="line">        <span class="comment">// 2. 如果之前是负数 dp[i] = nums[i]; /*这里可以直接更新*/</span></span><br><span class="line">        <span class="comment">// 2. 如果之前还是正的 dp[i] = dp[i - 1] + nums[i]</span></span><br><span class="line">        <span class="comment">// 2. 取最大值 dp[i] = max(dp[i - 1] + nums[i], nums[i]);</span></span><br><span class="line">        <span class="comment">// 3. 初始化: dp[0] = nums[0]; 其余的都要为无穷小, 如果全是负数的话 0有可能覆盖掉正确的值</span></span><br><span class="line">        <span class="comment">// 4. 要求连续数组 -&gt; 顺序不能变 -&gt; 顺序遍历</span></span><br><span class="line">        <span class="comment">// 5. -</span></span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(), INT_MIN)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> result = dp[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>] + nums[i], nums[i]);</span><br><span class="line">            result = <span class="built_in">max</span>(result, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 贪心</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*贪心*/</span></span><br><span class="line">        <span class="comment">// 局部最优: 总和小于0直接重置, 大于0继续叠加</span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> result = INT_MIN;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            count += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (result &lt; count) &#123;    <span class="comment">//只记录最大值</span></span><br><span class="line">                result = count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count &lt; <span class="number">0</span>) count = <span class="number">0</span>;<span class="comment">//总和小于0直接重置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="判断子序列"><a href="#判断子序列" class="headerlink" title="判断子序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/is-subsequence/">判断子序列</a></h4><ol>
<li>思路：判断最长公共子序列的应用题版本，主要的区别就是。若s是t的子串，st以最后一个元素为结尾元素的子串具有最长公共子序列的长度为s.size()</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubsequence</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 长度为i-1的s子数组与长度为j-1的t子数组相同的具有相同的子序列长度为dp[i][j]</span></span><br><span class="line">        <span class="comment">// 2. 当前位相同 -&gt; if (s[i - 1] == t[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;</span></span><br><span class="line">        <span class="comment">// 2. 当前位不相同 -&gt; 看t的前一位(长度为j-2的t子数组, 其实就是往前删, 一直没有就一直继承上一个dp值) dp[i][j] = dp[i][j - 1];</span></span><br><span class="line">        <span class="comment">// 3. 长度为-1的子数组没有意义 -&gt; dp[0][j] = 0; dp[i][0] = 0;</span></span><br><span class="line">        <span class="comment">// 4. 顺序遍历</span></span><br><span class="line">        <span class="comment">// 5. -</span></span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(t.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= t.<span class="built_in">size</span>(); ++j) &#123;    <span class="comment">//这里改成j = i也可以AC</span></span><br><span class="line">                <span class="keyword">if</span> (s[i - <span class="number">1</span>] == t[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dp[s.<span class="built_in">size</span>()][t.<span class="built_in">size</span>()] == s.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="不同的子序列"><a href="#不同的子序列" class="headerlink" title="不同的子序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/distinct-subsequences/">不同的子序列</a></h4><ol>
<li>思路：匹配单个元素的时候可以使用当前元素也可以不使用当前元素，使用当前元素就是dp[i][j] &#x3D; dp[i - 1][j - 1], 不使用当前元素就是dp[i][j] &#x3D; dp[i - 1][j]; 如果匹配失败，则找下一元素dp[i][j] &#x3D; dp[i - 1][j];</li>
<li>dp[i][0]一定都是1，因为也就是把以i-1为结尾的s，删除所有元素，出现空字符串的个数就是1。</li>
<li>当s[i - 1] 与 t[j - 1]不相等时，不用s[i - 1]来匹配（就是模拟在s中删除这个元素），即：dp[i - 1][j]</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numDistinct</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 长度为i-1的s子序列中, 长度为j-1的t子序列出现的个数为dp[i][j]</span></span><br><span class="line">        <span class="comment">// 2. 第i-1位与第j-1位相同 -&gt; if (s[i - 1] == t[j - 1]) dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];</span></span><br><span class="line">        <span class="comment">// 2. 加的后面那个部分 -&gt; 可以不使用最后一位进行匹配, 而是只使用前面的i-2位匹配</span></span><br><span class="line">        <span class="comment">// 2. 不相同 -&gt; dp[i][j] = dp[i - 1][j];</span></span><br><span class="line">        <span class="comment">// 3. 初始化:dp[0][j]没有意义; s随便删除, 都能够和空字符串进行匹配 -&gt; dp[i][0] = 1;</span></span><br><span class="line">        <span class="comment">// 4. 顺序遍历</span></span><br><span class="line">        <span class="comment">// 5. -</span></span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">uint32_t</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">uint32_t</span>&gt;(t.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= s.<span class="built_in">size</span>(); ++i) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= t.<span class="built_in">size</span>(); ++j) dp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= t.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i - <span class="number">1</span>] == t[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for (const vector&lt;int&gt;&amp; vi : dp) &#123;</span></span><br><span class="line">        <span class="comment">//     for (const int&amp; i : vi) &#123;</span></span><br><span class="line">        <span class="comment">//         cout &lt;&lt; i &lt;&lt; &quot; &quot;;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[s.<span class="built_in">size</span>()][t.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="两个字符串的删除操作"><a href="#两个字符串的删除操作" class="headerlink" title="两个字符串的删除操作"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-operation-for-two-strings/">两个字符串的删除操作</a></h4><ol>
<li>思路：将所有操作统一为删，相同则继承上一个状态，不相同则删掉其中一个字符串，然后步数+1</li>
<li>因为只需要记录步数，所以不区分操作，将操作统一为删</li>
<li>初始化的时候要注意，任一字符串为空的时候，另一个字符串有多长，要做的删除操作就有多少步；详见初始化的逻辑</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. word1长度为i-1的子串与word2长度为j-1的子串最少需经过dp[i][j]次能相同</span></span><br><span class="line">        <span class="comment">// 2. if (word1[i - 1] == word2[j - 1]) dp[i][j] = dp[i - 1][j - 1]; &lt;- 两边具有相同字母不需要改变</span></span><br><span class="line">        <span class="comment">// 2. else &#123; dp[i][j] = min(&#123;dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + 2&#125;)&#125;</span></span><br><span class="line">        <span class="comment">// 2. 上面三种分别对应： 删word1, 删word2, 两个都删</span></span><br><span class="line">        <span class="comment">// 3. 初始化: dp[i][0] = i; dp[0][j] = j; 如果另一个串是空串 -&gt; 需要把全部字符都删掉</span></span><br><span class="line">        <span class="comment">// 4. 顺序遍历</span></span><br><span class="line">        <span class="comment">// 5. -</span></span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(word<span class="number">1.</span><span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(word<span class="number">2.</span><span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= word<span class="number">1.</span><span class="built_in">size</span>(); ++i) dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= word<span class="number">2.</span><span class="built_in">size</span>(); ++j) dp[<span class="number">0</span>][j] = j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= word<span class="number">1.</span><span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= word<span class="number">2.</span><span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// for (const vector&lt;int&gt;&amp; vi : dp) &#123;</span></span><br><span class="line">        <span class="comment">//     for (const int&amp; i : vi) &#123;</span></span><br><span class="line">        <span class="comment">//         cout &lt;&lt; i &lt;&lt; &quot; &quot;;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[word<span class="number">1.</span><span class="built_in">size</span>()][word<span class="number">2.</span><span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/edit-distance/">编辑距离</a></h4><ol>
<li>思路：相同则继承上一个状态，不相同则进行删除和替换操作</li>
<li>初始化的时候和【583】两个字符串的删除操作相同，一个字符串是空串的时候另一个要做size次删除操作</li>
<li>替换元素dp[i][j] &#x3D; dp[i - 1][j - 1] + 1; word1或word2删除元素（一个删除相当于另一个增加）dp[i][j] &#x3D; dp[i - 1][j]或dp[i][j - 1]</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. word1长度为i-1的子串转换成word2长度为j-1的子串最少需要经过dp[i][j]</span></span><br><span class="line">        <span class="comment">// 2. 当前位相同 -&gt; 不需要操作 -&gt; dp[i][j] = dp[i - 1][j - 1];</span></span><br><span class="line">        <span class="comment">// 2. 需要删除word1子串 -&gt; dp[i][j] = dp[i - 1][j] + 1;</span></span><br><span class="line">        <span class="comment">// 2. 需要插入一个字符到word1子串 -&gt; 操作次数与删除word2子串相同 -&gt; dp[i][j] = dp[i][j - 1] + 1;</span></span><br><span class="line">        <span class="comment">// 2. 需要替换一个字符 -&gt; dp[i][j] = dp[i - 1][j - 1] + 1;**</span></span><br><span class="line">        <span class="comment">// 3. 初始化: dp[i][0] = i; dp[0][j] = j;</span></span><br><span class="line">        <span class="comment">// 4. 顺序遍历</span></span><br><span class="line">        <span class="comment">// 5. 替换操作从相同的子串开始, 操作数+1就可以</span></span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(word<span class="number">1.</span><span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(word<span class="number">2.</span><span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= word<span class="number">1.</span><span class="built_in">size</span>(); ++i) dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= word<span class="number">2.</span><span class="built_in">size</span>(); ++j) dp[<span class="number">0</span>][j] = j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= word<span class="number">1.</span><span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= word<span class="number">2.</span><span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(&#123;dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]&#125;) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[word<span class="number">1.</span><span class="built_in">size</span>()][word<span class="number">2.</span><span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/16/Analysis-of-Low-Memory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/xiaoxin.jpg">
      <meta itemprop="name" content="Make1tRight">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Make it right.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/16/Analysis-of-Low-Memory/" class="post-title-link" itemprop="url">Computer System | Analysis of Low Memory</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-11-16 14:06:45 / Modified: 15:31:11" itemprop="dateCreated datePublished" datetime="2024-11-16T14:06:45+08:00">2024-11-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/basic-computer-knowledge/" itemprop="url" rel="index"><span itemprop="name">basic computer knowledge</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="内存满了会发生什么？"><a href="#内存满了会发生什么？" class="headerlink" title="内存满了会发生什么？"></a>内存满了会发生什么？</h2><h3 id="内存分配的过程是怎样的？"><a href="#内存分配的过程是怎样的？" class="headerlink" title="内存分配的过程是怎样的？"></a>内存分配的过程是怎样的？</h3><p><img src="/../images/Analysis_of_low_memory/Analysis_of_low_memory_1.png" alt="Analysis_of_low_memory_1"></p>
<ol>
<li>通过malloc函数申请虚拟内存，进程使用这个虚拟内存的时候发现没有对应的物理内存 -&gt; 引发缺页中断</li>
<li>如果此时物理内存不够，会触发后台内存回收kswapd，异步执行、不阻塞</li>
<li>如果后台内存回收速度跟不上内存申请的速度，会触发直接内存回收，同步执行、阻塞</li>
<li>如果直接内存回收也没办法获得足够的物理内存，那么触发OOM（Out of Memory机制）杀死占用物理内存最多的进程，不够再杀</li>
</ol>
<h3 id="哪些内存可以被回收？"><a href="#哪些内存可以被回收？" class="headerlink" title="哪些内存可以被回收？"></a>哪些内存可以被回收？</h3><ol>
<li>文件页，就是内核缓存的磁盘数据和文件数据；因为这些数据如果我们有需要的话回磁盘再次读取就好，如果文件页没有改动那么直接回收，如果文件页被应用程序改动过，也就变成了脏页，这时候会先保存到磁盘中再进行内存释放</li>
<li>匿名页，比如堆栈中的数据，因为很有可能被再次访问到，所以不能直接释放，通过linux的swap机制，先保存到磁盘中再进行内存释放，如果还需要这些数据，从磁盘中读取就好<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="comment"># -i就是不区分大小写的意思</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> /proc/meminfo | grep -i active | <span class="built_in">sort</span></span></span><br><span class="line">Active:</span><br><span class="line">Active(anon):</span><br><span class="line">Active(file):</span><br><span class="line">Inactive:</span><br><span class="line">Inactive(anon):</span><br><span class="line">Inactive(file):</span><br></pre></td></tr></table></figure></li>
<li>内存回收（文件页、匿名页的回收）的算法基于LRU算法，就是优先回收不常访问的内存，简单来说就是维护两个链表，一个活跃内存页链表active_list（最近被访问过）一个不活跃内存页链表inactive_list（很少被访问），越接近链表尾部的内存越不活跃，从链表尾部开始释放内存就好</li>
</ol>
<h3 id="内存回收带来的性能影响"><a href="#内存回收带来的性能影响" class="headerlink" title="内存回收带来的性能影响"></a>内存回收带来的性能影响</h3><ol>
<li>因为一些文件被改动，或者不能在磁盘中访问，所以脏页、堆栈数据等文件会需要先保存到磁盘中再进行内存释放，一旦涉及磁盘就意味着磁盘IO操作会很多，系统性能就会下降，也就是变卡</li>
<li>如何进行优化？<ol>
<li>可以调整参数<code>/proc/sys/vm/swappiness</code>，范围是<code>0-100</code>，来调整对文件页和匿名页的回收倾向，因为文件页碰到干净页是可以直接释放的，所以匿名页的回收会涉及更多IO操作 -&gt; 对性能的影响更大；<code>swappiness</code>越大越倾向于回收匿名页，<code>swappiness</code>越小越倾向于回收文件页<br><img src="/../images/Analysis_of_low_memory/Analysis_of_low_memory_2.png" alt="Analysis_of_low_memory_2"></li>
<li>kswapd机制在$$pages_min\le pages_free\le pages_low$$的时候会触发，直到pages_free大于pages_high<ol>
<li>$$pages_free \le pages_min$$的时候会触发直接内存回收，这时候会阻塞程序</li>
<li>pages_min可以通过系统参数<code>/proc/sys/vm/min_free_kbytes</code>来设置，另外两个参数是根据pages_min算出来的，low&#x3D;min<em>5&#x2F;4，high&#x3D;min</em>3&#x2F;2<ol>
<li>关注延迟 -&gt; 上调；关注内存 -&gt; 下调</li>
</ol>
</li>
</ol>
</li>
<li>调高<code>/proc/sys/vm/min_free_kbytes</code>来调高pages_min，尽早触发kswapd内核线程异步回收机制，避免直接内存回收；</li>
</ol>
</li>
</ol>
<h4 id="NUMA架构下的内存回收策略"><a href="#NUMA架构下的内存回收策略" class="headerlink" title="NUMA架构下的内存回收策略"></a>NUMA架构下的内存回收策略</h4><p><img src="/../images/Analysis_of_low_memory/Analysis_of_low_memory_3.png" alt="Analysis_of_low_memory_3"></p>
<ol>
<li>SMP架构就是多个CPU处理器地位平等、共享电脑硬件资源（总线、内存、IO、操作系统等），每个CPU访问内存要花费的时间是一样的，所以SMP也称为一致存储访问结构UMA，Uniform Memory Access</li>
<li>NUMA架构就是将CPU进行分组，一个组是一个Node<ol>
<li>每个Node有自己独立的资源（内存、IO等）</li>
<li>访问远端Node比本地内存耗时很多</li>
<li>不同Node通过互联模块总线QPI来通信，意味着每个Node的CPU都可以访问到整个系统中所有内存<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/vm/zone_reclaim_mode</span><br><span class="line"><span class="comment"># 0(默认值, 推荐) - 在回收本地内存之前, 在其他Node寻找空闲内存</span></span><br><span class="line"><span class="comment"># 1 - 只回收本地内存</span></span><br><span class="line"><span class="comment"># 2 - 只回收本地内存, 可将脏页写回硬盘后回收内存</span></span><br><span class="line"><span class="comment"># 4-  只回收本地内存, 通过swap内存的方式回收</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>在NUMA架构下，如果内存不够用，既可以通过其他Node来获取空闲内存，也可以通过回收本地内存来获取空闲内存；虽然访问其他Node比访问本地内存耗时，但是对性能的影响更小</li>
</ol>
<h3 id="如何保护一个进程不被OOM杀掉"><a href="#如何保护一个进程不被OOM杀掉" class="headerlink" title="如何保护一个进程不被OOM杀掉?"></a>如何保护一个进程不被OOM杀掉?</h3><ol>
<li><code>oom_badness()</code>函数会把可以杀掉的进程全部扫描一遍，对每个进程打分，分数最高的进程会被杀掉</li>
<li>每个进程都有一个OOM校准值<code>oom_score_adj</code>，取值范围在-1000~1000之间、默认值是0，分数越高越容易被杀；如果无论如何都不能杀这个进程 -&gt; 把进程的这个参数设为-1000</li>
<li>进程使用的物理内存页面数越高越容易被杀</li>
<li>计算公式<br>$$points&#x3D;process _ pages+oom_score_adj\times totoalpages\div1000$$</li>
</ol>
<ul>
<li>process_pages是进程已经使用的页面数，totalpages是系统总的可用页面数</li>
</ul>
<ol>
<li>不建议把业务程序的<code>oom_score_adj</code>设置为-1000，如果业务程序有内存泄漏又杀不掉，内存开销就越来越大 -&gt; OOM KILLER不断被唤醒杀掉其他的程序</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/16/How-malloc-works/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/xiaoxin.jpg">
      <meta itemprop="name" content="Make1tRight">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Make it right.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/16/How-malloc-works/" class="post-title-link" itemprop="url">Computer System | How malloc works</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-11-16 13:56:34 / Modified: 14:05:13" itemprop="dateCreated datePublished" datetime="2024-11-16T13:56:34+08:00">2024-11-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/basic-computer-knowledge/" itemprop="url" rel="index"><span itemprop="name">basic computer knowledge</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="malloc是如何分配内存的？"><a href="#malloc是如何分配内存的？" class="headerlink" title="malloc是如何分配内存的？"></a>malloc是如何分配内存的？</h2><h3 id="Linux进程的内存分布长什么样？"><a href="#Linux进程的内存分布长什么样？" class="headerlink" title="Linux进程的内存分布长什么样？"></a>Linux进程的内存分布长什么样？</h3><p>内核空间是段页式管理结构</p>
<h3 id="malloc是如何分配内存的？-1"><a href="#malloc是如何分配内存的？-1" class="headerlink" title="malloc是如何分配内存的？"></a>malloc是如何分配内存的？</h3><ol>
<li>malloc分配的是虚拟内存 -&gt; 如果不用到分配的虚拟内存是不会映射到物理内存的 -&gt; 节约物理内存空间</li>
<li>malloc不是系统调用，是C库函数，但是malloc调用的brk()和mmap()指令都是用来管理内存的系统调用<br><img src="/../images/malloc/malloc_1.png" alt="malloc_1"></li>
<li>如果要分配的内存<code>&lt;128KB</code>通过brk()使堆顶指针上移 -&gt; 获得新的内存空间<ol>
<li>如果使用free指令，不会立即释放内存给操作系统，而是会缓存到malloc内存池中方便下次调用</li>
<li>因为堆空间是连续的，为了减少因为系统调用产生的上下文切换次数，一般都会分配更多的内存，不用以后执行free指令把内存缓存到内存池中；对比mmap()分配的内存来说，减少了系统调用的开销、减少了缺页中断的次数提升了CPU效率</li>
<li>举例说明，malloc(1)里面的参数虽然是字节数，但是不会严格按照我们设置的字节数来分配对应的空间数的，例如，malloc(1)会分配132K字节的内存</li>
<li>随着系统频繁调用malloc和free，尤其对于小块的内存，在使用brk()分配内存的过程中，如果产生了向内核空间那样的用不了的内存碎片，就叫做内存泄漏（可以用Valgrind检查）</li>
</ol>
</li>
<li>如果要分配的内存<code>&gt;128KB</code>通过mmap()在文件映射段里面分配一片内存<ol>
<li>如果使用free指令就会立即释放内存操作系统</li>
<li>因为mmap()指令是系统调用，所以涉及到内核态与用户态的上下文切换；</li>
<li>因为mmap()分配的内存在执行free指令后一定会释放掉对应的内存，所以每当首次使用mmap()分配的内存都会触发一次缺页中断 -&gt; 加大CPU消耗<br> <img src="/../images/malloc/malloc_2.png" alt="malloc_2"></li>
<li>malloc返回给用户的内存起始地址会比进程的堆空间起始地址多16字节，这16字节用来记录分配的内存块长度</li>
<li>free对传入的内存向左偏移16字节就知道内存块的长度 -&gt; 释放对应大小的内存<ul>
<li>因为有这个内存块的头信息，我们在使用free的时候不需要指定大小</li>
</ul>
</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/16/Virtual-Memory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/xiaoxin.jpg">
      <meta itemprop="name" content="Make1tRight">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Make it right.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/16/Virtual-Memory/" class="post-title-link" itemprop="url">Computer System | Virtual Memory</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-11-16 13:17:05 / Modified: 13:56:54" itemprop="dateCreated datePublished" datetime="2024-11-16T13:17:05+08:00">2024-11-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/basic-computer-knowledge/" itemprop="url" rel="index"><span itemprop="name">basic computer knowledge</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="为什么要有虚拟内存？"><a href="#为什么要有虚拟内存？" class="headerlink" title="为什么要有虚拟内存？"></a>为什么要有虚拟内存？</h2><h3 id="虚拟内存是什么？"><a href="#虚拟内存是什么？" class="headerlink" title="虚拟内存是什么？"></a>虚拟内存是什么？</h3><ol>
<li>单片机没有操作系统，需要把程序烧录到内存中去才能运行；如果要运行其他程序，因为程序是直接访问物理内存的，这时候只能把旧程序废弃，烧录新程序到内存中去，所以对于单片机来说不能让两个程序同时运行；引入了虚拟内存就能够让操作系统同时运行多个程序</li>
<li>程序所用的内存空间是虚拟内存地址；实际在硬件上的空间地址是物理内存地址</li>
<li>多个程序运行过程中互不干扰的原因在于，他们都只访问各自的虚拟地址，都不直接访问物理地址</li>
<li>操作系统通过内存分段和内存分页的方式来管理虚拟内存和物理内存之间的关系</li>
</ol>
<h3 id="内存分段"><a href="#内存分段" class="headerlink" title="内存分段"></a>内存分段</h3><p><img src="/../images/virtual_memory/virtual_memory_1.png" alt="virtual_memory_1"></p>
<ol>
<li>程序是由代码段、数据段、堆段、栈段组成的，内存分段就是按照程序中不同段的功能将内存地址进行分段</li>
<li>分段机制下，虚拟地址由段选择因子和段内偏移量组成<ol>
<li>段选择因子就是标记段号，哪些段从哪个基地址开始</li>
<li>基地址+偏移量就能够说明从哪里到哪里是哪个段</li>
</ol>
</li>
<li>分段的办法会引发外部内存碎片、内存交换效率低的问题<ol>
<li>两段不连续的100MB内存无法运行一个200MB的程序，因为他们之间不连续，程序加载不进去</li>
<li>解决外部内存碎片的方案是内存交换，也就是把空闲内存之间占用的内存先换到磁盘中去，把空闲内存变成连续的一段、再把原来占用的部分还原到内存中；linux的swap内存就是干这个事的；因为涉及到磁盘读写，就有了内存交换效率低的问题</li>
</ol>
</li>
</ol>
<h3 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h3><p><img src="/../images/virtual_memory/virtual_memory_2.png" alt="virtual_memory_2"></p>
<ol>
<li>为解决外部内存碎片和内存交换效率低的问题，思路就是让内存碎片变小一些，解决方案是把虚拟内存空间和物理内存空间都分成连续且尺寸固定的内存空间，称为页，也就是内存分页；</li>
<li>MMU是内存管理单元，功能是将虚拟内存和物理地址进行转换</li>
<li>因为页与页之间是紧密排布的，不会产生外部碎片；另外，如果有一个页里面内存空间没有用完，将一个页换出到磁盘中开销也远远比换一个段更小<br><img src="/../images/virtual_memory/virtual_memory_3.png" alt="virtual_memory_3"></li>
<li>内存分页的缺点在于，每个进程都要有用于记录页号和偏移量的页表，一个进程如果是4MB的页表，100个进程就是400MB的页表 -&gt; 用于存储页表的内存非常大<ol>
<li>虚拟内存空间共有4GB，一个页的大小如果是4KB，那么就有100W页</li>
<li>页表一行需要4个字节来存储一个页的信息，4GB空间映射要花费4M来保存一个页</li>
</ol>
</li>
<li>普通的分页会造成页表太大的问题，多级页表可以解决页表过大的问题</li>
<li>多级页表就是先分配1024行映射整个物理地址空间，等到进程实际要用的时候再去分配二级页表（或者说下一级页表）</li>
<li>64位系统的页表有4级分页</li>
</ol>
<h3 id="段页式内存管理"><a href="#段页式内存管理" class="headerlink" title="段页式内存管理"></a>段页式内存管理</h3><p><img src="/../images/virtual_memory/virtual_memory_4.png" alt="virtual_memory_4"><br><img src="/../images/virtual_memory/virtual_memory_5.png" alt="virtual_memory_5"></p>
<ol>
<li>内存分段和内存分页结合的方式就是段页式内存管理；一个进程按不同段的功能分段，将信息记录到一个段表中，每行写的是页表的起始地址；页表里面写的是物理页号，将物理页号和偏移量组合就是物理地址</li>
<li>段页式管理提升了内存的利用率</li>
</ol>
<h3 id="Linux内存布局"><a href="#Linux内存布局" class="headerlink" title="Linux内存布局"></a>Linux内存布局</h3><ol>
<li>主要采用页式内存管理，也有段，但是每个段的起始地址都是一样的；</li>
<li>每个进程都有独立的虚拟内存，每个虚拟内存中的内核地址关联的都是同一片物理地址<br><img src="/../images/virtual_memory/virtual_memory_6.png" alt="virtual_memory_6"></li>
</ol>
<p><strong>用户空间的内存分布情况：</strong></p>
<ol>
<li>栈的大小是固定的，包括局部变量和函数调用上下文信息（函数参数），每次申请新的栈地址，地址值都在减少<ol>
<li>start_stack标识栈的起始位置、RSP寄存器保存栈顶指针stack pointer、RBP寄存器保存栈基地址</li>
</ol>
</li>
<li>文件映射与匿名映射区，用来存放动态链接库（动态链接库也有自己的代码段、数据段、BSS段，动态链接库的这3段会加入到这个区里面）和内存映射区域（用于建立文件与内存的映射）（dynamic link library）<ol>
<li>动态链接库的代码可被多个程序共享，不会被编译到可执行文件中，所以节约了系统资源</li>
<li>因为不会被编译到可执行文件中，所以动态链接库可以单独更新，不需要修改使用它的程序（libstdc++.dll，STL也是动态链接库）</li>
</ol>
</li>
<li>在栈区和文件映射与匿名映射区，地址增长方向都是从上往下增长</li>
<li>堆、文件映射段都是在程序运行期间动态分配的（动态申请内存）<ol>
<li>mmap()在文件映射段动态分配内存，文件映射段包括动态库、共享内存</li>
<li>malloc()在堆动态分配内存，start_brk标识堆的起始位置，brk标识堆当前结束的位置，增长也是由brk堆顶指针来向上增长</li>
</ol>
</li>
<li>BSS段包含未初始化的静态变量和全局变量，未初始化的全局变量被加载进内存之后会在这里初始化为0值</li>
<li>数据段就是初始化了的静态变量和全局变量</li>
<li>代码段是可执行的指令，也可以理解成机器码</li>
<li>最下面灰色的部分不可访问，防止代码跑飞，NULL指针就指向这个区域</li>
</ol>
<h3 id="虚拟内存作用总结"><a href="#虚拟内存作用总结" class="headerlink" title="虚拟内存作用总结"></a>虚拟内存作用总结</h3><ol>
<li>多进程独享各自的页表，各进程在运行的过程中互不干扰，解决多地址冲突的问题</li>
<li>能够将不常使用的内存换出到磁盘中，节约内存空间</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/16/Monotone-Stack/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/xiaoxin.jpg">
      <meta itemprop="name" content="Make1tRight">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Make it right.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/16/Monotone-Stack/" class="post-title-link" itemprop="url">Monotone Stack</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-11-16 11:02:58 / Modified: 11:09:14" itemprop="dateCreated datePublished" datetime="2024-11-16T11:02:58+08:00">2024-11-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/../images/monotoneStack_summary.png" alt="monotoneStack_summary"></p>
<h3 id="找两边比自己大的元素"><a href="#找两边比自己大的元素" class="headerlink" title="找两边比自己大的元素"></a>找两边比自己大的元素</h3><h4 id="每日温度"><a href="#每日温度" class="headerlink" title="每日温度"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/daily-temperatures/submissions/580661919/">每日温度</a></h4><ol>
<li>思路：单调栈从栈顶到栈底是单调递增的，每当数组元素比栈顶元素更小则入栈，否则一直弹出栈顶元素并记录结果，直到栈顶元素比数组元素更大</li>
<li>为了记录更大元素与当前元素的距离，单调栈要维护的是元素的索引，作差就能得到距离</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(temperatures.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        st.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; temperatures.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temperatures[i] &lt;= temperatures[st.<span class="built_in">top</span>()]) &#123; <span class="comment">//元素更小或者相等</span></span><br><span class="line">                st.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;    <span class="comment">//元素更大 -&gt; 记录结果</span></span><br><span class="line">                <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; temperatures[st.<span class="built_in">top</span>()] &lt; temperatures[i]) &#123;</span><br><span class="line">                    result[st.<span class="built_in">top</span>()] = i - st.<span class="built_in">top</span>();</span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                st.<span class="built_in">push</span>(i); <span class="comment">//最后不要忘记把元素放入栈内记录后面的结果</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="下一个更大元素Ⅰ"><a href="#下一个更大元素Ⅰ" class="headerlink" title="下一个更大元素Ⅰ"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/next-greater-element-i/description/">下一个更大元素Ⅰ</a></h4><ol>
<li>思路：B数组正常做单调栈（但是记录结果的时候转成A数组的索引），如果不是两个数组共有的元素只需要保持单调栈的单调性就可以，不需要记录结果</li>
<li>建立键值对映射用unordered_map，在A数组上做映射、在B数组上做单调栈，AB数组之间的重要联系就是他们拥有的相同元素，那么就检查当前元素是否为两数组共有，用count来检查，用unordered_map来转换</li>
<li>建立哪个数组的键值对？长度和哪个数组一致就用哪个；另一个不需要做映射，因为要在他上面做单调栈的遍历，另一个只需要记录结果</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; umap;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums<span class="number">1.</span><span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            umap[nums1[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(nums<span class="number">1.</span>size(), <span class="number">-1</span>)</span></span>;</span><br><span class="line">        st.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums<span class="number">2.</span><span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums2[i] &lt;= nums2[st.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; nums2[st.<span class="built_in">top</span>()] &lt; nums2[i]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (umap.<span class="built_in">count</span>(nums2[st.<span class="built_in">top</span>()]) &gt; <span class="number">0</span>) &#123;  <span class="comment">//检查当前元素是否在nums1里面</span></span><br><span class="line">                        <span class="type">int</span> index = umap[nums2[st.<span class="built_in">top</span>()]];  <span class="comment">//记录当前元素的索引</span></span><br><span class="line">                        result[index] = nums2[i];           <span class="comment">//记录比当前元素大的元素</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                st.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h4 id="下一个更大元素Ⅱ"><a href="#下一个更大元素Ⅱ" class="headerlink" title="下一个更大元素Ⅱ"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/next-greater-element-ii/">下一个更大元素Ⅱ</a></h4><ol>
<li>思路：也是单调栈的模板题，只是需要循环遍历（对数组长度取模、或者也可以2个数组拼在一起）</li>
<li>c.insert(p, b, e)将be指定范围（不能指向c中的元素）内的元素插入到迭代器p指向元素之前，时间复杂度是O(n)，虽然更直观但是更费时</li>
<li>直接取模，遍历两倍的size是更高效的做法</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextGreaterElements</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*****方法一：把nums重复拼接起来****</span></span><br><span class="line"><span class="comment">         *  数组两个拼在一起, 然后找一遍，只返回和nums一样大小的结果</span></span><br><span class="line"><span class="comment">         *  vector&lt;int&gt; result(nums.size(), -1);</span></span><br><span class="line"><span class="comment">         *  vector&lt;int&gt; doubleNums(nums.begin(), nums.end());</span></span><br><span class="line"><span class="comment">         *  doubleNums.insert(doubleNums.end(), nums.begin(), nums.end());</span></span><br><span class="line"><span class="comment">         *  后面的计算就不需要取膜了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">         </span><br><span class="line">        <span class="comment">/*********方法二：取模运算*********/</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(nums.size(), <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        st.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>() * <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i % nums.<span class="built_in">size</span>()] &lt;= nums[st.<span class="built_in">top</span>()]) &#123; <span class="comment">//取模</span></span><br><span class="line">                st.<span class="built_in">push</span>(i % nums.<span class="built_in">size</span>());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; nums[st.<span class="built_in">top</span>()] &lt; nums[i % nums.<span class="built_in">size</span>()]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (st.<span class="built_in">top</span>() &lt; result.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                        result[st.<span class="built_in">top</span>()] = nums[i % nums.<span class="built_in">size</span>()];</span><br><span class="line">                    &#125;</span><br><span class="line">                    st.<span class="built_in">pop</span>();   </span><br><span class="line">                &#125;</span><br><span class="line">                st.<span class="built_in">push</span>(i % nums.<span class="built_in">size</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h4 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/trapping-rain-water/description/">接雨水</a></h4><ol>
<li>思路：栈顶到栈底单调递增的单调栈，每当入栈元素比栈顶元素大的时候，弹出栈顶元素作为中间值，根据栈顶元素左右两边柱子的高度最小值和左右两边柱子的距离，横向计算所接雨水面积</li>
<li>要注意栈顶指针是否到栈底，因为有pop以后再取值的操作，所以pop以后要手动检查一次</li>
<li>每次计算面积的时候只弹出中间的元素，左边只参与计算，右边参与计算以后再入栈</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (height.<span class="built_in">size</span>() &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//剪枝</span></span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        st.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; height.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (height[i] &lt;= height[st.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; height[st.<span class="built_in">top</span>()] &lt; height[i]) &#123;</span><br><span class="line">                    <span class="type">int</span> mid = st.<span class="built_in">top</span>();</span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (!st.<span class="built_in">empty</span>()) &#123;    <span class="comment">//检查</span></span><br><span class="line">                        <span class="type">int</span> h = <span class="built_in">min</span>(height[i], height[st.<span class="built_in">top</span>()]) - height[mid];</span><br><span class="line">                        <span class="type">int</span> w = i - st.<span class="built_in">top</span>() - <span class="number">1</span>;</span><br><span class="line">                        result += w * h;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                st.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="找两边比自己小的元素"><a href="#找两边比自己小的元素" class="headerlink" title="找两边比自己小的元素"></a>找两边比自己小的元素</h3><h4 id="柱状图中最大的矩形"><a href="#柱状图中最大的矩形" class="headerlink" title="柱状图中最大的矩形"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">柱状图中最大的矩形</a></h4><ol>
<li>思路：根据三根柱子统计面积：通过栈顶到栈底单调递减的栈来找矩形的左右边界，根据左右边界+当前柱子的高度计算矩形最大面积</li>
<li>为什么要三根柱子才能计算呢？左边比自己矮的柱子是左边界，右边比自己矮的柱子是右边界；如果柱子比自己高那么就可以扩展矩形的面积；要找两边都矮的柱子，也解释了构造栈顶到栈底是单调递减的栈的原因</li>
<li>结果怎么统计？宽度就是柱子之间的距离（从1根柱子的情况开始统计的），高度就是中间柱子的高度</li>
<li>为什么要在首尾位置添加0？<ol>
<li>如果数组元素是单调递减的时候[8, 6, 4, 2]，那么栈里每次只会有1个元素，凑不齐3根柱子，导致进不到统计结果的逻辑 -&gt; 开头加一个0元素凑最左边的柱子，凑齐3根</li>
<li>如果数组是单调递增的[2, 4, 6, 8]每个柱子都入栈，最后也进不到while循环里面，也无法凑齐3根柱子，导致进不到统计结果的逻辑 -&gt; 末尾加一个0元素凑最右边的柱子，凑齐3根</li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        heights.<span class="built_in">insert</span>(heights.<span class="built_in">begin</span>(), <span class="number">0</span>); <span class="comment">//头尾插入0</span></span><br><span class="line">        heights.<span class="built_in">push_back</span>(<span class="number">0</span>);               <span class="comment">//便于结果统计</span></span><br><span class="line">        st.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; heights.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (heights[st.<span class="built_in">top</span>()] &lt;= heights[i]) &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; heights[i] &lt; heights[st.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">                    <span class="type">int</span> mid = st.<span class="built_in">top</span>(); st.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">if</span> (!st.<span class="built_in">empty</span>()) &#123;      <span class="comment">//如果元素单调递减的话, 栈里永远只有1个元素, </span></span><br><span class="line">                        <span class="type">int</span> left = st.<span class="built_in">top</span>();</span><br><span class="line">                        <span class="type">int</span> right = i;</span><br><span class="line">                        <span class="type">int</span> w = right - left - <span class="number">1</span>;</span><br><span class="line">                        <span class="type">int</span> h = heights[mid];</span><br><span class="line">                        result = <span class="built_in">max</span>(result, w * h);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                st.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/15/Process%20&%20Threads/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/xiaoxin.jpg">
      <meta itemprop="name" content="Make1tRight">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Make it right.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/15/Process%20&%20Threads/" class="post-title-link" itemprop="url">Computer System | Process & Threads</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-11-15 15:11:13 / Modified: 15:48:33" itemprop="dateCreated datePublished" datetime="2024-11-15T15:11:13+08:00">2024-11-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/basic-computer-knowledge/" itemprop="url" rel="index"><span itemprop="name">basic computer knowledge</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="进程、线程基础知识"><a href="#进程、线程基础知识" class="headerlink" title="进程、线程基础知识"></a>进程、线程基础知识</h2><h3 id="进程基础知识"><a href="#进程基础知识" class="headerlink" title="进程基础知识"></a>进程基础知识</h3><h4 id="什么是进程？"><a href="#什么是进程？" class="headerlink" title="什么是进程？"></a>什么是进程？</h4><ol>
<li>可执行程序被装载到内存中运行，CPU执行其中每一条指令的过程叫做进程</li>
<li>对于一个支持多进程的系统来说, CPU会为每个进程分配时间片, 时间(一般是几十ms或几百ms)到了以后会自动切换其他进程并执行; 在任一瞬间, CPU都只能执行一个进程, 但是在一秒钟来看, CPU执行了多个进程, 这个就叫做并发.<br><img src="/../images/processManagement/process_management_1.png" alt="process_management_1"></li>
<li>并行和并发不一样; 并发是CPU不断切换进程, 并行是不同的核同时执行不同的任务</li>
<li>CPU可以在不同进程之间切换, 但是在切换之前要记录当前执行程序的状态信息, 否则下一次切回到这个进程都不知道工作到哪里了; 进程有执行-&gt; 暂停 -&gt; 执行的规律</li>
</ol>
<h4 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h4><ol>
<li>基本状态是创建和结束这两个状态; 因为CPU执行进程的特点, 进程还有运行状态、就绪状态、阻塞状态<br><img src="/../images/processManagement/process_management_2.png" alt="process_management_2"></li>
<li>进程处于阻塞状态的时候，进程没有发挥作用还占用了物理内存空间；因为内存空间是十分宝贵的，如果有大量的进程处于阻塞状态，会占用大量的内存；<ol>
<li>这时我们可以把阻塞的进程保存到磁盘当中去</li>
<li>在进程就绪并且被调度执行的时候再还原到内存中去</li>
<li>处于磁盘中的进程有就绪挂起和阻塞挂起两个状态；Ctrl+Z, 挂起的<br> <img src="/../images/processManagement/process_management_3.png" alt="process_management_3"></li>
</ol>
</li>
</ol>
<h4 id="进程的控制结构"><a href="#进程的控制结构" class="headerlink" title="进程的控制结构"></a>进程的控制结构</h4><ol>
<li>操作系统中，用进程控制块（process control block，PCB）来描述进程；PCB是进程存在的唯一标识，如果进程存在，就会有一个PCB；如果进程消失，PCB也消失</li>
<li>PCB包含的信息<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>进程描述信息</td>
<td>标识进程和进程归属用户</td>
</tr>
<tr>
<td>进程控制和管理信息</td>
<td>标识进程运行的状态和进程运行的优先级</td>
</tr>
<tr>
<td>资源分配清单</td>
<td>标识内存地址空间或虚拟内存空间的信息（打开的文件列表和所使用的IO设备信息）</td>
</tr>
<tr>
<td>CPU相关信息</td>
<td>CPU中各寄存器的值，保证还原的时候能够从断点继续执行</td>
</tr>
</tbody></table>
</li>
<li>因为进程的创建和销毁经常发生，为了更方便插入和删除节点，PCB一般使用链表进行组织，状态为就绪的进程归到一类 -&gt; 就绪队列；状态为阻塞的进程归到一类 -&gt; 阻塞队列;  除了链表还有索引表的形式, 将不同状态的进程加入到不同索引表中, 索引表中每行指向相应的PCB</li>
</ol>
<h4 id="进程的控制"><a href="#进程的控制" class="headerlink" title="进程的控制"></a>进程的控制</h4><table>
<thead>
<tr>
<th>创建进程</th>
<th>终止进程</th>
<th>阻塞进程</th>
<th>唤醒进程</th>
</tr>
</thead>
<tbody><tr>
<td>申请空白PCB, 向PCB中填写进程相关信息</td>
<td>查找要终止的进程</td>
<td>找到要阻塞的进程</td>
<td>在阻塞队列中找到要唤醒进程的PCB</td>
</tr>
<tr>
<td>为进程分配运行必需资源, 比如内存资源</td>
<td>如果进程处于执行状态, 终止进程执行, 将CPU资源分配给其他进程</td>
<td>如果要阻塞的进程处于执行状态, 保护现场后将进程设置为阻塞状态, 并停止进程运行</td>
<td>将PCB从阻塞队列中移除, 并将进程设置为就绪状态</td>
</tr>
<tr>
<td>将PCB加入到就绪队列</td>
<td>如果要终止的进程有子进程, 将子进程交给1号进程进行管理</td>
<td>将PCB加入到阻塞队列</td>
<td>将PCB加入到就绪队列, 等待调度程序调度</td>
</tr>
<tr>
<td></td>
<td>将进程的资源归还操作系统</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>将PCB从所在队列中删除</td>
<td></td>
<td></td>
</tr>
<tr>
<td>进程可以创建子进程</td>
<td>有正常结束、异常结束以及外界干预三种终止方式</td>
<td>阻塞的进程只能由其他进程唤醒</td>
<td>只有该进程期待的事情出现,才由发现者进程唤醒</td>
</tr>
</tbody></table>
<h4 id="进程的上下文切换"><a href="#进程的上下文切换" class="headerlink" title="进程的上下文切换"></a>进程的上下文切换</h4><ol>
<li>一个进程切换到另一个进程就叫做进程的上下文切换, 但是在切换之前要保护现场</li>
<li>对于CPU的上下文切换, 为了让CPU能够继续执行之前未执行完毕的任务, 需要保存<strong>CPU寄存器和程序计数器</strong>这两个信息, 他们是CPU在执行任何任务必须依赖的环境, 即CPU上下文；CPU所执行的任务包括进程、线程和中断三种，根据任务的不同，CPU的上下文切换可以分为进程的上下文切换、线程的上下文切换和中断的上下文切换</li>
<li>进程上下文切换的内容<br><img src="/../images/processManagement/process_management_3.png" alt="process_management_3"><table>
<thead>
<tr>
<th>内核空间（进程由内核调度、管理，进程的切换只发生在内核态）</th>
<th>用户空间</th>
</tr>
</thead>
<tbody><tr>
<td>内核堆栈</td>
<td>虚拟内存</td>
</tr>
<tr>
<td>寄存器</td>
<td>栈</td>
</tr>
<tr>
<td></td>
<td>全局变量</td>
</tr>
<tr>
<td>上下文切换过程中，信息会被保存到PCB中；要保存的信息越少，上下文切换的开销越小，程序执行效率越高</td>
<td></td>
</tr>
</tbody></table>
</li>
<li>发生进程上下文切换的场景<ol>
<li>系统资源不足，进程被挂起</li>
<li>有硬件中断，CPU进程被中断挂起，先去执行中断</li>
<li>当前进程时间片耗尽，从执行状态转到就绪状态</li>
<li>通过睡眠函数sleep()将自己主动挂起</li>
<li>有更高优先级的进程需要被执行的时候，当前进程被挂起</li>
</ol>
</li>
</ol>
<h3 id="线程基础知识"><a href="#线程基础知识" class="headerlink" title="线程基础知识"></a>线程基础知识</h3><h4 id="什么是线程？"><a href="#什么是线程？" class="headerlink" title="什么是线程？"></a>什么是线程？</h4><ol>
<li>进程虽然可以让CPU同时完成不同的任务，但是每次切换进程的时候，因为每个进程依赖的环境都不一样，所以每次都需要进行上下文切换；线程就是想让CPU既能够完成不同的任务（即实体之间并发运行），又让实体之间能够共享相同的地址空间</li>
<li>线程是进程当中的一条执行流程<br><img src="/../images/processManagement/process_management_4.png" alt="process_management_4"></li>
<li>C&#x2F;C++里面，一个线程崩溃会导致相同进程的其他线程也崩溃，所以做游戏不能用多线程</li>
</ol>
<h4 id="线程与进程的比较"><a href="#线程与进程的比较" class="headerlink" title="线程与进程的比较"></a>线程与进程的比较</h4><p>线程创建和终止的开销都比进程小，因为不用分配或释放地址空间、文件等资源</p>
<table>
<thead>
<tr>
<th>进程</th>
<th>线程</th>
</tr>
</thead>
<tbody><tr>
<td>资源分配的最小单位</td>
<td>CPU调度的最小单位</td>
</tr>
<tr>
<td>拥有完整的资源平台</td>
<td>共享地址空间和文件，独享栈和寄存器</td>
</tr>
<tr>
<td>有就绪、阻塞、执行三种状态</td>
<td>有就绪、阻塞、执行三种状态</td>
</tr>
<tr>
<td>切换进程要切换页表</td>
<td>切换线程不用切换页表</td>
</tr>
</tbody></table>
<h4 id="线程的上下文切换"><a href="#线程的上下文切换" class="headerlink" title="线程的上下文切换"></a>线程的上下文切换</h4><ol>
<li>操作系统在进行任务调度的过程中，调度的对象实际上是线程</li>
<li>如果是不同进程之间的线程进行上下文切换，那切换线程和切换进程是一样的</li>
<li>如果是相同进程之间的线程进行上下文切换，因为地址空间、文件、虚拟内存等资源是共享的，所以只需要切换寄存器和栈等线程独享资源即可</li>
</ol>
<h4 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h4><ol>
<li>在用户空间实现的线程是用户线程；在内核空间实现的线程由内核管理，是内核线程；用户线程和内核线程有多对一、一对一、多对多的关系</li>
<li>用户线程基于用户态的线程管理库来实现，（多用户线程对一内核线程）<ol>
<li>对应的线程控制块（Thread Control Block）也由线程管理库来实现（我理解的TCB实现了对PCB更细粒度的管理），TCB保存各个线程的状态信息，包括PC、栈指针、寄存器</li>
<li>操作系统不直接参与用户线程的管理，由线程管理库完成对线程的创建、终止、同步和调度管理操作<table>
<thead>
<tr>
<th>用户线程的优点</th>
<th>用户线程的缺点</th>
</tr>
</thead>
<tbody><tr>
<td>切换由线程库函数自己完成，在用户态就能完成，因此不需要在用户态和内核态进行切换，速度特别快</td>
<td>用户线程在执行过程中不能被中断，只有操作系统才有打断线程执行的特权</td>
</tr>
<tr>
<td>TCB由用户级线程管理库来实现，可用于不支持线程技术的操作系统</td>
<td>因为操作系统不参与用户线程的管理，如果线程发起系统调用而被阻塞，同一进程下的其他线程也都无法运行</td>
</tr>
<tr>
<td></td>
<td>时间片是分配给进程的，所以线程得到的时间片更少，执行速度更慢</td>
</tr>
</tbody></table>
</li>
<li>内核线程由操作系统管理，线程的创建、终止、同步和调度管理操作由操作系统完成（一用户线程对一内核线程）<table>
<thead>
<tr>
<th>内核线程的优点</th>
<th>内核线程的缺点</th>
</tr>
</thead>
<tbody><tr>
<td>一个内核线程发起系统调用被阻塞，其他内核线程不会受影响</td>
<td>内核来维护PCB和TCB</td>
</tr>
<tr>
<td>分配的CPU运行时间更多</td>
<td>线程的创建、终止、同步和调度管理操作通过系统调用来完成，开销更大</td>
</tr>
</tbody></table>
</li>
<li>轻量级线程Light-Weight Process是由内核支持的用户线程</li>
</ol>
</li>
</ol>
<h3 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h3><p>调度程序的功能就是选择一个进程来运行，由操作系统来完成；调度就是进程从一个状态切换到另一个状态</p>
<h4 id="调度时机"><a href="#调度时机" class="headerlink" title="调度时机"></a>调度时机</h4><ol>
<li>调度算法根据处理时钟中断的机制分为非抢占式调度算法和抢占式调度算法<ol>
<li>非抢占式调度算法，不理会时钟中断，当前进程执行完毕，或者当前进程退出以后才去执行下一进程</li>
<li>抢占式调度算法，也就是时间片机制，分配给进程的时间片用完以后触发时钟中断，将CPU控制返回给调度程序进行调度</li>
</ol>
</li>
</ol>
<h4 id="调度原则-让进程更快完成"><a href="#调度原则-让进程更快完成" class="headerlink" title="调度原则 - 让进程更快完成"></a>调度原则 - 让进程更快完成</h4><ol>
<li>CPU利用率要高，当发生IO事件请求的时候就必须从就绪队列中取出进程来运行</li>
<li>系统吞吐量，就是单位时间内CPU完成进程的数量，系统的吞吐量越高越好</li>
<li>周转时间包括进程运行时间+进程等待时间，一个进程的周转时间越小越好</li>
<li>等待时间，进程在就绪队列中的时间</li>
<li>响应时间，从用户发出请求到系统第一次产生响应的时间；在交互式系统中，响应时间是衡量调度算法好坏的标准</li>
</ol>
<h4 id="调度算法-单核CPU"><a href="#调度算法-单核CPU" class="headerlink" title="调度算法(单核CPU)"></a>调度算法(单核CPU)</h4><ol>
<li>先来先服务FCFS调度算法，按进程在就绪队列中的顺序一个一个执行；非抢占式，当一个长作业先运行，后面的短作业也必须等待</li>
<li>对短作业优先Shortest Job First调度算法，优先选择运行时间最短的进程来运行；对长作业不利，短作业一直处于优先地位，长作业只能一直等待，会导致周转时间变长</li>
<li>高响应比优先Highest Response Ratio Next调度算法，$$优先权&#x3D;\frac{等待时间+要求服务时间}{要求服务时间}$$，要求服务时间不可预估，不能实现</li>
<li>时间片轮转Round Robin调度算法，时间片就是时间段；时间片用完了进程还在执行 -&gt; 把进程从CPU释放出来，分配给其他进程；时间片没用完但是进程结束或被阻塞 -&gt; CPU立即切换；一般来说时间片的长度是20ms ~ 50ms</li>
<li>最高优先级HPF调度算法，调度程序在就绪队列中选择优先级高的进程优先运行；<ol>
<li>优先级有动态和静态优先级两种，<ol>
<li>静态优先级是在创建进程的时候就固定好优先级后面不会改变</li>
<li>动态优先级是等待时间长的进程优先级变高、运行时间长的进程优先级降低</li>
</ol>
</li>
<li>这个调度算法有抢占式和非抢占式两种<ol>
<li>非抢占式，当前进程执行完以后，在就绪队列中选择优先级高的进程优先运行</li>
<li>抢占式，有优先级高的进程直接挂起当前进程，调度优先级高的进程运行</li>
</ol>
</li>
</ol>
</li>
<li>多级反馈队列Multilevel Feedback Queue调度算法, RR+HPF, 多级就是有多个队列，每个队列的优先级从高到低、反馈就是如果有新的进程加入到更高优先级队列时，挂起当前进程去执行更高优先级队列中的进程<br> <img src="/../images/processManagement/process_management_5.png" alt="process_management_5"><ol>
<li>优先级越高的队列中，进程分配到的时间片越短</li>
<li>新的进程都被放到第一优先级的队列中，如果在对应时间片内没有执行完，加入到下一优先级队列中去</li>
<li>兼顾了长短作业，同时响应时间也保证了，因为每个进程一开始都是加在最高优先级队列的，很快就能被响应，搞不定再降级</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/15/I-O-multiplexing-technology/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/xiaoxin.jpg">
      <meta itemprop="name" content="Make1tRight">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Make it right.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/15/I-O-multiplexing-technology/" class="post-title-link" itemprop="url">Computer System | I/O multiplexing technology</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-15 14:58:49" itemprop="dateCreated datePublished" datetime="2024-11-15T14:58:49+08:00">2024-11-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-03-08 00:00:05" itemprop="dateModified" datetime="2025-03-08T00:00:05+08:00">2025-03-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/basic-computer-knowledge/" itemprop="url" rel="index"><span itemprop="name">basic computer knowledge</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="I-O多路复用-select-poll-epoll"><a href="#I-O多路复用-select-poll-epoll" class="headerlink" title="I&#x2F;O多路复用: select&#x2F;poll&#x2F;epoll"></a>I&#x2F;O多路复用: select&#x2F;poll&#x2F;epoll</h2><h3 id="最基本的Socket模型"><a href="#最基本的Socket模型" class="headerlink" title="最基本的Socket模型"></a>最基本的Socket模型</h3><ol>
<li>Socket &#x3D; IP + Port</li>
<li>服务器内核为每个SOCKET都维护了一个半连接队列(SYN_RCVD)和一个全连接队列(ESTABLISHED)</li>
</ol>
<h3 id="如何服务更多用户"><a href="#如何服务更多用户" class="headerlink" title="如何服务更多用户?"></a>如何服务更多用户?</h3><ol>
<li>C10K问题, 就是能否支持并发1万请求</li>
<li>单个进程能够打开的文件描述符数量可以通过修改ulimit参数来修改</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询</span></span><br><span class="line"><span class="built_in">ulimit</span> -n </span><br><span class="line"></span><br><span class="line"><span class="comment"># 设定为m</span></span><br><span class="line"><span class="built_in">ulimit</span> -n m</span><br></pre></td></tr></table></figure>

<h3 id="多进程模型"><a href="#多进程模型" class="headerlink" title="多进程模型"></a>多进程模型</h3><ol>
<li><p>为了让服务器和多个客户端建立连接，给每个客户端分配一个进程 -&gt; 多进程模型</p>
<table>
<thead>
<tr>
<th>多进程模型(父进程负责监听, 子进程负责处理业务)</th>
<th>多线程模型</th>
</tr>
</thead>
<tbody><tr>
<td>server在LISTEN状态下, 客户端发起connect</td>
<td>与多进程模型相同</td>
</tr>
<tr>
<td>服务端accept</td>
<td>与多进程模型相同</td>
</tr>
<tr>
<td>应用父进程fork一个子进程</td>
<td>pthread_create()创建新的线程</td>
</tr>
<tr>
<td>子进程复制父进程的文件描述符、内存地址空间、程序计数器、执行的代码等资源(包括与客户端相关的信息)</td>
<td>在线程中实现与客户端的数据交换</td>
</tr>
<tr>
<td>子进程专门处理数据的读写、父进程继续监听socket</td>
<td>-</td>
</tr>
<tr>
<td>如果有新的客户端调用connect, 父进程再fork新的子进程与客户端进行数据交换</td>
<td>-</td>
</tr>
</tbody></table>
</li>
<li><p>父子进程用返回值来区分: 0 -&gt; 子进程, 其他整数 -&gt; 父进程； 父进程只关心监听socket，不关心已连接socket；子进程只关心已连接socket，不关心监听socket</p>
</li>
<li><p>多进程模型的问题, 父子进程之间的上下文切换要复制虚拟内存、全局变量、数据、文件、寄存器和栈等等资源 -&gt; 上下文切换的次数越多 -&gt; 系统性能就越下降</p>
</li>
<li><p>另外，父进程要通过调用wait()&#x2F;pidwait()函数合法回收子进程，否则这些子进程会变成僵尸进程-&gt;同样消耗系统资源</p>
</li>
</ol>
<h3 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h3><ol>
<li>因为多进程模型在使用过程中，进程的上下文切换开销特别大，所以需要更小开销的多线程模型</li>
<li>多线程模型的优势在于，线程共享进程的代码、全局数据、进程空间、文件描述符列表、堆、共享库等资源  -&gt; 切换线程的时候只需要复制寄存器、线程私有数据等专属资源，开销更小、速度更快</li>
<li>虽然说线程的上下文切换开销不大，但是不断创造、删除线程也会消耗很多的系统资源<ol>
<li>可以启用线程池，在建立连接之前就将线程创建好</li>
<li>从全连接队列（ESTABLISHED）中取出全连接对象-&gt;进行数据交换 -&gt; 数据交换结束后也不需要释放对应线程，放回到线程池里即可</li>
</ol>
</li>
</ol>
<h4 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I&#x2F;O多路复用"></a>I&#x2F;O多路复用</h4><ol>
<li>要实现C10K，单纯使用多线程&#x2F;多进程模型意味着需要1w个线程&#x2F;进程，现在自己的电脑也才32线程</li>
<li>IO多路复用技术类似于CPU的并发技术，对每个socket都分配一个时间片，到期以后切换下一个socket，看起来就像是同时处理了多个socket（也叫时分多路复用技术）</li>
<li>常见的IO复用技术就是select&#x2F;poll和epoll（看todolist2-day60）<ol>
<li>select&#x2F;poll都要遍历文件描述符列表去检查哪些socket可读&#x2F;可写；select&#x2F;poll首先要把文件描述符列表复制到内核，让内核去检查并标记哪些socket可读&#x2F;可写，然后再将文件描述符列表复制回用户态，在用户空间对socket进行读写。总共2次遍历，2次复制。时间复杂度O(n)</li>
<li>epoll维护红黑树[时间复杂度<code>O(logn)</code>]+链表，能够解决C10K问题</li>
</ol>
</li>
<li>边缘触发和水平触发 - select&#x2F;poll只支持LT水平触发，epoll支持LT和ET两种</li>
</ol>
<h5 id="Linux下的三种IO复用方式：epoll、select和poll"><a href="#Linux下的三种IO复用方式：epoll、select和poll" class="headerlink" title="Linux下的三种IO复用方式：epoll、select和poll"></a>Linux下的三种IO复用方式：epoll、select和poll</h5><ol>
<li>select:<ol>
<li>所有文件描述符在用户态被加入其文件描述符集合，每次调用都需要将整个集合拷贝到内核态</li>
<li>使用线性表描述文件描述符集合，文件描述符有上限</li>
<li>每次执行select或poll调用时，它们会采用遍历的方式，遍历整个文件描述符集合去判断各个文件描述符是否有活动</li>
<li>只能工作在相对低效的LT模式下(Level Trigger, 电平触发)</li>
</ol>
</li>
<li>poll:<ol>
<li>所有文件描述符都是在用户态被加入其文件描述符集合的，每次调用都需要将整个集合拷贝到内核态</li>
<li>使用链表来描述文件描述符集合</li>
<li>每次执行select或poll调用时，它们会采用遍历的方式，遍历整个文件描述符集合去判断各个文件描述符是否有活动</li>
<li>只能工作在相对低效的LT模式下(Level Trigger, 电平触发)</li>
</ol>
</li>
<li>epoll:<ol>
<li>将整个文件描述符集合维护在内核态，每次添加文件描述符的时候都需要执行一个系统调用(系统调用的开销很大， 因此在有很多短期活跃连接的情况下，epoll可能会慢于select和poll)</li>
<li>底层通过红黑树来描述文件描述符集合，并且维护一个ready list，将事件表中已经就绪的事件添加到这里，在使用epoll_wait调用时，仅观察ready list中有没有数据即可<ol>
<li>待检测的socket加入到自己维护的红黑树中</li>
<li>epoll_wait从链表中取出已经就绪的socket</li>
<li>红黑树的增删改时间复杂度是O(logn)比bitsmap和动态数组的O(n)效率更高</li>
<li>不用去遍历哪个可读&#x2F;可写-&gt;取出来就处理（链表对象是通过回调函数添加的）</li>
<li>另外，epoll仍旧需要把数据从内核态拷贝到用户态</li>
</ol>
</li>
<li>不需要遍历整个文件描述符集合，当有活动产生时，会自动触发epoll回调函数通知epoll文件描述符，然后内核将这些就绪的文件描述符放到之前提到的ready list中等待epoll_wait调用后被处理</li>
<li>epoll同时支持LT和ET模式(Edge Trigger, 边沿触发)<ol>
<li>LT会去遍历在epoll事件表中每个文件描述符，来观察是否有我们感兴趣的事件发生，如果有（触发了该文件描述符上的回调函数），epoll_wait就会以非阻塞的方式返回。若该epoll事件没有被处理完（没有返回EWOULDBLOCK），该事件还会被后续的epoll_wait再次触发</li>
<li>ET在发现有我们感兴趣的事件发生后，立即返回，并且sleep这一事件的epoll_wait，不管该事件有没有结束 -&gt; 使用ET模式必须保证fd是非阻塞的，每次调用read和write的时候都必须等到他们返回EWOULDBLOCK</li>
</ol>
</li>
<li>监测的fd数量较小，且各个fd都很活跃的情况下，建议使用select和poll，当监听的fd数量较多，且单位时间仅部分fd活跃的情况下，使用epoll会明显提升性能</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/default-index/page/2/">2</a><a class="extend next" rel="next" href="/default-index/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Make1tRight"
      src="/uploads/xiaoxin.jpg">
  <p class="site-author-name" itemprop="name">Make1tRight</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/make1tRight" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;make1tRight" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:xliang9809@163.com" title="E-Mail → mailto:xliang9809@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Make1tRight</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
